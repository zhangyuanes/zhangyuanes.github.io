<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>上线流程与规范</title>
      <link href="/2022/09/14/record/shang-xian-gui-fan-yu-liu-cheng/"/>
      <url>/2022/09/14/record/shang-xian-gui-fan-yu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="业务需求评审"><a href="#业务需求评审" class="headerlink" title="业务需求评审"></a>业务需求评审</h2><ul><li>需求预串：了解这一期产品需求，判断是否合理，方案实现代价，带来的业务价值</li><li>上下游依赖确认：梳理上下游调用链路，涉及的影响面和改动范围，上下游相关人员介入</li><li>需求正式串：本期需求正式拉通，深入理解需求内容与意义</li><li>需求确认与评审：明确项目标和收益，判断需求合理型，明确项目迭代周期，包括概要方案的设计讨论</li><li>开始技术方案评审：需求确认完成进入技术方案评审阶段</li></ul><h2 id="技术方案设计"><a href="#技术方案设计" class="headerlink" title="技术方案设计"></a>技术方案设计</h2><ul><li>开发方案：概要设计与详细设计，包括设计文档/说明/简图</li><li>测试方案：包含准入case设计，功能测试方案，服务测试方案等</li><li>监控预案设计：监控&amp;报警设计，回滚预案设计等</li></ul><h2 id="技术方案评审"><a href="#技术方案评审" class="headerlink" title="技术方案评审"></a>技术方案评审</h2><ul><li>方案详细设计：需求评审之后技术团队要做详细设计，明确相关困难点与解决方案思路，内部review通过</li><li>确认开发排期：预估工作量，人力投入，确定开发、提测、联调、上线等时间点</li><li>开始开发：技术方案确认完成进入开发</li></ul><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ul><li>GIT分支开发：从主干创建新的开发feature分支</li><li>UT（Unit Test）：开发过程要求必编写UT，且要求新feature代码覆盖率超过30%，覆盖核心功能</li><li>自测：开发完成后，完成自测功能，预期功能效果、性能稳定性、diff影响面心里要有数</li><li>CR（Code Review）：确认代码实现合理性，准确判断代码异常情况，至少2名同学CR，工程owner必须参与CR</li><li>联调：上下游服务联合调试，预期功能效果验证，全链路问题追查</li><li>开始提测：rebase主干分支代码进入提测阶段<br>资源版本管理</li><li>资源版本管理<ul><li>代码、配置及脚本全部入git，配置过大的话走数据资源发布方案</li></ul></li><li>数据资源：<ul><li>配置/小词典（&lt;10M），可以作为代码一部分入git管理。</li><li>本地配置（开关等）/词典/模型：建议进词典平台管理，统一管理</li><li>在线服务大词典接入数据平台管理统一管理</li><li>引擎词典进辅表<br>CodeReview</li></ul></li><li>CR标准：可读性、合理性、正确性、稳定性、高性能、安全性<ul><li>代码风格：Google C++ Style，<a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html</a></li><li>实现逻辑：正确高效</li><li>异常判断：泄漏、空指针判断、doube free、锁的使用、边界检查，如果需要可以利用扁鹊等工具来辅助</li><li>性能是否是高效的方案：放在压测部分评估</li><li>有没有安全问题（异常query/core query/注入）</li><li>CR条件：<ul><li>至少2名同学CR（有经验且通过模块串讲）</li><li>CR 必须全部通过</li><li>工程服务Owner必须参与CR</li></ul></li></ul></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>测试准入：提测后QA根据这期需求和开发功能点开发测试用例，开发提测走case准入与基线回归</li><li>功能测试：根据测试Case进行功能验证，交付自动化脚本，并进行老功能回归测试（含资损及P1&amp;P2级别Case）</li><li>diff测试：对关键list接口进行diff测试，需要研发确认diff结果</li><li>性能测试：压测时间20分钟以上进行测试版本及基线版本性能对比，性能降低超过5%需要记账或者打回</li><li>联调测试：上下游测试同学需要在日常、预发、灰度、线上进行全链路Case的走查验证</li><li>测试结论：提测后发现的BUG都需要重走开发流程重新提测；测试完成后测试产出测试报告，产品走查验证效果</li><li>开始上线：merge主干进入上线阶段</li></ul><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><ul><li>上线准备：上线前需要确定发布方案、预期影响、回滚方案，提前加好报警与监控，</li><li>发布评审：发邮件走上线审批，带上测试报告与产品走查结论；重大项目上线必要时需要拉会讨论明确细节</li><li>预发上线：预发流程上线，冒烟与功能check，观测至少一天效果</li><li>灰度上线：预发验证无问题，灰度发布线上环境，冒烟与功能check，观测至少一天效果，灰度需要有等待时间&gt;20分钟，进行流量验证</li><li>生产上线：灰度验证无问题，生产分机房分批次发布上线，分批过程必须有冒烟和功能check</li><li>生产check：生产发布后，需要分批冒烟和功能验证，上线完成后需要观测服务日志与指标监控一段时间，确认上下有服务正常</li><li>开始业务迭代终止流程：生产check无误后进入最终流程</li></ul><h2 id="业务需求结束"><a href="#业务需求结束" class="headerlink" title="业务需求结束"></a>业务需求结束</h2><ul><li>功能验证：产品+研发+测试验证线上效果与服务状态，验证异常需要判断是否立刻回滚或者走紧急修复，紧急修复需要重走开发流程重新上线；验证无异常，本次迭代周期结束，进入下一次产品需求迭代</li></ul><h2 id="日常开发迭代"><a href="#日常开发迭代" class="headerlink" title="日常开发迭代"></a>日常开发迭代</h2><ul><li>严禁除服务owner外的同学使用线上admin权限操作线上服务机器，如果需要操作需要审批且跟服务owner确认操作方案，一起操作；</li><li>严禁使用类似pgm的集群命令操作线上集群，稳定性性相关同学紧急处理线上问题除外；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Record </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Record </tag>
            
            <tag> 发布流程 </tag>
            
            <tag> 上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码规范一览（必要性）</title>
      <link href="/2021/08/23/kai-keng/coding-style/"/>
      <url>/2021/08/23/kai-keng/coding-style/</url>
      
        <content type="html"><![CDATA[<h2 id="google-style"><a href="#google-style" class="headerlink" title="google style"></a>google style</h2><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/">Google开源项目风格指南</a></p><h2 id="关于代码风格其他想说的话"><a href="#关于代码风格其他想说的话" class="headerlink" title="关于代码风格其他想说的话"></a>关于代码风格其他想说的话</h2><p>在与团队的合作中，重要的是遵守团队或者项目的代码风格，书写符合要求的代码，写好注释，写好测试。</p><p>在书写代码或者完成需求的过程中，我一般会使用issue或者md的方式在记录整个过程——包括遇到的问题、分析出现的原因、解决的方法、参考资料等——这样在复盘或者总结的时候不至于完全忘记。</p><p>在构建一个复杂的内容时，有时候也需要输出必要的 <code>sh</code> 也就是执行脚本，将 cmd 或者 bash 书写成sh，在其中写上必要的注释，针对不同的demo或演示效果输出不同的 sh，放在scripts 文件夹内，这样在别人接手项目或者是自己几个月之后再次接手项目可以快速把项目 run 起来，不然很多时候会出现自己不知道自己做了什么。</p><p>接上文，其实这个思想也可以理解为“乙方思想”，即在一段时间内完成一个标准内容的输出，可以输出文档和演示交付。有点像写作业、考试，在规定时间内完成内容，好坏再议，这样可以很好的培养自己的时间意识，不拖沓，能在有限时间内完成任务。这样的思想指导下，确立明确的目标，标准和执行方式就已经有PDCA（Plan Do Check Act）的味道了。</p>]]></content>
      
      
      <categories>
          
          <category> 开坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序Sort全整理（C++实现）</title>
      <link href="/2021/08/11/ji-lu/c/pai-xu-quan-zheng-li/"/>
      <url>/2021/08/11/ji-lu/c/pai-xu-quan-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="基础排序"><a href="#基础排序" class="headerlink" title="基础排序"></a>基础排序</h2><p><img src="https://gitee.com/yanbo01haomiao/pic/raw/master/assets/sort.png" alt="基础排序整理表格"></p><p>关键词说明：</p><ul><li><code>稳定性</code>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，<code>r[i]=r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是<strong>稳定</strong>的；否则称为<strong>不稳定</strong>的。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。</p><p>稳定性：稳定</p><p>平均时间复杂度：$$O(n^2)$$</p><p>C++实现：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 冒泡排序 * 比较相邻的元素。如果第一个比第二个大，就交换它们两个； * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； * 针对所有的元素重复以上的步骤，除了最后一个； * 重复步骤1~3，直到排序完成。 * @param arr  */</span><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> swap_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        swap_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果相邻的元素前面比较大，就需要交换</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                swap_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//end loop j</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>swap_<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// end loop i</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。</p><p>稳定性：稳定</p><p>平均时间复杂度：$$O(n^2)$$</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 插入排序 * 插入排序是一种简单直观的排序算法。 * 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 * 1、 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。 * 2、 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。 * 3、 重复上述过程直到最后一个元素被插入有序子数组中。 * @param arr  */</span><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> value_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 从第二个元素开始</span>        value_ <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先记录一下这个元素</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> value_<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            pos<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从后往前找到value_的位置pos</span>        arr<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> value_<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。</p><p>稳定性：不稳定</p><p>平均时间复杂度：$$O(n^2)$$</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 选择排序 * 是一种交换排序算法，是冒泡的一种改进 * 1、在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 * 2、从剩余未排序元素中继续寻找，然后放到已经排序序列的末尾 * 3、重复第二步直至所有元素排列完毕 * 注意：这里只需要记录下标，最后再交换 * @param arr  */</span><span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> min_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        min_ <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>min_<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到后面更小的元素就记录一下</span>                min_ <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min_ <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="希尔排序（缩小增量排序）"><a href="#希尔排序（缩小增量排序）" class="headerlink" title="希尔排序（缩小增量排序）"></a>希尔排序（缩小增量排序）</h2><p>希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至<code>1</code>，完成排序。</p><p>希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量<code>di</code>逐渐缩小，分组数减少，各组的记录数增多，但由于已经按<code>di−1</code>分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。</p><p>在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量<code>d</code>就为<code>1</code>。</p><p>稳定性：不稳定</p><p>平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n^1.3)到O(n^2)之间。</p><h2 id="快速排序-重要"><a href="#快速排序-重要" class="headerlink" title="快速排序(重要)"></a>快速排序(重要)</h2><p>1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准，称为<code>pivot</code>;</p><p>2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；</p><p>3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。</p><p>稳定性：不稳定</p><p>平均时间复杂度：$$O(nlogn)$$</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 快速排序  * 1、 从数列中挑出一个元素，称为"基准"（pivot） * 2、 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。 *     在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 * 3、 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 * @param arr  */</span><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> low<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">--</span>high<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>low<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 扫描完成，基准位置确定</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回基准的位置</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆：</p><p>1、完全二叉树或者是近似完全二叉树。</p><p>2、大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序。</p><p>堆排序在选择排序的基础上提出的，步骤：</p><p>1、建立堆</p><p>2、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素。</p><p>稳定性：不稳定</p><p>平均时间复杂度：$$O(nlogn)$$</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 堆排序 * @note 堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。 * 尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。 *  */</span><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"After heapInsert:"</span><span class="token punctuation">;</span>    <span class="token function">displayArr</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token operator">--</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>last <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token operator">--</span>last<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//递归检查父节点</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> heapSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> largest <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> largest<span class="token punctuation">;</span>        left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序。</p><p>稳定性：稳定</p><p>平均时间复杂度：$$O(nlogn)$$</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 归并排序 * 递归法 * 1、 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 * 2、 设定两个指针，最初位置分别为两个已经排序序列的起始位置 * 3、 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 * 4、 重复步骤3直到某一指针到达序列尾 * 5、 将另一序列剩下的所有元素直接复制到合并序列尾 *  * 迭代法 * 1、 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素 * 2、 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素 * 3、 重复步骤2，直到所有元素排序完毕，即序列数为1 * @param arr  */</span><span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">temp</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">internalMergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">internalMergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">internalMergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> left<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">internalMergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergeSortedArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> left<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">mergeSortedArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> temp<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> middle<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> middle <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> middle<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>思想：如果比元素<code>x</code>小的元素个数有<code>n</code>个，则元素<code>x</code>排序后位置为<code>n+1</code>。</p><p>步骤：</p><p>1）找出待排序的数组中最大的元素<code>max_number</code>；</p><p>2）统计数组中每个值为i的元素出现的次数，存入数组<code>C</code>的第<code>i</code>项；</p><p>3）对所有的计数累加（从<code>C</code>中的第一个元素开始，每一项和前一项相加）；</p><p>4）反向填充目标数组：将每个元素<code>i</code>放在新数组的第<code>C(i)</code>项，每放一个元素就将<code>C(i)</code>减去<strong>1</strong>。</p><p>稳定性：稳定</p><p>时间复杂度：$$O(n+k)$$k是待排序数的范围。</p><pre class=" language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">/** @brief 计数排序  @param array 数组指针  @param nLength_ 数组的最大长度  @param nMaxNumber_ 数组元素中的最大值  @note   计数排序的核心思想(来自算法导论）：  计数排序要求待排序的n个元素的大小在[0, k]之间，并且k与n在一个数量级上，即k=O(n).  对于每一个输入元素x, 确定小于等于x的个数为i。利用这一信息，就可以把元素x放到输出数组  的正确位置,即把元素x放到输出数组下标为i-1的位置。  重要说明：  1. 计数排序要求待排序的n个元素的大小在[0, k]之间，并且k与n在一个数量级上，即k=O(n).  此时使用计数排序可以把时间复杂度降到O(n)上。  2. 计数排序不是基于比较的排序算法，它基于计数策略。  3. 写计数排序算法时，应该把它写成稳定排序的。  4. 计数排序还是原址排序，它需要借助额外的内存空间。  任何比较排序算法的时间复杂度的上限为O(NlogN), 不存在比o(nlgN)更少的比较排序算法。  如果想要在时间复杂度上超过O(NlogN)的时间复杂度，肯定需要加入其它条件。计数排序就加入  了限制条件，从而使时间复杂度为O(N).  **/</span>  <span class="token keyword">void</span> <span class="token function">CountingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nLength_<span class="token punctuation">,</span> <span class="token keyword">int</span> nMaxNumber_<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 参数的合法化检测</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> array <span class="token operator">||</span> nLength_ <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> nMaxNumber_ <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 统计待排序数组中每一个元素的个数</span>      <span class="token comment" spellcheck="true">// 注意：此处new出来的数组的大小为nMaxNumber_ + 1, 用于统计[0, nMaxNumber_]范围内的元素</span>      <span class="token keyword">int</span><span class="token operator">*</span> ArrayCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nMaxNumber_ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nLength_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token operator">++</span>ArrayCount<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 此处计算待排序数组中小于等于第i个元素的个数.</span>      <span class="token comment" spellcheck="true">// 备注：如果要进行大到小的排序，就计算大于等于第i个元素的个数, 也就从后向前进行累加;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nMaxNumber_ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          ArrayCount<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> ArrayCount<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 把待排序的数组放到输出数组中, 为了保持排序的稳定性，从后向前添加元素</span>      <span class="token keyword">int</span><span class="token operator">*</span> ArrayResult <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nLength_<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nLength_ <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> _nIndex <span class="token operator">=</span> ArrayCount<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 元素array[i]在输出数组中的下标</span>          ArrayResult<span class="token punctuation">[</span>_nIndex<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 因为可能有重复的元素，所以要减1,为下一个重复的元素计算正确的下标;</span>          <span class="token operator">--</span>ArrayCount<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 交换数据并释放内存空间</span>      <span class="token function">memcpy</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> ArrayResult<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> nLength_<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> ArrayCount<span class="token punctuation">;</span>      ArrayCount <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> ArrayResult<span class="token punctuation">;</span>      ArrayResult <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 测试代码</span>  <span class="token comment" spellcheck="true">/***************    main.c     *********************/</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">PrintArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nLength_<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> test<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"排序前："</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">PrintArray</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">CountingSort</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"排序后："</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>      <span class="token function">PrintArray</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打印数组函数</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">PrintArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nLength_<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">nullptr</span> <span class="token operator">==</span> array <span class="token operator">||</span> nLength_ <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nLength_<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>步骤：</p><p>1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：</p><p>2）寻访序列，并且把记录一个一个放到对应的桶子去；</p><p>3）对每个不是空的桶子进行排序。</p><p>4）从不是空的桶子里把项目再放回原来的序列中。</p><p>时间复杂度：$$O(n+C)$$ <code>C</code>为桶内排序时间。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * @brief 桶排序 * 原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序 * （有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）， * 最后将各个桶中的数据有序的合并起来。 * 1、 找出待排序数组中的最大值max、最小值min * 2、 桶的数量为(max-min)/arr.length+1 * 3、 遍历数组 arr，计算每个元素 arr[i] 放的桶 * 4、 每个桶各自排序 * 5、 遍历桶数组，把排序好的元素放进输出数组 * @param arr  * @note 还有bug未解决 */</span><span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  min_num <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>    <span class="token keyword">int</span>  max_num <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        min_num <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span>min_num<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        max_num <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>max_num<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>min_num <span class="token operator">==</span> max_num<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bucketNum <span class="token operator">=</span> <span class="token punctuation">(</span>max_num <span class="token operator">-</span> min_num<span class="token punctuation">)</span> <span class="token operator">/</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">hasNum</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">max_</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">min_</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        bid <span class="token operator">=</span> <span class="token function">bucket</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> min_num<span class="token punctuation">,</span> max_num<span class="token punctuation">)</span><span class="token punctuation">;</span>        min_<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">=</span> hasNum<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">?</span> std<span class="token operator">::</span><span class="token function">min</span><span class="token punctuation">(</span>min_<span class="token punctuation">[</span>bid<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        max_<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">=</span> hasNum<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">?</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>max_<span class="token punctuation">[</span>bid<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        hasNum<span class="token punctuation">[</span>bid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// cout &lt;&lt; "min_数组 : " &lt;&lt; endl;</span>    <span class="token comment" spellcheck="true">// displayArr(min_);</span>    <span class="token comment" spellcheck="true">// cout &lt;&lt; "max_数组 : " &lt;&lt; endl;</span>    <span class="token comment" spellcheck="true">// displayArr(max_);</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lastMax<span class="token operator">=</span> max_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hasNum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> min_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> lastMax<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastMax <span class="token operator">=</span> max_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">bucket</span><span class="token punctuation">(</span><span class="token keyword">long</span> num<span class="token punctuation">,</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span> <span class="token keyword">long</span> min<span class="token punctuation">,</span> <span class="token keyword">long</span> max<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">*</span> len <span class="token operator">/</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面经整理</title>
      <link href="/2021/05/27/ji-lu/c/c-mian-jing-zheng-li/"/>
      <url>/2021/05/27/ji-lu/c/c-mian-jing-zheng-li/</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><ul><li><p>南京场，招银网络科技面经：<a href="https://www.nowcoder.com/discuss/125087">https://www.nowcoder.com/discuss/125087</a></p><ul><li><p>一面:基础技术</p><ul><li><p>手写简单的一个线程: </p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>thread <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  demo<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>手写多个线程按顺序执行</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">;</span>mutex m<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>thread <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  demo<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>thread <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  demo2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;condition_variable></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>mutex mutex_<span class="token punctuation">;</span>condition_variable convar<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">threa1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"threa1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  convar<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">threa2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">lc</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>  convar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lc<span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thre2"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>thread <span class="token function">demo2</span><span class="token punctuation">(</span>threa2<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token operator">::</span>thread <span class="token function">demo1</span><span class="token punctuation">(</span>threa1<span class="token punctuation">)</span><span class="token punctuation">;</span>  demo1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  demo2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"主线程执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>手写一定区间的随机数</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span></code></pre></li><li><p>给个序列，告知快排一次之后的序列</p></li><li><p>手写两个链表合并</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> a<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> b<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  ListNode <span class="token operator">*</span><span class="token operator">*</span> pre<span class="token operator">=</span><span class="token operator">&amp;</span>c<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token operator">></span>val<span class="token operator">></span>b<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token operator">*</span>pre<span class="token operator">=</span>a<span class="token punctuation">,</span> a<span class="token operator">=</span>a<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>a<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token operator">*</span>pre<span class="token operator">=</span>b<span class="token punctuation">,</span> b<span class="token operator">=</span>b<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span>pre<span class="token operator">=</span>a<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">*</span>pre<span class="token operator">=</span>b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>手写n<em>n矩阵中2</em>2的小正方形最大值</p></li></ul></li><li><p>二面</p><ul><li>扫码登录整个流程</li><li>序列中有一个数出现次数超过了三分之一次，如何快速找到<ul><li>对于超出<code>1/n</code>的都可以消去法进行计算, 一次消去n个不同的元素, 剩下的就是了</li><li>参考: <a href="https://blog.csdn.net/xuqingict/article/details/40181155">算法之找出数组中出现次数大于n/m的元素</a></li></ul></li></ul></li></ul></li></ul><ul><li><p>深信服面筋回馈牛油：<a href="https://www.nowcoder.com/discuss/119868">https://www.nowcoder.com/discuss/119868</a></p><ul><li><p>字典树: <a href="https://blog.csdn.net/qq_31964727/article/details/80862805">字典树详解</a></p></li><li><p>什么是字典树?</p><ul><li>首先字典树是一种数据结构,用于处理大量字符串. 优点在于利用字符串的公共前缀,在存储时节约存储空间,并在查询时最大限度的减少无谓的字符串比较.</li></ul></li><li><p>字典树有什么用?</p><ul><li>以最节约空间的方式存储大量字符串, 且存好后是有序的; 因为是有序的,故而字典树不仅可用于大量字符串的存储,还可用于大量字符串的排序.</li><li>快速查询某字符串s在字典树中是否已存在,甚至出现过几次; 因为当字典树预处理好之后,查询字符串s在当前的出现情况的效率为strlen(s),异常高效,故而常用于搜索引擎等.</li></ul></li><li><p>字典树实现思路</p><ul><li>首先我们已经知道了字典树是一种数据结构,而一个数据结构的重点就在于:<ul><li>怎么有规则的把数据存储下来</li><li>怎么有规则的去高效的得到自己需要的数据</li></ul></li></ul></li><li><p>跳表: <a href="https://blog.csdn.net/jinjiniao1/article/details/97246033">跳表</a></p><ul><li>跳表(skip list) 对应的是平衡树(AVL Tree)，是一种 插入/删除/搜索 都是 O(log n) 的数据结构。</li><li>它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热门的项目里用来替代平衡树，如 redis, leveldb 等。</li><li>因此跳表（skip list）表示，我们就不强制要求 1:2 了，一个节点要不要被索引，建几层的索引，都在节点插入时由抛硬币决定。</li><li>当然，虽然索引的节点、索引的层数是随机的，为了保证搜索的效率，要大致保证每层的节点数目与上节的结构相当。</li></ul></li></ul></li><li><p>深信服霸面：<a href="https://www.nowcoder.com/discuss/116845">https://www.nowcoder.com/discuss/116845</a></p><ul><li><p>手写memcopy</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">my_memcpy_byte</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>dst <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> src <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span> pdst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dst<span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span> psrc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 还不如全部都是用尾插法, 这样对所有情况都适用!</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pdst <span class="token operator">></span> psrc <span class="token operator">&amp;&amp;</span> pdst <span class="token operator">&lt;</span> psrc <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果出现内存覆盖,则尾使用尾拷贝</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      pdst <span class="token operator">=</span> pdst <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      psrc <span class="token operator">=</span> psrc <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>          <span class="token operator">*</span>pdst<span class="token operator">--</span> <span class="token operator">=</span> <span class="token operator">*</span>psrc<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>          <span class="token operator">*</span>pdst<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>psrc<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>进程间通信: 管道, socket, 系统IPC(信号, 信号量, 消息队列, 共享内存)</p></li><li><p>在TCP报文的画出三次握手的全过程。</p></li><li><p>一道智力题：100层楼，有两个玻璃球，有唯一一层，从该楼层及以下楼层扔下玻璃球不会碎，从该楼层以上扔玻璃球会碎，请用用两个玻璃球找出该层（最小的时间复杂度）。</p><ul><li>始终维持k次, 然后求k</li><li><a href="https://blog.csdn.net/coolws123/article/details/22998879"> 百度面试题 100层楼丢玻璃球问题</a></li></ul></li><li><p>手写</p><ul><li>删除s1中s2出现过的字符；</li><li>双向链表创建删除等；</li><li>给一个文件，合理匹配大括号小括号和中括号； // 使用栈来进行匹配</li></ul></li><li><p>MYSQL：创建一个表吧，三行三列。</p><ul><li>创建表<pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t_student<span class="token punctuation">(</span>  id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- id</span>  student_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- 姓名</span>  age <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- 年龄</span>  sex <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- 性别</span>  birthday <span class="token keyword">DATE</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- 生日</span>  tel <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">-- 电话号码</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span></code></pre></li><li>插入行<pre class=" language-sql"><code class="language-sql">  <span class="token comment" spellcheck="true">-- 单行</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t_student <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'2018-05-28'</span><span class="token punctuation">,</span><span class="token string">'18125864478'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t_student<span class="token punctuation">(</span>student_name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>tel<span class="token punctuation">)</span>   <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'2007-05-28'</span><span class="token punctuation">,</span><span class="token string">'18215864478'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 多行</span>  <span class="token comment" spellcheck="true">-- 只要每条INSERT语句中的列名和次序相同，也可以使用单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔：</span>  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t_student<span class="token punctuation">(</span>student_name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>sex<span class="token punctuation">,</span>birthday<span class="token punctuation">,</span>tel<span class="token punctuation">)</span>   <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">"钱七"</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'2007-05-28'</span><span class="token punctuation">,</span><span class="token string">'18215864478'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"李八"</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'2006-05-28'</span><span class="token punctuation">,</span><span class="token string">'18215864478'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> stu<span class="token punctuation">(</span>  id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>   name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span>ENGIN<span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> stu <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"33"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> stu <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"TT"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"TT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>ARP用来做什么？滑动窗口是?那个值代表什么意思？</p></li><li><p>linux网络编程熟悉吗？UNIX网络编程那本书你看过吗？</p></li><li><p>那好我来考考你：服务器端，接收多个客户端发来的数据，如何接收？</p></li><li><p>参考: <a href="https://blog.csdn.net/qq_41026740/article/details/83099707">Linux—-网络编程(TCP网络通信服务器客户端编程流程与其循环实现)</a></p></li></ul></li><li><p>深信服C++开发 一、二、HR面：<a href="https://www.nowcoder.com/discuss/116694">https://www.nowcoder.com/discuss/116694</a></p><ol><li>如何用数组实现链表的功能？<ul><li>(数组中存放一个结构体，一个表示数据，另外一个表示其下一个节点在数组中的index，以便于快速插入删除)</li></ul></li><li>linux下有哪些信号?<pre><code> - 参考: [SIGINT、SIGQUIT、 SIGTERM、SIGSTOP区别](https://blog.csdn.net/pmt123456/article/details/53544295)     - 常见信号</code></pre><table><thead><tr><th>信号英文名</th><th>信号数字表述</th><th>信号中文说明</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>挂断控制终端或进程</td></tr><tr><td>SIGINT</td><td>2</td><td>终止进程</td></tr><tr><td>SIGQUIT</td><td>3</td><td>终止进程并阐述dump文件</td></tr><tr><td>SIGKILL</td><td>9</td><td>强制终止进程</td></tr><tr><td>SIGALARM</td><td>15</td><td>系统调用alarm超时后产生，终止进程</td></tr><tr><td>SIGTERM</td><td>16</td><td>终止进程</td></tr><tr><td>SIGCHLD</td><td>18</td><td>子进程死，默认忽略该信号</td></tr><tr><td>SIGCONT</td><td>19</td><td>恢复进程执行，默认忽略该信号</td></tr><tr><td>SIGSTOP</td><td>20</td><td>终止进程</td></tr></tbody></table><ul><li>信号的来源<ul><li>非法内存</li><li>硬件故障</li><li>键盘</li><li>信号的处理方式:</li><li>默认：如果是系统默认的话，那就会终止这个进程</li><li>忽略：信号来了我们不处理，装作没看到   SIGKILL  SIGSTOP 不能忽略</li><li>捕获并处理</li><li>信号和中断的区别</li><li><a href="https://blog.csdn.net/qq_38619183/article/details/83097475">信号使用 信号和中断区别  linux  signal </a></li><li><a href="https://blog.csdn.net/weixin_31916083/article/details/90242575">linux信号机制</a></li></ul></li></ul></li><li>https中的pipeline?<pre><code> - 多个相同请求的时候一次返回(在一次tcp连接中完成多次请求) - [HTTP Pipeline](https://www.cnblogs.com/diantao/p/5336859.html)</code></pre></li><li>函数指针的作用?<pre><code> - 指针, 类型由函数的返回值和参数列表决定 - 可以通过函数指针实现函数调用,  - 可以用作形参进行传递 - 通过函数指针可以把函数调用者和背调函数分开, 函数调用者不需要知道具体是哪个函数被调用, 它只需要知道背调函数具有某种特定的返回值和形参列表即可</code></pre></li><li>如何实现一个非定长的结构体? <pre><code> - 在标准C和C++中，长度为0的数组是被禁止使用的。 - 不过在GNUC中，存在一个非常奇怪的用法，那就是长度为0的数组，比如Array[0]; - 这个特性是不可移植的 - 注意长度为0的数组, 并不是指针, 因为它不占用内存空间, 可以后期自己分配空间, 它应该是表示一个偏移量 - 长度为0的数组(a[0]) - [struct中长度为0的数组用途与原理](https://blog.csdn.net/tjcwt2011/article/details/80824505)</code></pre></li></ol></li></ul><pre class=" language-cpp"><code class="language-cpp">        <span class="token keyword">struct</span> line <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length<span class="token punctuation">;</span>        <span class="token keyword">char</span> contents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...ommit code here</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">struct</span> line <span class="token operator">*</span>thisline            <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> line <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> line<span class="token punctuation">)</span> <span class="token operator">+</span>this_length<span class="token punctuation">)</span><span class="token punctuation">;</span>            thisline<span class="token operator">-</span><span class="token operator">></span>length <span class="token operator">=</span> this_length<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre><code>7) strcpy实现方法及其缺点，strncpy？8) 野指针？9) linux io和标准io区别？    - 主要区别：        - 系统IO：不带缓冲机制，系统IO可以操作普通文件与驱动文件        - 标准IO：带缓冲机制，标准IO只可以操作普通文件。提供多种的格式的输入输出如(字符串、整形)        - 参考: [Linux中的系统IO与标准IO](https://blog.csdn.net/laifengyuan1/article/details/86620421)10) http网址访问过程，get post区别？- 二面:    - 谈谈io复用，select？        - fdset, fdzero    - 谈谈项目***享内存实现方法？    - linux下编译调试方法，如何调试内存泄露问题？        - 首先命令行工具: ps -aux (VSZ值)        - 静态代码分析工具: BEAM        - 动态分析工具: valgrind        - [Linux平台中调试C/C++内存泄漏方法](https://www.jianshu.com/p/c78c7c2535f1)    - 给几百万个网址，如何高效找出特定网址是否在其中?        - (布隆过滤器)布隆过滤器优缺点，如何解决其缺点？        - [详解布隆过滤器的原理、使用场景和注意事项](https://www.jianshu.com/p/2104d11ee0a2)        - [布隆过滤器及优缺点](https://blog.csdn.net/baidu_37964071/article/details/79873090)        - 什么是布隆过滤器            - 本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是`高效地插入和查询(不能删除)`，可以用来告诉你 “某样东西一定不存在或者可能存在”。            - 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。        - 实现原理            - bit 数组(如果想实现删除,就不能使用bit了)            - 多个哈希函数族    - 给一容量较大非法单词词典，如何判断某输入中是否有非法单词?- 建立字典树--实现一次遍历就可做出判断</code></pre><ul><li><p>深信服面经(中秋居然还面试，牛逼。。。)：<a href="https://www.nowcoder.com/discuss/116689">https://www.nowcoder.com/discuss/116689</a></p><ul><li>画堆排序过程，复杂度分析。<ul><li>首先构建大顶堆</li><li>然后将堆堆顶元素与末尾元素进行交换，使末尾元素最大。</li><li>然后继续调整堆</li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li></ul></li><li>画平衡二叉树建立过程。<ul><li>二叉查找树<ul><li>如果插入的数据比当前的节点大，并且节点的右子树为空，那么直接把当前的值插入到当前右子节点，如果不为空的话，那么递归查找右子树的位置，</li><li>同理如果插入的数据比节点小，并且节点的左子树为空，那么直接把值插入到节点的左节点，如果不为空，递归遍历节点的左子树，寻找插入的位置</li></ul></li><li>平衡调转: <a href="https://blog.csdn.net/qq_24336773/article/details/81712866">平衡二叉树(树的旋转)</a><ul><li>LL型调整: A的左孩子B, B的左孩子插入导致不平衡<ul><li>B调整为根</li><li>A调整为B的右节点</li><li>然后将BR-&gt;AL</li></ul></li><li>RR型调整: A的右孩子B, B的右孩子插入导致不平衡<ul><li>把B调转为根结点</li><li>把A调转为B的左节点</li><li>然后将BL-&gt;AR</li></ul></li><li>LR型调整: A的左孩子B, B的右孩子插入, C为新插入节点<ul><li>把C调转为新根</li><li>把A调整为C的右根, B调整为C的左节点</li><li>CL-&gt;BR, CR-&gt;AL</li></ul></li><li>RL型调整:<ul><li>把C调转为新根</li><li>把A调整为C的左根, B调整为C的右节点</li><li>CL-&gt;AR, CR-&gt;BL</li></ul></li></ul></li></ul></li><li>画红黑树构造过程。<ul><li>首先搜素树插入</li><li>然后红黑树调整<ul><li>此节点作为根节点或, 直接把本节点变成黑色</li><li>如果被插节点为黑色, 不用做</li><li>然后就是被插节点为红色:<ul><li>叔叔节点是红色<ul><li>(01) 将“父节点”设为黑色。</li><li>(02) 将“叔叔节点”设为黑色。</li><li>(03) 将“祖父节点”设为“红色”。</li><li>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</li></ul></li><li>叔叔节点是黑色，且当前节点是其父节点的右孩子<ul><li>(01) 将“父节点”作为“新的当前节点”。</li><li>(02) 以“新的当前节点”为支点进行左旋。</li><li>(03) 继续对“当前节点”进行操作。</li></ul></li><li>叔叔节点是黑色，且当前节点是其父节点的左孩子    <ul><li>(01) 将“父节点”设为“黑色”。</li><li>(02) 将“祖父节点”设为“红色”。</li><li>(03) 以“祖父节点”为支点进行右旋。</li></ul></li></ul></li></ul></li></ul></li><li>虚析构作用。<ul><li>防止内存泄漏</li></ul></li><li>什么叫重载，继承，隐藏。<ul><li>参数重载</li><li>继承/重写/覆盖</li><li>隐藏</li></ul></li><li>什么函数不能声明为virtual。<ul><li>静态函数</li><li>inline函数</li><li>构造函数</li></ul></li><li>extern C的作用。</li><li>讲一下快排。<ul><li>采用分治策略，一次排序后，将数据划分为两半，一半比某一个数小，另一半比某个数大。</li><li>然后利用递归，完成对数组的排序。</li></ul></li><li>算法题，O(n)内旋转字符串。</li><li>算法题，文件中有大量数字，排序并保存到结果文件中。</li><li>memcpy的实现。</li><li>TCP快重传。</li></ul></li><li><p>深信服C++面经 攒人品：<a href="https://www.nowcoder.com/discuss/116634">https://www.nowcoder.com/discuss/116634</a></p><ul><li>一面（30分钟）<ul><li>sizeof 各种基本类型 结构体 类</li><li>继承和多态<ul><li>继承<ul><li>子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；</li><li>子类可以拥有父类没有的属性和方法；</li></ul></li><li>多塔<ul><li>静态多态</li><li>动态多态</li></ul></li></ul></li><li>栈在实际编程的时候有哪些应用场景(深度搜索)</li><li>广搜用什么数据结构(queue, 队列)</li><li>浮点数判断是否相等</li><li>手写代码 <ul><li>字符串反转 有时间和空间复杂度限制<ul><li>reverse()</li></ul></li><li>字符串循环移位<ul><li>面试官让优化复杂度 没想出来(要用到上一题的字符串反转)</li></ul></li><li>统计一篇英文文章出现频率最高的十个单词<ul><li>TOP K问题(建堆 make_heap, pop_heap) </li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></li></ul></li></ul></li><li>new和malloc</li></ul></li><li>二面（40分钟）<ul><li>1.聊了将近20分钟项目</li><li>3.给了一张题表 面试官直接点题目号让我回答上面的问题 点了四个问题 都是比较简单的问题 概率 斐波那契数</li><li>4.问笔试编程题的一三题，木板那道说了自己的思路有把另外一个老哥用栈解法的思路说一遍，第三题比较简单</li><li>5.实现strcpy，要考虑内存重叠和特殊情况处理</li></ul></li></ul></li><li><p>2018深信服C++面经：<a href="https://www.nowcoder.com/discuss/116569">https://www.nowcoder.com/discuss/116569</a></p><ul><li><p>Q：象棋中马从一个位置跳到另一个位置的最少步数</p></li><li><p>A：手写BFS</p></li><li><p>Q：一次可以上一层台阶，也可以上两层台阶，到第N层有多少种走法</p></li><li><p>A：F[N]=F[N-1]+F[N-2] (动态规划问题)</p></li><li><p>Q：一分钟内经过公交车的概率为p，求三分钟内有公交车经过的概率</p></li><li><p>A：P=1-(1-p)^3</p></li><li><p>Q：strcpy和memcpy的区别</p></li><li><p>A：复制的内容不同，strcpy无需指定长度，遇到’\0’为止</p></li><li><p>Q：那strncpy呢？</p></li><li><p>A：我没用过</p></li><li><p>Q：你怎么判断两个struct相等？</p></li><li><p>A:我会选择重载==运算符，逐一比较成员变量是否相等</p></li><li><p>Q：那能不能用内存比较memcmp来判断呢？</p></li><li><p>A：不能，涉及字节对齐，可能有内存间隙，这里的值是随机的</p></li><li><p>Q：进程间的通信有哪些方式？</p></li><li><p>A：管道、有名管道、（信号、信号量、）共享内存、消息队列、socket</p></li><li><p>Q：epoll和select/poll的区别</p></li><li><p>A：</p><ul><li>epoll是实现I/O多路复用的一种方法,有水平触发（level trigger，LT，默认)和边缘触发（edge trigger，ET）两种工作模式，区别在于两种模式的返回就绪状态的时间不同。水平触发和select/poll的方式一样</li></ul></li><li><p>水平触发</p><ul><li>读：缓冲内容不为空返回读就绪</li><li>写：缓冲区还不满返回写就绪</li></ul></li><li><p>边缘触发</p><ul><li>读：<ul><li>缓冲区由不可读变为可读</li><li>新数据到达，缓冲区中待读数据变多时</li></ul></li><li>写：<ul><li>当缓冲区由不可写变为可写</li><li>当有旧数据被发送走，即缓冲区中的内容变少的时候</li></ul></li><li>epoll之所以高效，是因为epoll将用户关心的文件描述符放到内核里的一个事件表中，而不是像select/poll每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入就绪队列的描述符集合就行了。</li></ul></li><li><p>Q：在TCP连接中，服务端的socket要做哪些？</p></li><li><p>A：socket-&gt;bind-&gt;listen-&gt;accept-&gt;send/recv</p></li><li><p>Q：堆和栈的区别？</p></li><li><p>A：堆是一颗二叉树、栈是一个单向进出的线性结构</p></li><li><p>Q：堆排序和快排的区别？</p></li><li><p>A：快排的思想是分治，每次选择当前范围的第一个数作为标杆，然后再将这个范围的所有比它小的数放到他左边，大的放到他右边，由这个标杆的现在位置划分出两个范围，分别对这两个范围的数再重复这样的*作，直到范围大小为1</p></li><li><p>堆排序则是在建堆的时候保证堆顶最小，然后每次取堆顶</p></li><li><p>下面应该是面试官自己出的一些题目</p></li><li><p>Q:XML是什么结构？</p></li><li><p>A:树</p></li><li><p>Q：用过正则表达式吗？写一个32位IP地址的正则</p><ul><li>200-255: 2(5[0-4] | [0-4]\d)</li><li>0-100: [0-1]?\d{1,2}</li></ul></li><li><p>Q：进程和线程的区别？</p></li><li><p>A：这个没背，只回答上了几句话</p></li></ul></li></ul><ul><li><p>百度三面面经：<a href="https://www.nowcoder.com/discuss/136247">https://www.nowcoder.com/discuss/136247</a></p><ul><li>一面<ul><li>new/delete和malloc/free的区别</li><li>vector的结构？vector拷贝时发生什么<ul><li>拷贝<ul><li>元素的拷贝:<ul><li>对于没有拷贝构造函数的元素(用户未定义, 编译器也没有合成默认够构造函数), 直接使用memcopy</li><li>对于对于有拷贝构造函数的元素, 使用拷贝构造函数进行拷贝</li></ul></li><li>关于内存的问题: 对于拷贝构造构造或则赋值运算时, 新生成的vector的capacity恰好等于元素个数, 意味着插入查找一定会发生内存迁移</li></ul></li></ul></li><li>一个数组，只有一个数字出现奇数次，其余数字出现偶数次，如何得到这个数字？如果出现奇数次的数字有2个呢？<ul><li>对于一个数直接异或</li><li>对于两个数首先全部异或, 然后得到的结果为两个值得异或结果, </li><li>然后找到异或结果二进制表示为1的那一位, 意味着在这两个数在这一位上是不同的, 所以我们把数组按照这一位拆分为两个数组进行异或</li><li><a href="https://blog.csdn.net/weixin_34341117/article/details/92789765">一组数中，只有两个数只出现了奇数次，其他所有数都是成对出现的，请找出那两个数…</a></li></ul></li><li>给定一个ip地址，编码使得ip和32位整数呈双射关系<ul><li>a.b.c.d</li><li>int t =0;</li><li>t |= (int)a || (int)b&lt;&lt;8|| (int)c&lt;&lt;16 ||(int)d&lt;&lt; 24</li></ul></li><li>50个红球50个蓝球，放到2个袋子里，从两个袋子各取1个球，让2个都是红球的概率最大，怎么放<ul><li>两个箱子概率是1/2，选中某个箱子后又有选择的是不是红球的概率，</li><li>所以最大概率就是一个红球放在一个箱子里，其余的99个球全放到另一个箱子。</li><li>这样抓到红球的概率=0.5+0.5*（49/99）约等于0.75，这样为最大概率。</li><li>这样两个都是红球的概率=1*(49/99)=大概约等于0.5</li></ul></li><li>进程和线程的区别</li><li>时间复杂度为O(nlogn)的排序算法有哪些？简述快速排序的过程<ul><li>归并排序,时间复杂度O(nlogn), 空间复杂度o(n)<ul><li>分治的思想, 按空间位置划分</li><li>将数组按照选定值得前一半和后一半划分</li><li>然后在前一半中继续迭代, 后一半中继续迭代</li><li>然后将两段合并为有序的段(合并过程需要额外的空间)</li></ul></li><li>快速排序,时间复杂度O(nlogn), 空间复杂度o(1)<ul><li>分治的思想, 按值划分</li><li>将大于选定值得分为一段, 将小于等于该值得分为后一段, </li><li>然后在前一段/后一段中继续划分</li></ul></li><li><a href="https://www.cnblogs.com/zpchya/p/10775866.html">排序—时间复杂度为O(nlogn)的两种排序算法</a></li></ul></li><li>C++内存分布</li><li>重载和重写的区别<ul><li>静态多态</li><li>动态多态</li></ul></li><li>Linux下删除同一文件夹下所有满足条件的文件<ul><li><code>rm -rf $(find ./ -name &#39;test*&#39;)</code></li></ul></li><li>介绍项目</li></ul></li><li>二面<ul><li>1个32位无符号整数，计算二进制格式下有多少个1，不通过循环怎么做</li><li><code>bitset&lt;32&gt;m(a); m.count</code></li><li>cmake和makefile的区别<ul><li>make工具就根据makefile中的命令进行编译和链接的, 但是规则编写比较麻烦,尤其是项目较大的时候</li><li>cmake是一个输出makefile的工具, 它的配置文件时cmakelist, 规则还比较简单, 一般都是用它来配置项目的编译</li></ul></li><li>简述cmake到可执行文件的过程<ul><li>cmake根据cmakelist, 生成makefile</li><li>make根据makefile生成exe和库文件</li></ul></li><li>进程和线程的区别</li><li>git pull和git fetch的区别<ul><li>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</li><li>git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</li></ul></li><li>用数据结构模拟浏览器前进后退的操作<ul><li>栈结构, 后进先出</li></ul></li></ul></li><li>三面<ul><li>2g物理内存，new一个3g的数组时发生什么？<ul><li><a href="http://www.sohu.com/a/139709634_467784">在物理内存为1G的计算机中能否malloc(1.2G)？</a></li><li>首先, 常见系统都是支持虚拟内存机制的, 而不是直接使用物理内存</li><li>其次, new最终会调用malloc进行内存分配, malloc分配内存时大于128k会在文件映射区分配内存, 并且分配的时候, 是分配虚拟内存空间, 而不是物理内存.</li><li>当访问数组时, 如果物理页不存在则触发缺页中断, 由操作系统负责根据外存地址将数据加载如内存中, 如果内存已满, 则会触发缺页置换(fifo, lru, lfu)</li></ul></li><li>平衡二叉树的特性，红黑树的特性，判断是否为平衡二叉树<ul><li>平衡二叉树<ul><li>每个节点最多2个子节点</li><li>左子树的键值小于根的键值，右子树的键值大于根的键值。</li><li>任何节点的两个子树的高度最大差为1</li></ul></li><li>红黑树<ul><li>除了平衡二叉树外</li><li>每个节点非红即黑</li><li>根结点为黑, 叶子结点为黑</li><li>每个红节点的子节点一定位黑</li><li>任意一个节点到它的叶子节点的所有路径拥有相同的黑色节点</li></ul></li></ul></li><li>虚函数和纯虚函数</li><li>智能指针如何实现</li><li>学过操作系统吗？学过网络吗？没有</li><li>进程和线程的区别，多线程和多进程的优缺点</li><li>介绍项目亮点</li><li>A-H中选3个字母，可以重复，求组合数: <code>8*8*8</code></li></ul></li></ul></li><li><p>百度凉径：<a href="https://www.nowcoder.com/discuss/126809">https://www.nowcoder.com/discuss/126809</a></p><ul><li>先问项目，把其中一个项目用编程把重要地方实现出来，然后把里面的进程和线程关系理清楚，最好通过图形进行说明一下</li><li>进程之间怎么信息共享，相互通信，本人太渣，只回答出两个</li><li>问有没有用过shrink_to_fit，说一下作用，为什么用<ul><li>收缩容器的实际内存空间收缩为现在的真是内存空间, 也就是让capacity()和size()返回值相等</li></ul></li><li>线程与线程之间怎么通信，用的什么机制<ul><li>临界区</li><li>互斥锁</li><li>信号量</li><li>信号</li></ul></li><li>虚函数的两种情形下怎么用，为什么用虚函数</li><li>手撕代码<ul><li>第一个字符串比较，利用三种方法写的，面试官比较喜欢第三种，说挺好</li><li>第二个是链表，用了4种方法，第四种是在面试官的提醒下完成的。</li><li>第三个回溯法，本人对回溯法没有了解太深，写的代码太麻烦，想不出第二种</li></ul></li></ul></li></ul><ul><li>度小满金融面经：<a href="https://www.nowcoder.com/discuss/115577">https://www.nowcoder.com/discuss/115577</a><ul><li>一面：<ul><li>1.进程与区别</li><li>2.3次握手与各个状态</li><li>3.DNS解析过程<ul><li>本地到本域名dns, 使用递归查询</li><li>如果本域名dns不能找到, 则它作为客户端使用迭代查询</li></ul></li><li>4.ARP解析过程<ul><li>首先查找自身ARP缓存表</li><li>如果没有, 则向直连设备发送一个广播报文, 寻找目标ip</li><li>接受者收到之后会进行检查, 如果发现自己是目标, 则以单播的形式将自身mac地址给广播发送者</li></ul></li><li>5.事务特性<ul><li>ACID; 原子性, 一致性, 独立性, 持久性</li></ul></li><li>6.算法：<ul><li>一个字符串中{}  [ ]  ()匹配问题，好像是leecode上面的~</li><li>stack计算</li></ul></li></ul></li><li>二面：<ul><li>1.TCP ,UDP<ul><li>TCP面向连接, 通信前需要建立连接, 为一对一通信</li><li>UDP无连接, 可以一对多通信</li><li>TCP有流量控制, 拥塞控制, 序号, 确认和重传机制, 其为可靠传输, 无差错, 无丢失, 按序到达</li><li>UDP为尽最大努力传输, 不保证可靠新</li><li>TCP报文长度为动态报文长度, 可以合并和拆分, 头部为20字节</li><li>UDP报文无拆分, 不合并, 首部8字节</li></ul></li><li>2.Linux命令，延伸：netstat，top，free -m 都显示了什么有什么含义？<ul><li>top 监控linux系统状况, cpu,内存等</li><li>netstat 查看内核访问网络相关信息的进程, 还提供TCP链接, tcp,udp监听等功能</li><li>free -m 查看内存, m表示按m为单位显示</li></ul></li><li>3.进程间通讯，你用过什么？</li><li>4.文件系统，文件名和文件权限是存在一块的吗？<ul><li>不是,,,</li><li>（innode不存文件名，存权限，访问日期，指向数据的指针等等）</li></ul></li><li>5.一个文件的md5码会因为该文件名而更改吗？<ul><li>md5加密只跟数据区相关,按照LINUX的储存形式上说就是, 文件名和inode的改动不会引起md5发生变化</li></ul></li><li>6.从网上下载的各种 .ios软件包会改变md5码吗？<ul><li>只要数据没变,就不会</li></ul></li><li>7.a,b两个文件，a文件存url，有1亿行。b文件存域名，有 1万行。  要求：找出a中不在b文件中的？时间复杂度是多少？  没有内存限制。<ul><li>可以尝试使用布隆过滤器, 但是可能会存在找不全的问题, 因为布隆过滤器是基于概率的, 复杂度为O(k), k为哈希函数的个数</li><li>hash + 字典树, </li><li>回答：1.先提取a文件的url中的域名（这个不会，是用awk吗？）2.hash+字典树</li></ul></li></ul></li><li>三面：<ul><li>1.DNS解析过程</li><li>2.输入url的过程，知道的协议都说说，IP路由选路，ARP等等</li><li>3.有查看过三次握手中socket状态吗？就是书本上的那些状态有看过吗？</li></ul></li></ul></li></ul><ul><li><p>百度三面面经，攒人品！！！：<a href="https://www.nowcoder.com/discuss/114896">https://www.nowcoder.com/discuss/114896</a></p><ul><li><p>一面：</p><ul><li><p>编写shell脚本  查看一个文件，大小大于10M就删除，否则打印内容</p><ul><li>rm -rf <code>ls -al | awk &#123;&#39;if($5&gt;10*1024)&#123;print $NF&#125;&#39;&#125;</code></li></ul></li><li><p>core dump，出现段错误的原因</p><ul><li>访问非法地址空间(不存在地址, 受保护地址)</li><li>试图修改只读数据</li></ul></li><li><p>哈希表 如何实现 冲突解决</p><ul><li>一个是线性表(vector)</li><li>一个是桶(单链表)</li><li>开链法(其他解决方案: 开放寻址法)</li></ul></li><li><p>hash table用什么实现，最差插入时间复杂度o(1)</p><ul><li>用开链法实现的</li></ul></li><li><p>函数值传递一个百万个元素的vector会怎么样？为什么?</p><ul><li>值传递?</li><li>会存在大量的拷贝构造, 极大的浪费内存, 而且应该会栈溢出</li></ul></li><li><p>c 内存分布?</p></li><li><p>一个二维地图，每个格子有不同分数，求机器人从左下到右上的最大分数的路径。</p><ul><li>动态规划</li></ul></li></ul></li><li><p>二面</p><ul><li>求一个数组逆序对<ul><li>并归排序, 交换的就是它!</li></ul></li><li>三次握手四次挥手的状态字，为什么3次，为什么4次</li><li>求最大连续子数组<ul><li>状态转换: 当前状态 = max(前面状态+当前值, 当前值);</li></ul></li><li>一次完整的http链接过程，应用层到数据链路层，越详细越好</li><li>http https区别</li><li>设计模式的了解，<ul><li>单例模式, 懒汉模式, 饿汉模式</li></ul></li><li>数据库。。不太会，谢谢  介绍了b树，b 树，和一些数据库设计优化方法， 具体怎么做。。不<ul><li>B树: <ul><li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>每个节点都存有索引和数据，也就是对应的key和value</li><li>(m阶)根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1</li></ul></li><li>B+树: <a href="https://blog.csdn.net/qq_26222859/article/details/80631121">b+树图文详解</a><ul><li>有k个子树的中间节点包含有k个元素(B树中是k-1个元素)，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大(或最小)元素。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li></ul></li><li>平衡二叉树:<ul><li>查询二叉树</li><li>平衡(每个节点的子树高度差不超过1)</li><li>插入删除都是log(N),但是旋转会牺牲掉log(N)的性能,但是相对于搜索二叉树而言已经好很多了</li></ul></li><li>红黑树:<ul><li>红黑</li><li>跟为黑, 叶子为黑</li><li>红有黑子</li><li>每个节点到子节点的路径拥有相同搞得黑色节点</li><li>插入删除都是log(N), 而且每次旋转都是1-3次, 不会很多, 是非常稳定个快速的</li></ul></li></ul></li><li>死锁，死锁预防，死锁避免，死锁检测<ul><li>死锁检查: <ul><li>方法一: 维护进程等待表和资源分配表</li><li>方法二: 进程回退法, 为每个进程记录一下中间节点, 当进程发生死锁让这些死锁的进程都回退一下重新执行, 原理为, 死锁是偶发的, 重新跑一下可能不会死锁了</li></ul></li></ul></li><li>进程同步<ul><li>信号量</li><li>信号</li><li>管程</li></ul></li></ul></li><li><p>三面</p><ul><li>算法 最小生成树</li><li>cpu调度<ul><li>非抢占式的先来先服务算法（FCFS）</li><li>非抢占式的最短作业优先（SJF）</li><li>最短剩余时间优先（SRTN）</li><li>最高相应比优先算法（HRRN）</li></ul></li><li>成员函数的前后const</li><li>算法 最短路径</li><li>会多线程吗？  不会谢谢，介绍了多线程的同步方式，和多进程的区别，进程，线程区别</li><li>算法 快排topk<ul><li>分治思想, 按照值分为两半, 然后把两半再来划分</li></ul></li><li>虚拟内存和物理内存的区别</li></ul></li></ul></li><li><p>百度C++面试 一/二面 面经：<a href="https://www.nowcoder.com/discuss/113601">https://www.nowcoder.com/discuss/113601</a></p><ul><li><p>一面：</p><ul><li><p>2、进程线程区别？</p></li><li><p>谈谈项目中的多线程和线程池？</p></li><li><p>3、linux下如何快速将文件每行倒序输出？shell或者编程都行，说了下python和c++实现方法，结果人考的是tac命令</p><ul><li>cat 顺序输出, tac逆序输出, cat -n 显示行号</li><li>head 从头开始, tail</li><li>最狠的是! 用awk逆序输出<pre class=" language-cpp"><code class="language-cpp"><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  line<span class="token punctuation">[</span>NR<span class="token punctuation">]</span> <span class="token operator">=</span> $<span class="token number">0</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  END <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      i <span class="token operator">=</span> NR      <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          print line<span class="token punctuation">[</span>i<span class="token punctuation">]</span>          i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><a href="https://blog.csdn.net/bytxl/article/details/48135311">tac命令以及各种linux文件查看命令</a></li></ul></li><li><p>4、手撕代码-输出字符串中最长的回文子串长度？写完了不会优化</p><ul><li>用状态法, 先找到可能会有回文的地方, 然后进行扩张</li></ul></li><li><p>5、TCP-UDP区别？</p><pre><code>  - 面向连接, 一对一, 一对多  - 可靠性(无差错, 无重复, 按序到达), 流量控制, 拥塞控制, 序号, 确和重传  - 动态报文长度, 合并和拆分报文, | 保留边界  - T头20, U头8</code></pre></li><li><p>描述四次挥手过程，以及timewait、closewait？</p><ul><li>closing</li><li>客户端发送 SYN | SYN_send</li><li>服务器收到 syn, 回复ack+syn | syn_recv</li><li>客户端收到ack+syn, 回复 ack | establish</li><li>服务器收到 ack | establish</li><li>客户端发送 fin | fin_wait_1</li><li>服务器收到 fin, 回复ack | close_wait</li><li>客户端收到 ack | fin_wait_2</li><li>服务器发送 fin | last_ack</li><li>客户端收到 fin, 回复 ack | time_wait</li><li>服务器收到 ack | close</li><li>还有一个客户端可服务器同时发送fin, 则进入closing</li></ul></li><li><p>timewait过程如果出现过多, 拥塞或者网络不稳定导致很多非正常数据该如何解决？</p><ul><li>设置内核配置文件完成: <code>/etc/sysctl.conf</code><ul><li><code>net.ipv4.tcp_tw_reuse=1</code></li><li><code>net.ipv4.tcp_tw_recycle=1</code></li><li><code>net.ipv4.tcp_fin_timeout</code></li><li>参考: <a href="https://www.cnblogs.com/dadonggg/p/8778318.html">解决TIME_WAIT过多造成的问题</a></li></ul></li></ul></li><li><p>linux下如何查看特定端口有多少tcp连接？</p><ul><li>netstate -ant | grep ‘80’| wc -l</li><li><a href="https://www.cnblogs.com/EasonJim/p/8098532.html">Linux查看某个端口的连接数</a></li></ul></li><li><p>6、手撕sql查询排序？</p></li><li><p>如何通过索引优化该sql？</p></li><li><p>谈谈Innodb中b+树？myisam和Innodb中b树有什么区别？</p></li><li><p>7、了解数据结构？图如何表示？图广度遍历用什么结构？</p><ul><li>邻接矩阵(nxn), 关联矩阵(可能大于nxn)</li><li>广度遍历一般用队列queue</li></ul></li><li><p>8、是否熟悉docker镜像制作？了解docker-compose？</p><ul><li>部署, 建立依赖, 尤其是数据库和应用</li><li>docker-compose up -d</li></ul></li></ul></li><li><p>二面：</p><ul><li><p>2、谈谈你熟悉的项目，项目遇到了哪些难点？</p></li><li><p>3、char (*p) [] 、char *p[]、char (*p)()的区别？</p><ul><li>[]的优先级高于*</li><li>第一个数指针指向一个char数组</li><li>第二个是素组, 存放的是char*</li><li>第三个是函数指针, 返回值为char, 空参数列表</li></ul></li><li><p>4、熟悉设计模式？手写下单例模式？</p></li><li><p>5、手撕代码int atoi(char *str)？</p><ul><li>注意开头的负号和空格</li></ul></li><li><p>6、谈谈web上访问网址的过程？</p><ul><li>说说DNS如何找到ip和port的？若本地和局域网查找不到，如何向上层查找(DNS服务迭代查询和递归查询的流程)？</li><li>谈到socket通信，说说握手过程，为何三次握手？</li><li>谈到get、post了，get和post的原理和区别？</li><li>直到http和http2区别？<ul><li>1.HTTP2使用的是二进制传送，HTTP1.X是文本(字符串)传送。</li><li>2.HTTP2支持多路复用</li><li>3.HTTP2头部压缩</li><li>4.HTTP2支持服务器推送</li><li>参考: <a href="https://blog.csdn.net/zq_king/article/details/80319847">HTTP2与HTTP1.1的区别</a></li></ul></li><li>熟悉https，https中加密实在哪一过程进行了？<ul><li>首先三次握手之后有一个ssl握手,协商密钥, 以后非明文传输</li><li>说说ssl加密原理？<ul><li>客户端发送 hello</li><li>服务器恢复 hello,自己的证书</li><li>客户端验证证书, 并生成客户端会话密钥</li><li>客户端发送 自己的公钥,客户端会话密钥公钥; 使用服务器公钥加密</li><li>服务器使用自己的私钥解密, 然后生成服务器回话密钥</li><li>服务器发送 服务器回话密钥, 使用客户端公钥加密</li><li>参考: <a href="https://blog.csdn.net/qq_32998153/article/details/80022489">HTTPS的加密过程</a></li></ul></li></ul></li></ul></li><li><p>7、说说select、poll、epoll区别？</p></li><li><p>8、熟悉句柄么？程序执行后句柄如何处理，如何修改可打开句柄数量？</p><ul><li>句柄始于系统资源, 用完之后一定要关闭, 不然也算是资源泄露</li><li>临时修改: ulimit -n xxx</li><li>永久修改: /etc/sercurity/limits.conf<pre><code>soft　　nofile　　65536hard　　nofile　　65536// 将最大句柄数改为 65536</code></pre></li></ul></li><li><p>9、数组存中在一个大于n/2次的数，如何以最优方法查找它？</p><ul><li>用消除法, 用map保存点, 当map中的关键字大于两个时删除,最终剩下的即是</li></ul></li><li><p>10、用栈实现队列，用队列实现栈？</p><ul><li>栈变队: 双栈法(负负得正)</li><li>队变栈: 双队法</li></ul></li><li><p>11、如何设计一个高并发的分布式服务器？</p><ul><li>reactor模型</li></ul></li><li><p>12、64匹马、8赛道，知识多少轮比赛找出速度最快的4匹马？（在提示下优化到12次，最优解为10或者11次）</p></li></ul></li></ul></li></ul><ul><li><p>百度一面二面经历（体验极差）：<a href="https://www.nowcoder.com/discuss/112003">https://www.nowcoder.com/discuss/112003</a></p><ul><li><ol><li>首先是3次握手（已经被问过n多次）。</li></ol></li><li><ol start="2"><li>然后是select，epoll，但是问的很隐晦，大致是在问我TCP接收到报文后内核和上层报文之间怎么交换，但是刚开始没太听懂他在说什么，所以我重复问了一下，但是他自己却把过程说了出来，可能是因为本人是本科生，他觉得我不知道相关知识的缘故吧。</li></ol></li><li><ol start="3"><li>问了一下流量控制，还是很隐晦，当时大概问的是“一个服务器有很多TCP连接，然后某一时刻他可能来不及处理接受到的数据，这时候该怎么办？”。坦白说刚开始听到我是比较懵B的，但是仔细想过之后发现这好像就是流量控制，所以很流利的回答了流量控制，顺道说了一下原理。</li></ol></li><li><ol start="4"><li>然后问了一点有关操作系统方面的知识，shell命令。</li></ol></li><li><ol start="5"><li>开始数据结构，首先是哈希解决冲突的办法。</li></ol></li><li><ol start="6"><li>用拉链法设计一个哈希类，要求把链换成STL中的map。（手写代码），写完之后他说不是线程安全的，让改一下。</li></ol></li><li><ol start="7"><li>开始问map那点破事。</li></ol></li><li><p>二面（体验极差，估计是挂了）：其实也够倒霉的，本来我投的是C++/Php，但是二面来面我那哥们是个搞云端产品的。</p></li><li><ol><li>向一个文科生解释一下指针和引用的差别。。。。。。（我表示很无语，但是一时紧张有却时想不到什么好的解释）。</li></ol></li><li><ol start="2"><li>再解释一下对象和类。。。。。。（和上面一样，不知道从何入手）。</li></ol></li><li><ol start="3"><li>开始了算法，先问我二叉树学过吗，然后让我设计一个节点，再然后让我比较两棵树是否相同（手写代码）。现在我才明白，大概是在考我用递归怎么遍历树，我当时写的居然是以按层遍历的方式去遍历树，然后两棵树逐个节点作对比。</li></ol></li><li><ol start="4"><li>让我反转一个字符串。。。。。。（手写代码）。</li></ol></li></ul></li></ul><ul><li><p>百度一面凉面面经：<a href="https://www.nowcoder.com/discuss/111058">https://www.nowcoder.com/discuss/111058</a></p><ul><li><p>D：拿出一张白纸，多路归并排序知道吧，怎么做</p></li><li><p>先内部排序,然后还用堆排序</p></li><li><p>D：top K知道吧，大根堆还是小根堆，是不是都可以</p></li><li><p>默认是大根堆, 结果为顺序(虽然出堆是逆序的,但是出堆结果存在最后)</p></li><li><p>D：C、c++什么区别</p></li><li><p>…</p></li><li><p>D：内核是吧，讲下文件系统实现吧</p></li><li><p>inode区和数据区</p></li><li><p>D：那你讲下进程、内存管理你比较熟悉的</p></li><li><p>其实应该是进程中的内存管理,也就是c/c++体系的内存管理</p></li><li><p>D：讲下进程间通信</p></li><li><p>…</p></li><li><p>D：读写锁知道吧，写个多个读者读，阻塞写者的实现。</p></li><li><p>D: SQL了解吧，能写语句吗</p><pre class=" language-sql"><code class="language-sql">CREATE_TABLE demo<span class="token punctuation">(</span>  id <span class="token keyword">INT</span> <span class="token keyword">NO</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>   name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span></code></pre></li><li><p>D：讲下关系型数据库和K-V数据库的特点</p><ul><li><p>就是关系数据库和键值对数据库的特点</p></li><li><p>关系数据库</p><ul><li>有点:<ul><li>关系数据库历史悠久, 技术成熟</li><li>关系数据库是基于表的, 重复储存少, 数据更新方便</li><li>强一致性</li></ul></li><li>缺点:<ul><li>处理大量数据的读写有一定障碍(解决方案为: 主从模式, 主数据库负责写, 从数据库负责度)</li><li>表结构更改较难, 扩展性较差</li><li>查询较慢(很难针对简单查询快速返回)</li></ul></li></ul></li><li><p>键值对数据库</p><ul><li>优点<ul><li>成本低, 开源的多</li><li>查询速度</li><li>数据库储存形式</li><li>扩展性</li></ul></li><li>缺点<ul><li>不支持sql生态</li><li>不提供强一致性, 只能保证最终一致性</li></ul></li></ul></li><li><p>区别</p><ul><li>关系型数据库局域ACID(原子性, 一致性, 独立性, 持久性)模型, 非关系型数据库支持CAP(一致性, 可用性, 分区容忍性)模型</li><li>储存形式: 关系型数据库基于表, 修改不方便, 不便于扩展; 非关系数据库支持多种形式的储存, 例如键值对, 图 等,扩展性较强</li><li>数据一致性: 非关系型数据库强调最终一致性, 关系型数据库强调强一致性</li></ul></li><li><p><img src="../img/%E7%89%9B%E5%AE%A2%E5%AE%9E%E6%88%98/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="关系型数据库和非关系型数据库的特性以及各自的优缺点"></p></li></ul></li><li><p>D：行吧，说下TCP三次握手</p></li><li><p>D：为什么三次不是两次</p></li><li><p>D：行吧，做几个算法,树的深度怎么求</p></li><li><p>D：宽度呢</p></li><li><p>D：用c肯定指针熟吧，写个链表倒转</p></li></ul></li></ul><ul><li>百度一面：<a href="https://www.nowcoder.com/discuss/109958">https://www.nowcoder.com/discuss/109958</a><ul><li>一面<ul><li><ol><li>1G内存，4G url，求重复的url<ul><li>布隆过滤器(可能会有漏, 看设计得好不好了, 适合超大规模), 或则hash+字典树</li></ul></li></ol></li><li><ol start="2"><li>手写二分</li></ol></li><li><ol start="3"><li>Linux命令，find，grep，ps，netstat…<ul><li>find: 支持模糊操作</li><li>grep: 文件内查找, 支持正则表达式</li><li>awk: </li><li>sed: </li><li>cat</li><li>tac:</li><li>head:</li><li>tail:</li><li>ps: 进程状态</li></ul></li></ol></li><li><ol start="4"><li>Python的tuple<ul><li>元组, C++11中也有了</li></ul></li></ol></li><li><ol start="5"><li>C 与Cpp的区别<ul><li>…</li></ul></li></ol></li><li><ol start="6"><li>const/define<ul><li>首先是预编译阶段实现, 编译阶段生效</li><li>define可以实现更为丰富的逻辑</li><li>const定义的是变量, define只是宏替换, 会储存在代码区</li><li>作用域不同, const全域, const 变量自身与</li></ul></li></ol></li><li><ol start="7"><li>C语言内存布局</li></ol></li></ul></li><li>1.1 面：<ul><li><ol><li>Linux kvm，GPU 直通，SRIOV</li></ol></li><li><ol start="2"><li>CPU架构，NUAM，SMP</li></ol></li><li><ol start="3"><li>Guest OS发个网络请求，到Host OS，再到硬件的过程</li></ol></li><li><ol start="4"><li>CPU ***结构，是否共享</li></ol></li><li><ol start="5"><li>TCP握手过程，为啥三次</li></ol></li><li><ol start="6"><li>DDOS，怎么解决，如何让Server端收到ACK后在分配资源，不改变Client，不封装IP数据包<ul><li>小规模DDOS, 可以设置/etc/sysctl.conf中net.ipv4.tcp_syncookies</li></ul></li></ol></li><li><ol start="7"><li>如果把访问次数过多的IP拉入黑名单，怎么实现，用什么数据结构，写个伪码</li></ol></li><li><ol start="8"><li>hash冲突怎么解决<ul><li>开链发</li><li>开放寻址法</li></ul></li></ol></li><li><ol start="9"><li>多线程操作一个hash表呢？用什么锁？<ul><li>互斥锁</li></ul></li></ol></li><li><ol start="10"><li>读写锁说一下，怎么使用</li></ol></li><li><ol start="11"><li>C语言const，static</li></ol></li><li><ol start="12"><li>C语言volatile，说个应用场景</li></ol></li><li><ol start="13"><li>手写判断大小端的代码</li></ol></li><li><ol start="14"><li>C语言内存布局</li></ol></li><li><ol start="15"><li>分段分页机制</li></ol></li><li><ol start="16"><li>逻辑地址到物理地址过程</li></ol></li></ul></li></ul></li></ul><ul><li>来自小白的百度一面面经：<a href="https://www.nowcoder.com/discuss/109318">https://www.nowcoder.com/discuss/109318</a><ul><li>开始考察数据结构和算法，先让我说了一些排序算法，问我能不能手写快排</li><li>1.死锁是怎么产生的</li><li>2.有没有写过多线程？</li><li>3.调度算法有哪些？<ul><li>先进先出(FIFO), 队列</li><li>最近最不经常访问(LFU), 引用排序</li><li>最近最少访问(LRU), 队列(每次访问新激或则把旧的移动到队尾)</li></ul></li><li>4.三次握手四次挥手画图解释一下</li><li>5.UDP和TCP区别<ul><li>…</li></ul></li><li>6.HTTP和HTTPS介绍一下，区别是什么？<ul><li>http<ul><li>超文本传输协议,用于服务器往浏览器传送传输超文本的传输协议</li><li>基于tcp/ip</li><li>简单快速, 灵活, 无连接, 无状态</li></ul></li></ul></li><li>7.HTTPS的安全性是怎么实现的？<ul><li>加密!</li><li>客户端发送hello给服务器</li><li>服务器发送hell+证书</li><li>客户端验证证书, 并生成客户端通信回话密钥</li><li>客户端发送 自己的公钥+客户端回话密钥公钥,使用服务器公钥加密</li><li>服务器用自己的私钥解密, 然后生成自己的服务器回话密钥</li><li>服务器发送 服务器回话密钥公钥, 使用客户端私钥加密</li><li>然后加密通信!</li></ul></li><li>8.HTTP有哪几种操作？<ul><li>post, get, head</li><li>options, delete, put, connect, trace</li></ul></li></ul></li></ul><ul><li><p>秋招第一次面试-&gt;百度（c++后台岗位）<a href="https://www.nowcoder.com/discuss/90069">https://www.nowcoder.com/discuss/90069</a></p><ul><li>一面<ul><li>Q：TCP三次握手和断开的完整过程</li><li>Q：为什么要等2个MSL</li><li>Q：输入 <a href="http://www.baidu.com/">www.baidu.com</a> 在浏览器的完整过程，越详细越好</li><li>A：LRU那种？</li><li>Q：这个怎么实现同步和互斥，怎么样去加锁</li><li>Q：c++里面的同步和互斥怎么实现的</li><li>A：mutex，条件变量之类的说了一下，消费者生产者之类的举了个例子</li><li>Q：c++里面的常量怎么定义<ul><li>宏定义</li><li>const常量</li><li>enum 定义常量(注意对这玩意儿不能取地址)</li><li>constexpr 常量表达式, 也可以表达类似的效果, 表示在编译期间可以进行求值的表达式</li></ul></li><li>A：const和constexpr（这个面试官可能没见过，然后解释了一下）</li><li>Q：我主要想说宏</li><li>Q：c++的智能指针说一下，区别</li><li>Q：c++怎么实现一个函数先于main函数运行<ul><li>A：用static</li><li>如果gcc编译器,还可以用__attribute((constructor)) void befor(){}</li></ul></li><li>Q：c++的static的变量的初始化顺序怎么样的</li><li>不不不, C++中引入了对象的概念,它的初始化时放在了第一次被调用时,所以是可以使用变量来初始化c++中的static的</li><li>Q：如果一个类里面呢？</li><li>Q：两个文件，两个static变量a和b，怎么让某个变量先于另外一个初始化呢？</li><li>两种方式, <ul><li>一个是分别定义在两个头文件里面,并且是用定义赋值的方式,通过头文件引用顺序进行调整</li><li>另一个是定义在头文件里面,通过控制两个变量的调用顺序来控制初始化顺序</li></ul></li><li>A：使用定义的时候就赋予初始化,强行初始化.</li><li>Q：来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜</li><li>感觉应该是哈希+字典树</li><li>A：字典树+堆吧，然后balabala（第三次。。。感觉面试官不是很满意我的答案)</li></ul></li></ul></li><li><p>提前批面经C/C++后台开发岗位(持续更新) <a href="https://www.nowcoder.com/discuss/94734">https://www.nowcoder.com/discuss/94734</a></p><ul><li><p>百度一面</p><ul><li><p>C++拷贝构造函数为什么传引用</p><ul><li>值传递会调用拷贝构造函数创建副本, 而这里本来就是实现拷贝构造, 所以如果是值传递就会导致死循环.</li><li>实际上编译器也不允许循序拷贝构造函数为值传递.</li></ul></li><li><p>如何返回值一个类的构造和拷贝构造</p><ul><li>应该是返回值优化吧</li><li>如果没有开启返回值优化, 只需要返回对象, 就会自动调用拷贝构造函数</li><li>如果返回值为内部构造并通过值传递的方式返回主调函数, 则编译器使用返回值优化, 避免拷贝构造函数和析构函数的调用, 具体实现方式为:</li><li>函数返回值改为void, 形参列表为返回值类型的引用, 主调函数把即将赋值的参数的引用传入背调函数, 这样就可以只调用一次构造函数.</li><li>参考: <ul><li><a href="https://www.cnblogs.com/xkfz007/articles/2506022.html">转：C++中临时对象及返回值优化</a></li><li><a href="https://zhaostu4.github.io/2019/11/28/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/#23-%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96">2.3 命名返回值优化</a></li></ul></li></ul></li><li><p>如果声明为私有的，那么是编译时错误还是运行时错误</p><ul><li>编译错误</li></ul></li><li><p>vector越界访问下标</p><ul><li>vector通过下标运算符进行访问, 不会进行越界检查, 如果越界会得到脏数据, 或则段错误</li><li>通过at进行访问, 会进行越界检查, 如果越界会报<code>out_of_range</code> 异常</li></ul></li><li><p>map越界访问下标</p><ul><li>创建这个下标对应的键值对, 值调用默认构造函数进行构造</li></ul></li><li><p>如何删除map中的奇数节点</p><ul><li>直接迭代删除即可, map的迭代器不会失效</li></ul></li><li><p>指针和引用的区别</p><ul><li>…</li></ul></li><li><p>C++中内存泄漏问题</p><ul><li>概念: 在程序中申请了资源,但是在不使用时并没有释放, 导致这种资源不能再被利用,从而引起浪费, 甚至系统崩溃</li><li>分类:<ul><li>堆内存泄漏: 申请了对了堆内存未释放, 或则通过基类指针析构子类对象, 但是基类析构函数没有设置为虚函数</li><li>内核资源泄漏: 例如打开了文件描述符未管理, 甚至僵尸进程也算是一种内存泄漏</li></ul></li><li>解决方案:<ul><li>静态代码分析: beam(这个就像编译器一样, 他会对代码进行静态分析, 给出一个报告)</li><li>动态分析: valgrind</li></ul></li></ul></li><li><p>new和malloc的区别</p></li><li><p>TCP断开连接过程，timewait解释</p></li><li><p>HTTP中状态码 302(详细问) 403 400</p><ul><li>200 正常</li><li>300 可选重定向: 服务器根据请求可执行多种操作。服务器可根据请求者来选择一项操作，或提供操作列表供其选择。</li><li>301 永久重定向: 请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。<ul><li>这是对搜索引擎最友好的一种方式, 搜索引擎会拉取新的地址</li></ul></li><li>302 临时从定向: 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。<ul><li>这里就有一个网址劫持相关的概念了, </li><li>网址<code>A</code>做一个<code>302</code>重定向到网址<code>B</code>时，主机服务器的隐含意思是网址<code>A</code>随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到<code>302</code>重定向时，一般只要去抓取目标网址就可以了，也就是说网址<code>B</code>。</li><li>搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。</li><li>问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。</li><li>为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。</li><li>很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。</li><li>这就造成了网址URL劫持的可能性</li><li>一个家伙网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。当用户点进去的时候, 调转的确实网址A !!!!!.</li></ul></li></ul></li><li><p>参考: <a href="https://blog.csdn.net/qmhball/article/details/7838989">HTTP返回码中301与302的区别</a></p><ul><li>304 内容未修改, 使用缓存即可</li><li>400 客户端错误</li><li>403 客户端收到请求,但是拒绝提供服务</li></ul><hr><ul><li>1xx 继续 – 例如, post的时候先发头, 就会回复这个</li><li>2xx 正常 – 正常, 206是分片</li><li>3xx 重定向  – 更换了地址</li><li>4xx 客户端错误 – 语法错误或则无效请求</li><li>5xx 服务器错误 – 服务器未能完成合法请求</li></ul></li><li><p>连续子数组最大和问题</p><ul><li>动态规划问题</li></ul></li></ul></li><li><p>百度二面</p><ul><li><p>C++多态，虚表指针在什么时候初始化</p><ul><li>无继承时：<ul><li>1、分配内存</li><li>2、初始化列表之前赋值虚表指针</li><li>3、列表初始化</li><li>4、执行构造函数体</li></ul></li><li>有继承时：<ul><li>1、分配内存</li><li>2、基类构造过程(按照无继承来)</li><li>3、初始化子类虚表指针</li><li>4、子类列表初始化</li><li>5、执行子类构造函数体</li></ul></li></ul></li><li><p>参考: <a href="https://blog.csdn.net/jasonLee_lijiaqi/article/details/89073020">虚表指针初始化顺序</a></p></li><li><p>STL库的容器底层实现</p><ul><li>哪个容器撒</li></ul></li><li><p>红黑树的插入效率，为什么相对平衡的红黑树比绝对平衡的AVL适用广<br>查找、插入、删除操作的最坏时间复杂度</p><table><thead><tr><th>方法</th><th>二叉查找树</th><th>平衡二叉树</th><th>红黑树</th></tr></thead><tbody><tr><td>查找</td><td>O(n)</td><td>O(logn)</td><td>Olog(n)</td></tr><tr><td>插入</td><td>O(n)</td><td>O(logn)</td><td>Olog(n)</td></tr><tr><td>删除</td><td>O(n)</td><td>O(logn)</td><td>Olog(n)</td></tr></tbody></table><ul><li>二叉查找树因可能退化成链表，故其性能最差。</li><li>平衡二叉树和红黑树是带有平衡条件的二叉查找树，故它们的效率也较高。</li><li>平衡二叉树的<code>插入/删除</code>操作带来的旋转操作可能会达到<code>logn</code>次，而红黑树的<code>插入/删除</code>操作带来的旋转操作最多为<code>2到3</code>次。</li><li>所以说，当红黑树出现的时候，平衡二叉树就只能出现在博物馆里了。</li></ul></li><li><p>即红黑树是最优选择。</p></li><li><p>B树和B+树的区别，B+树应用在哪?</p><ul><li>B树<ul><li>特性<ul><li>每个节点保存数据和索引</li><li>所有的叶子节点处于同一层</li><li>拥有m个子树的根节点拥有[1,m-1]个内部节点, 中间节点拥有[m/2,m-1]个内部节点</li><li>内部顺序, 左小,右大</li></ul></li><li>缺点:<ul><li>索引和数据一起,查找的时候一次读到的索引较少</li><li>遍历较为麻烦</li></ul></li></ul></li><li>B+数<ul><li>特性<ul><li>内部排序, 左小等, 右大等</li><li>k个子树的中间节点拥有k个内部节点, 左侧的子树是最大的, 右侧的是最小的</li><li>叶子节点同一层, 且按序链起来</li><li>数据只储存在叶子节点, 中间节点子储存索引</li></ul></li><li>正好解决了B数的两个问题</li></ul></li></ul></li><li><p>哈希表的哈希冲突，解决哈希冲突的几种方法</p><ul><li>开链法</li><li>开放寻址方式</li></ul></li><li><p>进程间通信方式，每个都讲一下</p><ul><li>管道</li><li>socket</li><li>系统IPC(信号量, 信号, 共享内存, 消息队列)</li></ul></li><li><p>网编程讲一下。</p><ul><li>TCP <ul><li>服务器: bind, listen, accept, read(recv), write(send)</li><li>客户端: connect, write(send), read(recv)</li></ul></li><li>UDP recvfrom, sendto</li></ul></li><li><p>select和epoll，epoll底层实现，数据的拷贝方式。</p><ul><li>select 数组, 每次复制, 限制</li><li>epoll 红黑树, 不用每次复制, 中断,无限制<ul><li>水平模式</li><li>边缘模式</li></ul></li></ul></li><li><p>求一个数开根号（二分）</p><ul><li>二分法和牛顿法</li></ul></li><li><p>讲一下timewait状态，没有timewait有什么问题</p></li><li><p>滑动窗口和拥塞窗口</p></li><li><p>慢启动和快重传</p></li><li><p>实现一个功能，能检测内存泄漏问题，通过一个指令输出整个进程中哪一行哪个函数申请了多少内存，按照顺序排列出来，还有总的内存数</p><ul><li>(!!!!!!)</li></ul></li></ul></li><li><p>百度三面(经理面)</p><ul><li>谈实习工作</li><li>Linux下的内存机制</li><li>模板的分离编译</li><li>空类的大小，含有成员函数类的大小</li><li>链接过程(详细)<ul><li>(!!!!) 链接过程详解 - 简书: <a href="https://www.jianshu.com/p/53ccc77abc6a">https://www.jianshu.com/p/53ccc77abc6a</a></li></ul></li><li>写个string类</li></ul></li><li><p>阿里一面</p><ul><li>进程、线程、协程的区别</li><li>进程创建子进程，fork详解</li><li>I/O模型介绍，细说slect和epoll。I/O多路转接阻塞?非阻塞？有什么问题?</li><li>数据库底层数据结构？说下为什么采用B+树？<ul><li>遍历快, 查询索引和数据分离, 查询少IO操作</li></ul></li><li>数据库的ACID特性</li><li>数据库索引相关</li><li>知道那些非关系型数据库？<ul><li>Nosql</li><li>redis</li><li>mon</li></ul></li><li>C++中struct和class区别</li><li>C语言struct和C++struct区别</li><li>如何用C语言实现C++的继承<ul><li>利用函数指针访函数</li><li>在子类中,把基类放在最前面</li></ul></li><li>inline相关，虚函数可以声明为inline吗？</li><li>说下虚表的原理</li><li>多重继承的问题，详解，对比一些开源框架中使用的多重继承来说？<ul><li>问题<ul><li>菱形问题</li><li>不同基类的同名函数,导致二义性</li></ul></li></ul></li><li>了解RAII？说一下什么是RAII?应用？<ul><li>资源获取即初始化</li><li>RTTI是运行时类型检查</li></ul></li><li>智能指针，share_ptr和weak_ptr,细说weak_ptr?可以用原生指针吗？<ul><li>内存泄漏</li></ul></li><li>了解那些分布式组件？说下Zookeeper和HDFS，说下CAP理论<ul><li>不了解, 但是知道CAP理论: 一致性, 可用性, 分区容错性</li><li>(!!!!) zookeeper, hdfs</li><li><a href="https://www.jianshu.com/p/f1e785fffd4d">HDFS</a><ul><li>HDFS特点：<ul><li>高容错性、可构建在廉价机器上</li><li>适合批处理</li><li>适合大数据处理</li><li>流式文件访问</li></ul></li><li>HDFS局限：<ul><li>不支持低延迟访问</li><li>不适合小文件存储</li><li>不支持并发写入</li><li>不支持修改</li></ul></li></ul></li></ul></li><li>了解哪些一致性算法<ul><li>(!!!!)Raft</li><li>Paxos</li></ul></li><li>深度优先遍历和广度优先遍历的应用场景<ul><li>深度优先找深度</li><li>广度优先找宽度</li></ul></li><li>项目中使用网络编程？简单说下？说下cgi？服务器采用什么结构？使用的epoll模型？<ul><li>cgi</li></ul></li><li>有序的数组，其他数都出现两次，一个数只出现一次？思路(数组无序异或，数组有序采用二分)<ul><li>有序? 那之间检查前后就可以了啊</li><li>无序: 异或</li></ul></li></ul></li></ul></li></ul><h2 id="未看"><a href="#未看" class="headerlink" title="未看"></a>未看</h2><ul><li><p>百度 提前批C++一面 二面 三面（GG）<a href="https://www.nowcoder.com/discuss/96139">https://www.nowcoder.com/discuss/96139</a></p><ul><li>百度一面 电话面 (87分钟)<ul><li>自我介绍<ul><li>按照以往的套路，我都是自我介绍完直接说自己的项目，因为自己的项目已经很熟悉了。</li><li>就算问到一些不会的也能答出一二三。</li><li>可一面面试官完全不按照套路。</li><li>我准备说项目的时候直接打断了。说我们先问几个问题，等会再说项目。</li></ul></li><li>虚基类</li><li>纯虚函数</li><li>虚函数</li><li>虚函数表内存分布</li><li>虚函数中虚基类和派生类的关系</li><li>显示转换(隐式转换)</li><li>问了三个算法题 讲讲思路</li><li>学过网络和操作系统吗</li><li>三次握手，四次挥手 握手为什么是两次</li><li>讲一讲拥塞机制 和流量机制</li><li>http https 抓包工具原理</li><li>IP地址分为几类？简单说一下分类<ul><li><a href="https://zhidao.baidu.com/question/560135986.html">IP地址总共分为几类？怎样区分IP地址</a></li></ul></li><li>进程通信有哪些方式</li><li>进程同步的方法</li><li>知道互斥锁吗？</li><li>他用什么来保证共享数据的安全性？</li><li>这个我说信号量，他说如果用信号量来解决，现在出现一个状况，两段进程都被标记为可以访问该共享数据，但我们的共享单元只能支撑一个进程访问。这时候怎么办？</li><li>我说用唯一标识符去处理。生成唯一标识符，这样就不会出现这种情况。</li><li>他说不对。让我回去好好看看。</li><li>回去查了一下，是原子操作。。</li><li>(这个问题问了好久)</li><li>数据库索引 索引原理 以及如何优化数据库</li><li>开始讲项目 三个项目，本科的，硕士的，以及在鹅厂的。问鹅厂的问的最细（40 min）</li><li>一面总结: 还有很多问题都忘记，面完的感觉就是，百度问的真的很全，第一次电话面超过一个小时的。不够面试官也没有在不会的问题继续难为我，我就说不会。他说没事就下一个问题了。</li></ul></li><li>百度二面 电话面 25分钟<ul><li>为什么继承时基类的析构一般声明为虚函数？</li><li>虚函数与纯虚函数的区别在于</li><li>为什么构造函数不能够使虚函数</li><li>4.TCP端口扫描方式<ul><li>一般有三种：<ul><li>1.通过connect: 客户端通过connect发起连接后，如果服务器处于监听状态就可以发起连接成功，否则说明端口是关闭的。优点是比较简单可靠，缺点是如果连接不成功会频繁的发包，扫描时间比较长</li><li>2.通过SYN扫描: 向目标端口发送SYN数据帧，如果又收到SYN+ACK说明开放，如果收到RST说明关闭，在IP层实现。</li><li>3.通过FIN扫描: 四次挥手的过程，主动结束的一方会发送FIN帧。</li></ul></li><li>参考: <ul><li><a href="https://blog.csdn.net/tuantuanlin/article/details/17422705">linux下端口扫描的实现(TCP connect、TCP SYN、TCP FIN、UDP四种方式)</a></li><li><a href="https://blog.csdn.net/f905699146/article/details/82625597?utm_source=blogxgwz2">tcp端口扫描方式</a></li></ul></li></ul></li><li>5.TIME_WAIT、CLOSE_WAIT</li><li>6.守护进程</li><li>7.迭代器的++it和it++哪个好</li><li>8.开始问项目，从百度二面开始。我的项目就一直被怼，完全吹不动。说几个核心的点。</li><li>9.因为说了tars 的源码，他就基于这个源码开始问。如何去处理高并发HTTP请求？</li><li>我: 从接入层(统一接入网关，负载均衡)…..从服务层(服务细分，过载保护)…..从存储层(***,共享内存，分布式存储组件ceph)……</li><li>在服务层回答到 过载保护的时候。被打断。 他说你说的过载保护不过是在请求很多的时候去拒绝掉一部分用户。或者延时处理。那么 现在如果出现一个热点事件，百度的搜索可能会达到数十亿次，你去拒绝掉这一部分用户。那这一部分用户的用户体验怎么保证？</li><li>在存储层回答ceph 分布式存储组件的时候 被问到了映射 为什么ceph要去做三层映射？</li><li>面试官: 你有没有考虑过流量不干净的情况怎么办？ 用很简单的ddos攻击，你这个服务 我1分钟之内就能让他趴下。这个你考虑过吗？</li><li>面试官: 你这个底层本质上还是用队列做的。你有没有考虑过队列全满的情况？就是现在你的所有队列全部爆满，你根本没有办法去做请求迁移。这时候怎么处理？</li><li>虽然只面了25分钟，但是大概率知道自己过了。因为最后面试官说：你有什么问题吗。我觉得你OK。 我就问了关于他们团队的一些问题。</li><li>二面之后的三天，HR打电话过来约视频面，并说明视频面面完之后可能还要加一轮现场面。我说没问题。 后来又打电话过来，说面试官不同意视频和电话面。必须现场面。而且不报销任何路费。从深圳到北京 来回花了3000多。最后拒了。很伤很伤。</li></ul></li><li>百度三面 现场面 70分钟。<ul><li>从面试开始，我就没有想过会出现这种情况。</li><li>就是自己讲完腾讯的实习项目之后。面试官直接说。你这个项目是谁让你做的。你有没有质疑过，你这个项目从方案和逻辑上就是错的？</li><li>我 : ………………………….. (从这开始心里就有一些慌了。)</li><li>面试官：我们现在假设一种情况，就是我们的服务端是很安全的，你现在多一个第三方<code>**</code>，我怎么信任你这个第三方<code>**</code>？</li><li>我：我们这个服务是对内的。即使对外，我们也可以从请求上来判定。比如相同的IP的地址我们可以从频率上去限制他的请求。不同的IP地址 我们可以去从key(这个key 是有一个失效期，只能用一次，我们将这些不干净的流量尽量拦截在接入层，不让他进入我们的网关。)</li><li>面试官： 你可能理解错了我的意思，我的意思是，限制服务端去信任客户端。你凭空多出了一个第三方***，虽然原则上确实方便了客户端的使用，但安全性怎么去保证？</li><li>我： 我们可以去做加密。Balabalabalalalalal……………</li><li>面试官： 你的意思我懂，但高并发请求如何去处理呢？</li><li>我： 从接入层(统一接入网关，负载均衡)…..从服务层(服务细分，过载保护)…..从存储层(***,共享内存，分布式存储组件ceph)……没讲完就被打断了。</li><li>面试官: 你知不知道，你现在所做的可能都是没有意义的？</li><li>我: ………………………….</li><li>面试官：因为你们的服务端，绝对已经做过了这些处理。而且比你的第三方<code>***</code>做的好。你现在的这个<code>***</code>服务极其脆弱。你为什么不把他封装成一个接口呢？而不是一个服务。</li><li>我: …………………………………………</li><li>面试官： 你这个项目其实还是有很多有意思的东西，比如你知道为什么用appid和appsecret 去换取微信那边的一个access_token权限吗？</li><li>我：我们可以类比，淘宝登陆 除了用户名和密码 我们还需要手机验证码这样的方式。</li><li>面试官： 你这个类比不对，因为淘宝登陆他现在不信任你这个用户名和密码。需要多加一个验证方式。而通过appid appsecret 他的本质是换取 而不是加</li><li>你知道为什么要换取 ，而不是加吗？为什么要这样做。而不是把appid appsecret 存到数据库里面？</li><li>我：因为存到数据库里面，不够安全。只要是存在数据库里面的密钥。都可能有被攻破的风险。而access_token是实时生成的。</li><li>面试官： 咱们又绕回来了，那你做这个第三方<code>***</code>的时候为什么用的是数据库？你既然知道access_token是实时生成的，那么就应该知道这个客户端令牌从原则上是不允许被其他人知道的，更不允许存到数据库里面。那咱们换一个问题。还是刚才，那咱们现在假设我们的服务端和数据库原则上是安全的，那么现在还是要用access_token去换取？我现在可以直接把appid和appsecret直接串起来串成一个字符串然后md5加密一下。可以这样做吗？如果不可以说出理由。</li><li>我：到这里我就懵逼了。。。。。</li><li>面试官：好，你现在去做***服务器。去请求另一个接口。如何去提高他的性能？</li><li>我：去做那边接口的服务细分，每个接口去细分，再在存储层去做一些优化……………….</li><li>面试官：现在假设不允许你动那个接口呢。比如你现在去请求一个其他公司的接口，他就是慢。他那边代码写的就是很不好。你只可以动你的***层。怎么处理？</li><li>我：多线程，分发，缓存，cdn.</li><li>面试官就照着我回答的继续细问下去。。又懵了。</li><li>后来就没问什么问题了。问了几个简单的就结束了。</li><li>总结： 三面面试官，绝对是我面到现在技术最强的一个。虽然挂了，但是面试官人很nice 指出了项目很多我都没有考虑到的问题。面试全程都在引导我去回答问题。就是不报销路费太伤了。。。从各大博客和在百度实习的同学了解到，百度的技术氛围真的很赞。秋招再努力了。与大家共勉。</li><li>最新更新：后来Hr打电话过来，说可以报销部分路费。还是很感谢Hr小姐姐和百度给我提供的这次面试机会！</li></ul></li></ul></li><li><p>大佬们新鲜出炉的度秘面经，了解一下~~ <a href="https://www.nowcoder.com/discuss/96056">https://www.nowcoder.com/discuss/96056</a></p><ul><li>话不多说，开始重点<del>~</del></li><li>开始面试官做了个自我介绍，以及介绍了一下度秘事业部的情况，说实话，我是不太了解这个的。。就稀里糊涂听了听。</li><li>接着让我做自我介绍，我简单介绍了一下基本信息。</li><li>开始让我讲自己的项目。</li><li>我 balabala 讲了半天。讲完第一个面试官问我你的项目里用了 epoll ，你讲讲 epoll 与 select 区别优势。</li><li>我有 balabala 讲了半天。着重讲了一下 pselect 的 timeout 时间。可能让面试官比较感兴趣。</li><li>接着面试官又开始问我了第二个项目。（我一脸懵逼，还要问？？？）</li><li>我又 balabala 讲了讲项目。从项目背景，到项目过程，再到项目中遇到的问题。</li><li>面试官貌似对我第二个项目很感兴趣，接着我的项目又往下问。 （面试了一个 小时左右，项目问了三十分钟）。</li><li>突然话题一转，面试官问我你学校专业是哪方面，学哪些计算机相关的课程。</li><li>楼主电气专业。就讲了讲硬件方面，电力呀什么的。又讲了讲学的课程。</li><li>讲讲快速排序的思想。</li><li>我 balabala</li><li>讲讲归并排序的思想。</li><li>我 balabala</li><li>如果给你 一亿个数字，找出最大的前 20 个。（TOP K 问题）</li><li>如果我只要第二十个怎么优化。</li><li>如果给你一个文件，文件里有上亿个无序字符串，设计一个算法把上亿个字符串进行排序。接着把这个有序的字符串输入到一个新的文件当中。（内存有限制）</li><li>让我讲讲我理解的线程。</li><li>多线程对公共资源同时访问。（线程安全，同步互斥）</li><li>问我了解没了解过递归锁。</li><li>C++ 11 有没有了解，讲讲。</li><li>讲讲虚函数、纯虚函数。</li><li>你懂 java 吗？ （楼主是真的不懂。面试官也就没深问。）</li><li>一个函数返回值为 bool 类型。但是返回 true 与 false 的概率不是百分之五十对百分之五十。要求利用这个函数设计一个新函数，使得新函数的返回值的概率为 50%。<ul><li><a href="https://blog.csdn.net/u011768994/article/details/79583235">随机数概率变形01概率p和1-p改变概率为二分之一</a></li></ul></li></ul></li></ul><ul><li><p><a href="https://zhuanlan.zhihu.com/p/92233568">成功斩获腾讯offer，分享我的面试经历(附书籍推荐，资料分享)</a></p></li><li><p><a href="https://www.nowcoder.com/discuss/160033?type=2">腾讯C++后台一面(40分钟)_笔经面经_牛客网</a></p><ul><li>const关键字？使用场景。<ul><li>注意const引用, 可以绑定至右值, 做形参时允许隐式变换</li></ul></li><li>引用？有没有引用的引用？</li><li>引用和常引用？（跳过）</li><li>哪些场合常引用做得到引用做不到？传参？确定吗？<ul><li>注意const引用, 可以绑定至右值, 做形参时允许隐式变换</li></ul></li><li>函数能返回引用类型吗？返回函数中的变量有问题吗？</li><li>以引用的方式安全的返回函数内的局部变量？<ul><li>两种情况, 一种是堆对象</li><li>一种是引用/指针传递进来的对象</li></ul></li><li>STL用哪些库？</li><li>vector有哪些插入的方法？<ul><li>insert, push_back</li></ul></li><li>1，2，3，4，5有个迭代器指向5，头部插一个0，之前那个迭代器指向哪？确定吗？<ul><li>首先分为两种情况: capacity是否还有剩余空间</li><li>没有, 将会导致内存重分配, 但如果元素存在析构函数将会调用析构函数析构掉原来的对象, 如果不存在析构函数的元素, 那么依旧是可以访问的, 至少在gcc下是这样的</li><li>有, 不会导致内存重分配, 但是插入点的后续将往后挪动一个元素</li><li>迭代器失效？vector哪些操作会使迭代器失效？删除会导致吗？</li></ul></li><li>模板用的多吗？</li><li>项目介绍</li><li>Reactor模式外还有什么模式？<ul><li>可以改造Reactor模式来实现Proactor模式吗？</li></ul></li><li>多线程模型</li><li>线程间通信的方式？</li><li>不加锁的方式？</li><li>ET？LT？</li><li>ET下，来了100字节，读了50字节，下次Epoll会通知你吗？</li><li>下次网卡来了50字节，还会通知吗？确定吗？</li><li>epoll加了个socket，close了epoll，会有什么问题？即没有用epoll_ctl删除，没试过。</li><li>客户端connect阻塞IO，服务端listen，sleep10000秒，客户端connect去链，客户端会不会返回成功？</li><li>此时客户端send数据，会不会成功？为什么？一直发会一直成功吗？</li><li>数据结构知道哪些？高级的数据结构</li><li>红黑树和AVL树大O一样吗？什么时候用红黑树？AVL树？既然大O一样</li><li>B树？为什么数据库相关的B树用的多，二叉树什么的用的少？</li><li>Linux操作系统怎么管理内存？<ul><li>伙伴系统和slub系统</li></ul></li><li>物理4G，malloc 8G能不能成功？<ul><li>如果虚拟地址空间是32位的, 8G不行, 如果是64位的可以</li></ul></li><li>每次malloc 1G，10次？</li><li>Linux上malloc怎么实现？</li></ul></li></ul><ul><li><p>阿里、C++三面技术面+ hr面面筋~：<a href="https://www.nowcoder.com/discuss/100946">https://www.nowcoder.com/discuss/100946</a></p></li><li><p>【C/C++】阿里-面经-研发工程师（C/C++）：<a href="https://www.nowcoder.com/discuss/101607">https://www.nowcoder.com/discuss/101607</a></p></li><li><p>【Java】阿里国际事务部挂经，Java岗<a href="https://www.c++nowcoder.com/discuss/96464">https://www.C++nowcoder.com/discuss/96464</a></p></li><li><p>【后端c++】DJI+阿里巴巴ICBU一面面经（后端C++）<a href="https://www.nowcoder.com/discuss/87621">https://www.nowcoder.com/discuss/87621</a></p></li><li><p>阿里-面经-研发工程师（C/C++）：<a href="https://www.nowcoder.com/discuss/101607">https://www.nowcoder.com/discuss/101607</a></p></li><li><p>阿里一面面经C++，攒个人品<a href="https://www.nowcoder.com/discuss/88501">https://www.nowcoder.com/discuss/88501</a></p></li><li><p>新鲜热乎的百度一面面筋(C++)，攒人品<a href="https://www.nowcoder.com/discuss/88852">https://www.nowcoder.com/discuss/88852</a></p></li><li><p>阿里飞猪一面凉经<a href="https://www.nowcoder.com/discuss/94080">https://www.nowcoder.com/discuss/94080</a></p></li><li><p>【C++后台开发】 阿里巴巴新零售 一面凉凉（C++后台开发）<a href="https://www.nowcoder.com/discuss/90335">https://www.nowcoder.com/discuss/90335</a></p></li><li><p>华为凉经：<a href="https://www.nowcoder.com/discuss/121852">https://www.nowcoder.com/discuss/121852</a></p></li><li><p>华为优招-长沙-一二面面经（感觉用处不大）<a href="https://www.nowcoder.com/discuss/96528">https://www.nowcoder.com/discuss/96528</a></p></li><li><p>华为优招面经8.20 <a href="https://www.nowcoder.com/discuss/96410">https://www.nowcoder.com/discuss/96410</a></p></li><li><p>【c++开发】蚂蚁金服中间件一面和二面面筋（C++开发）<a href="https://www.nowcoder.com/discuss/87810">https://www.nowcoder.com/discuss/87810</a></p></li><li><p>秋招提前批面试记录小结<a href="https://www.nowcoder.com/discuss/97474">https://www.nowcoder.com/discuss/97474</a></p></li><li><p>CVTE武汉面经：<a href="https://www.nowcoder.com/discuss/113462">https://www.nowcoder.com/discuss/113462</a></p></li><li><p>CVTE一面二面+HR面<a href="https://www.nowcoder.com/discuss/89764">https://www.nowcoder.com/discuss/89764</a></p></li><li><p>CVTE提前批c++开发一面<a href="https://www.nowcoder.com/discuss/89534">https://www.nowcoder.com/discuss/89534</a></p></li><li><p>CVTE的电话两面面经<a href="https://www.nowcoder.com/discuss/91635">https://www.nowcoder.com/discuss/91635</a></p></li><li><p>美团二面凉经：<a href="https://www.nowcoder.com/discuss/108186">https://www.nowcoder.com/discuss/108186</a></p></li><li><p>腾讯面经(一面，二面，hr面）：<a href="https://www.nowcoder.com/discuss/118386">https://www.nowcoder.com/discuss/118386</a></p></li><li><p>【C++开发】腾讯面筋<a href="https://www.nowcoder.com/discuss/89707">https://www.nowcoder.com/discuss/89707</a></p></li><li><p>腾讯内推面试<a href="https://www.nowcoder.com/discuss/93770">https://www.nowcoder.com/discuss/93770</a></p></li><li><p>腾讯IEG凉经<a href="https://www.nowcoder.com/discuss/96731">https://www.nowcoder.com/discuss/96731</a></p></li><li><p>一脸懵逼的腾讯面试<a href="https://www.nowcoder.com/discuss/96355">https://www.nowcoder.com/discuss/96355</a></p></li><li><p>腾讯云补录一面面经：<a href="https://www.nowcoder.com/discuss/140442">https://www.nowcoder.com/discuss/140442</a></p></li><li><p>小米云存储面经：<a href="https://www.nowcoder.com/discuss/111718">https://www.nowcoder.com/discuss/111718</a></p></li><li><p>小米面经：<a href="https://www.nowcoder.com/discuss/108813">https://www.nowcoder.com/discuss/108813</a></p></li><li><p>中兴武汉面经一面：<a href="https://www.nowcoder.com/discuss/112960">https://www.nowcoder.com/discuss/112960</a></p></li><li><p>vivo开发( c++)一面面经：<a href="https://www.nowcoder.com/discuss/118539">https://www.nowcoder.com/discuss/118539</a></p></li><li><p>8.10 vivo C++软件开发工程师一面面经<a href="https://www.nowcoder.com/discuss/93137">https://www.nowcoder.com/discuss/93137</a></p></li><li><p>金山WPS C++岗一面：<a href="https://www.nowcoder.com/discuss/118302">https://www.nowcoder.com/discuss/118302</a></p></li><li><p>金山WPS，C++，二面面筋<a href="https://www.nowcoder.com/discuss/95219">https://www.nowcoder.com/discuss/95219</a></p></li><li><p>金山C++研发工程师 一面<a href="https://www.nowcoder.com/discuss/96606">https://www.nowcoder.com/discuss/96606</a></p></li><li><p>金山 凉经<a href="https://www.nowcoder.com/discuss/96286">https://www.nowcoder.com/discuss/96286</a></p></li><li><p>wps一面面经<a href="https://www.nowcoder.com/discuss/97704">https://www.nowcoder.com/discuss/97704</a></p></li><li><p>金山wps一面<a href="https://www.nowcoder.com/discuss/97425">https://www.nowcoder.com/discuss/97425</a></p></li><li><p>金山WPS，C++研发工程师，一面<a href="https://www.nowcoder.com/discuss/92322">https://www.nowcoder.com/discuss/92322</a></p></li><li><p>【Java】银联应用开发面经（我是Java，他们也有C++） 西安站<a href="https://www.nowcoder.com/discuss/93155">https://www.nowcoder.com/discuss/93155</a></p></li><li><p>8月底的拼多多学霸批面经：<a href="https://www.nowcoder.com/discuss/112238">https://www.nowcoder.com/discuss/112238</a></p></li><li><p>拼多多面经：<a href="https://www.nowcoder.com/discuss/109638">https://www.nowcoder.com/discuss/109638</a></p></li><li><p>迈瑞面经–C++工程师<a href="https://www.nowcoder.com/discuss/90442">https://www.nowcoder.com/discuss/90442</a></p></li><li><p>中国电信it研发中心面筋：<a href="https://www.nowcoder.com/discuss/114075">https://www.nowcoder.com/discuss/114075</a></p></li><li><p>今日海康面试体验：<a href="https://www.nowcoder.com/discuss/112148">https://www.nowcoder.com/discuss/112148</a></p></li><li><p>海康威视面经：<a href="https://www.nowcoder.com/discuss/111844">https://www.nowcoder.com/discuss/111844</a></p></li><li><p>滴滴面经～回忆版：<a href="https://www.nowcoder.com/discuss/136818">https://www.nowcoder.com/discuss/136818</a></p></li></ul><h2 id="已看"><a href="#已看" class="headerlink" title="已看"></a>已看</h2><ul><li><p>网易雷火平台开发工程师一面：<a href="https://www.nowcoder.com/discuss/120667">https://www.nowcoder.com/discuss/120667</a></p><ul><li>一面<ul><li><ol><li>一个数组，找到top100: 堆</li></ol></li><li><ol start="2"><li>海量url去重 <ul><li>布隆过滤器, hash+字典树</li></ul></li></ol></li><li><ol start="3"><li>链表中倒数第k个结点 <ul><li>反向迭代器, 或则双指针</li></ul></li></ol></li><li><ol start="4"><li>二叉树的镜像 <ul><li>递归交换左右子树</li></ul></li></ol></li><li><ol start="5"><li>老生常谈的HashMap、HashTable、ConcurrentHashMap<ul><li>(!!!!!) ConcurrentHashMap</li></ul></li></ol></li><li><ol start="6"><li>TCP、UDP区别以及适用场景<ul><li>TCP:完整性要求</li><li>UDP:实时性要求, 完整性不要求</li></ul></li></ol></li><li><ol start="7"><li>实现多线程有哪些方法<ul><li>库函数:<ul><li>linux 有pthread</li><li>stl 有thread</li></ul></li><li>stl中:<ul><li>thread</li><li><code>async和feature</code> 启动一个异步线程,返回一个结果<ul><li><code>std::launch::async</code>, 创建线程异步</li><li><code>std::launch::deferred</code>: 不创建线程</li><li><code>feature.get()</code>: 等待并取值</li><li><code>feature.wait()</code>: 等待</li></ul></li><li><code>promise</code>: <ul><li>std::promise 类模板，我们能够在某个线程中给它赋值，然后我们可以在其他线程中把这个值取出来用;</li><li>通过promise保存一个值，在将来某时刻我们通过把一个future绑定到这个promise上来得到这个绑定的值。</li><li><code>promise.set_value()</code>: 设置值</li><li><code>promise.get_future()</code>: 将promise和feature相关联, 以供异步调用</li></ul></li><li><code>packaged_task</code><ul><li>std::packaged_task是个模板类，它的模板参数是各种可调用对象；</li><li>通过std::packaged_task来把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</li><li>packaged_task包装起来的可调用对象还可以直接调用，所以从这个角度来讲，packaged_task对象，也是一个可调用对</li><li>还可以通过packaged_task.get_feature和feature进行关联, 以实现异步调用</li></ul></li></ul></li><li><a href="https://blog.csdn.net/u012507022/article/details/85957219">C++11 多线程 async、future、packaged_task、promise</a></li></ul></li></ol></li><li><ol start="8"><li>MySQL、MongoDB区别以及适用场景（这个问题之前有先问我用过哪些数据库）<ul><li>MongoDB<ul><li>存储方式: 磁盘+内存(mmap映射, 和写有操作系统负责, 如果系统挂掉, 则会丢失数据), 如果内存足够的话, 很快</li><li>C++编写, 开源, 支持RUBY，PYTHON，JAVA，C++，PHP，C# 等多种语言</li><li>分布式, 自带GirdFS分布式文件系统(此文件系统可以存放大量小文件), 支持通过网络创建数据镜像</li><li>NoSql, 支持丰富的查询语言, 文档储存, 类似JSON, 增加了序列化的最终为BSON(Binary-JSON), 为二进制对海量数据比较有优势, 相较于其他的Nosql系统, 它支持的的第三方工具较为丰富</li><li>方便扩展, 事务支持较弱</li><li>自带Fail over机制(故障转移), 自带Sharding(分区)</li><li>弱一致性, 为了提升速度</li><li>占用空间大</li></ul></li><li>MySQL<ul><li>无论数据还是索引都存放在硬盘中。到要使用的时候才交换到内存中。能够处理远超过内存总量的数据。</li><li>关系型数据库。</li><li>在不同的引擎上有不同的存储方式。</li><li>查询语句是使用传统的 SQL 语句，拥有较为成熟的体系，成熟度很高。</li><li>InnoDB支持事务, MyISAM不支持事务</li><li>缺点就是在海量数据处理的时候效率会显著变慢。</li></ul></li><li><a href="https://blog.csdn.net/CatStarXcode/article/details/79513425">MySQL、MongoDB、Redis 数据库之间的区别</a></li></ul></li></ol></li><li><ol start="9"><li>MySQL有哪些存储引擎以及它们的区别和适用场景<ul><li>IndoDB:<ul><li>支持事务, 支持行级锁定, 支持外键</li><li>索引(数据和索引在一起), 同一个表可以储存于多个文件类, 所以表可以无限大</li><li>行数, 不支持FULLTEXT索引</li><li>支持CAID特性</li><li>迁移不方便, 需要先导出为MyIsam(不能有外键), 然后在在导入MyIsam</li></ul></li><li>MyIsam<ul><li>非事务</li><li>不支持外键, 不支持行级锁定个</li><li>索引和数据分开, 同一个表储存于同一个文件中, 所以表的大小首系统文件系统的限制</li><li>独立于操作系统, 迁移方便</li><li>迁移方便</li><li>强调性能, 速度快</li></ul></li></ul></li></ol></li></ul></li></ul></li><li><p>网易互娱面经：<a href="https://www.nowcoder.com/discuss/114820">https://www.nowcoder.com/discuss/114820</a></p><ul><li><p>1.C++虚函数，我开始向虚函数指针和虚表那块说，中间无意中说出了自己曾经看过虚函数表在elf文件中的位置，遂停止让我介绍虚表。</p></li><li><p>2.开始问虚表在elf文件何处以及基本形式，答完之后开始问关于elf文件相关知识。</p><ul><li><a href="https://blog.csdn.net/fw72fw72/article/details/68488739">C++ 虚函数表 存在哪</a></li></ul></li><li><p>4.开始测汇编能力，问函数调用时会干什么（当时很懵B，随后提示一定会执行什么语句）。</p></li><li><p>5.开始问gdb相关知识，大概问了几个调试命令。</p><ul><li>info br/source/stack/args</li><li>list function/filename:function/line-number/filiename:line-number</li><li>break / break function/line-number/filename:line-number</li><li>break * addr: 在某个地址中断</li><li>break … if cond: 条件断点<ul><li>断点四状态: delete, enable, enable once, enable for deletion</li></ul></li><li>watch expr 设置监控点</li><li>print expr(表达式exp中的变量必须是全局变量或当前堆栈区可见的变量)</li></ul></li><li><p>set varible=value</p><table><thead><tr><th>命令</th><th>简写形式</th><th>说明</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>查看源码</td></tr><tr><td>backtrace</td><td>bt、where</td><td>打印函数栈信息</td></tr><tr><td>next</td><td>n</td><td>执行下一行</td></tr><tr><td>step</td><td>s</td><td>一次执行一行，遇到函数会进入</td></tr><tr><td>finish</td><td>无</td><td>运行到函数结束</td></tr><tr><td>continue</td><td>c</td><td>继续运行</td></tr><tr><td>break</td><td>b</td><td>设置断点</td></tr><tr><td>info breakpoints</td><td>无</td><td>显示断点信息</td></tr><tr><td>delete</td><td>d</td><td>删除断点</td></tr><tr><td>print</td><td>p</td><td>打印表达式的值</td></tr><tr><td>run</td><td>r</td><td>启动程序</td></tr><tr><td>until</td><td>u</td><td>执行到指定行</td></tr><tr><td>info</td><td>i</td><td>显示信息</td></tr><tr><td>help</td><td>h</td><td>帮助信息</td></tr></tbody></table><ul><li><a href="https://www.jianshu.com/p/9f81880752cd">GDB 基础知识及断点</a></li><li><a href="https://blog.csdn.net/ni1288/article/details/8564026">GDB 基本知识</a></li></ul></li><li><p>6.开始转战STL，问用过哪些，还有map那点破事。</p></li><li><p>7.丢给我一组数让我建一棵红黑树，并询问是否记得红黑树创建规则</p></li><li><p>8.TCP/UDP那点破事，让我用UDP实现可靠数据传输。</p></li><li><p>9.linux那点破事，大概问了几个命令，记录当前资源占用率的文件存放在哪过，隐约记得是proc，便随口答了）。</p><ul><li><a href="https://baijiahao.baidu.com/s?id=1625547275238662021&wfr=spider&for=pc">linux系统/proc目录内容简介</a></li></ul></li><li><p>11.开始问问题，地图中有一个圆圈，怎么样保证丢的补给可以均匀落到地图各处。</p><ul><li>回答1.0，随机生成坐标点（x，y），首先判断是否在园内，在就投递。</li><li>回应：可以但是需要判断较为麻烦，优化一下。</li><li>回答2.0，以圆心为原点，随即生成半径和角度（r ，sieta不知怎么打）。</li><li>回应：不均匀，圆心处比较密。</li><li>回答3.0，以圆心为原点，随即生成半径平方和角度（r^2 ，sieta不知怎么打）。</li><li>回应：可以，但是证明一下落点是随即的。</li></ul></li><li><p>4.怎么样均匀洗一副扑克牌。</p><ul><li>回答1.0，使用随机数函数，每次生成一个数然后和剩余牌数取余，然后将该下标牌取出。</li><li>不对! 这样不均匀了</li><li><a href="https://www.cnblogs.com/xushuai123/archive/2013/02/26/2978059.html">算法 洗扑克牌(乱数排列)</a></li><li><a href="https://blog.csdn.net/qq_41035588/article/details/83310447">算法精练 快速洗扑克牌(乱数排序)</a></li></ul></li><li><p>1.排瓷砖，经典斐波那契数列问题。</p><ul><li>排瓷砖: <a href="https://blog.csdn.net/weixin_42725143/article/details/82146253">从铺砖问题到排列组合算法的实现</a></li><li>斐波那契数列: 递归</li></ul></li><li><p>2.快速获得一个队列中的最大元素。</p><ul><li>堆</li></ul></li></ul></li></ul><ul><li><p>网易雷火一面（估计已经凉了）：<a href="https://www.nowcoder.com/discuss/113819">https://www.nowcoder.com/discuss/113819</a></p><ul><li>一面</li><li>问：如何实现高平发后台？</li><li>答：<ul><li>1、CDN。<a href="https://www.jianshu.com/p/ce98fbff39ac">什么是cdn？</a><ul><li>CDN把DNS改为了CDN域名解析器, 使得客户端会向就近的缓存服务器提出申请</li><li>如果缓存服务器不存在则向真实服务器提出申请, 本地缓存+返回客户端</li></ul></li><li>2、负载均衡。<ul><li>负载均衡的几种实现方式<ul><li>http重定向:302</li><li>dns负载均衡: 缺点dns是存在多级缓存的, 各个dns节点之间进行同步也很麻烦, dns和服务器之间也是分类的</li><li>反向代理: 反向代理服务服务器处理所有的请求和响应, 其性能决定着瓶颈(工作于应用层)</li><li>ip层负载均衡: 请求和响应依旧得经过负载均衡服务器(工作于ip层)</li><li>数据链路层负载均衡: 请求经过负载均衡服务器, 但是响应不用(工作于数据链路层)</li></ul></li></ul></li><li>3、数据在内存缓存(Redis、memcache, mongodb)。</li></ul></li><li>问：http的Get方法和Post方法分别在场景使用？</li><li>答：小数据量和大数据量。用我做留言板时举例，为了标志不同的留言板，需要传get参数，这时需要实现“URL语义化”。如果是提交和删除留言，这时候用Post方法。<ul><li>get得参数是ascii编码, 且浏览器默认会cache它, 所以不适用于传输敏感数据</li><li>且get携带得参数长度受限, 如果要非常长的参数的话还是需要使用post</li><li>get是明文, post可加密</li><li>get查询数据, post修改数据</li></ul></li><li>问：数据表中Primary key和Unique key区别？</li><li>答：不太清楚。只知道每条记录的Primary key是不能相同的，Unique key是不能相同的。Primary key数据库会自动给它做索引，所以查询时以Primary key为条件比普通属性快。（面试官告诉我Unique key也会做索引。）</li><li><a href="https://www.cnblogs.com/zjfjava/p/6922494.html">Mysql中key 、primary key 、unique key 与index区别</a></li><li>问：数据表设计注意什么？</li><li>答：避免数据冗余。如果没有其他需求，尽量实现第三范式。有“多对多”的关系要分表。拿当时比特币测量时的数据库设计举例，另外讲到外键对性能的影响。<ul><li>三个范式:<ul><li>列不可再分</li><li>属性完全依赖主键</li><li>属性不依赖于其他非主键, 直接依赖于主键</li></ul></li></ul></li><li>问：关系型数据库和NoSQL共同工作。</li><li>答：不太清楚，大概要在业务逻辑层面处理数据该往那个数据库存吧？<ul><li>对于还在未来改动较大的业务, 也就是还没有定型的时候使用nosql, 毕竟nosql扩充方便</li><li>如果未来较为稳定的时候, 切换到关系型数据库</li></ul></li></ul></li><li><p>网易互娱-我为自己耽误了面试官的时间而愧疚：<a href="https://www.nowcoder.com/discuss/113550">https://www.nowcoder.com/discuss/113550</a></p><ul><li>hash函数的设计<ul><li>std::hash<T>() stl提供的获取哈希函数的</li><li>扰动函数 h = key.hashCode() ^ (h &gt;&gt;&gt; 16)</li><li><a href="https://www.cnblogs.com/zhengwang/p/8136164.html">HashMap中的hash函数</a></li></ul></li></ul></li><li><p>很难受的网易互娱研发面经: <a href="https://www.nowcoder.com/discuss/96710">https://www.nowcoder.com/discuss/96710</a></p><ul><li>一面<ul><li>多态，虚表虚指针，虚基类以及内存分布<ul><li>多态</li><li>虚函数</li><li>虚基类</li></ul></li><li>函数重载</li><li>构造函数和复制构造函数能否为虚，为什么</li><li>一个对象的内存分布，多个虚函数占多大空间</li><li>shared_ptr介绍原理，weak_ptr如何解决引用传递</li><li>右值引用</li><li>编译器如何处理模版</li><li>编译中的导出符号表和未决符号表<ul><li><a href="https://blog.csdn.net/petersmart123/article/details/52333818">编译过程和符号表重定位问题、静态和动态链接</a></li></ul></li><li>反汇编时符号表的状态</li><li>比较c++和java</li><li>介绍一下stl的list，查找list复杂度</li><li>unorder_map插入复杂度</li><li>stl迭代器重载</li><li>遍历vector的几种写法</li><li>数据库常用数据结构，b+树的好处</li><li>图的bfs和dfs</li><li>快排，复杂度，最坏情况以及设计算法解决</li><li>tcp和udp</li><li>如何用udp封装实现tcp</li><li>进程和线程</li><li>如何保证线程安全</li><li>互斥锁原理和使用</li><li>虚拟内存和LRU</li><li>字符串匹配kmp</li><li>最长公共子串dp的状态转移方程</li><li>点在线段上投影，向量解法</li></ul></li><li>二面：（50m）<ul><li>擅长的语言排下序，比较c++和java…</li><li>给定两点初始状态和运动方程，求两点相遇的时间和最早相遇的时间（没做出来）</li><li>文件io类似括号匹配的问题，疯狂提示下才想到用栈解决，也没完全做出来</li></ul></li></ul></li></ul><ul><li><p>网易初游研面经: <a href="https://www.nowcoder.com/discuss/96793">https://www.nowcoder.com/discuss/96793</a></p><ul><li><p>一面</p><ul><li><p>3、你知道什么排序算法？它们的平均复杂度各是多少？其中稳定的排序有哪些？</p><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O（n^2）</td><td>O（n^2）</td><td>O（1）</td><td>是</td></tr><tr><td>选择排序</td><td>O（n^2）</td><td>O（n^2）</td><td>O（1）</td><td>不是</td></tr><tr><td>直接插入排序</td><td>O（n^2）</td><td>O（n^2）</td><td>O（1）</td><td>是</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O（n）</td><td>是</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O（n^2）</td><td>O（logn）</td><td>不是</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O（1）</td><td>不是</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O（n^s）</td><td>O（1）</td><td>不是</td></tr><tr><td>计数排序</td><td>O(n+k)O</td><td>O(n+k)</td><td>O(n+k)</td><td>是</td></tr><tr><td>基数排序</td><td>O(N∗M)</td><td>O(N∗M)</td><td>O(M)</td><td>是</td></tr></tbody></table><ul><li>参考: <a href="https://blog.csdn.net/yushiyi6453/article/details/76407640">排序算法时间复杂度、空间复杂度、稳定性比较</a></li></ul></li><li><p>4、说一下快排。它的最坏复杂度是多少？什么情况下最坏？</p><ul><li>快排的重点是选择值, 如果每次选择的值都没有比他小的, 那就很尴尬了</li></ul></li><li><p>5、说一下归并？</p></li><li><p>6、哈希是什么？哈希如何存储数据？什么情况下用到哈希？</p></li><li><p>7、说一下static的作用？</p></li><li><p>8、虚函数你知道吗？它是如何实现的？</p></li><li><p>9、如何让一个类被有限次数的实例化？</p></li><li><p>10、纯虚函数是什么？如何定义？</p></li><li><p>11、一个类如何被称为抽象类？抽象类可以实例化吗？为什么？</p></li><li><p>12、如何比较两个对象？</p></li><li><p>13、跳台阶，一次跳1阶或2阶，n阶有多少种跳法？（最多能跳n阶呢？）（动态规划，递归）</p></li><li><p>14、一个链表，实现它的翻转。（当时定义了三个指针， = =反正挺简单的）</p></li><li><p>15、有一个数组，所有数据都可以是负数、0、正数，求和最大的连续序列。如果是一个矩阵呢？（矩阵的没答上）动态规划, 矩阵跟左上相关</p></li><li><p>16、stl库懂吗？你常用的有什么？</p></li><li><p>17、vector的底层是什么？它是如何实现动态分配空间的？如果将其中一个元素删除，那么它的地址空间是怎么样的？</p></li><li><p>18、map、set知道吗？（知道，底层红黑树。既然你说到红黑树，那说一下红黑树是什么？它的实质是什么？如何实现的？）说一下它们的区别？</p></li><li><p>19、线程和进程的区别？线程间如何通信？线程共享的资源有什么？</p></li><li><p>20、TCP和UDP的区别？TCP如何实现可靠传输？它们的传输方式？</p></li><li><p>21、socket懂吗？如何实现？</p></li><li><p>22、堆和栈的区别？</p><ul><li>堆是一种特殊的树,分为大根堆和小根堆</li><li>栈是可以看做是一个受限数组, 先进后出</li></ul></li></ul></li><li><p>二面（可能有一些在上面，具体也记不清了）：</p><ul><li>23、给你一串字符串，压缩它有几种方法？<ul><li>统计法</li></ul></li><li>24、vector赋值n个数，它需要拷贝几次？</li><li>25、基类A，派生类B继承于A，A *a = new B[10] 是否正确？ 会发生什么错误？ a[5]能正确的取到对象吗？<ul><li>编译能通过, 不能正确取到对象, 对于指针使用下标运算符,进行偏移的基本单位是指针的类型</li></ul></li><li>26、两个链表，判断他们是否有相交部分？如果他们相交部分有环呢？<ul><li>快慢指针法</li></ul></li><li>27、一副扑克，如何等概率洗牌？不消耗额外空间呢？<ul><li>交换法</li></ul></li></ul></li></ul></li><li><p>网易互娱游戏研发面经（两面）：<a href="https://www.nowcoder.com/discuss/111976">https://www.nowcoder.com/discuss/111976</a></p><ul><li>一面：<ul><li>有点印象的记得问了一些指向函数指针的数组怎么写？<ul><li>char a[] = “test” char b[] = “test”</li><li>char *p = “test” char *t = “test”</li><li>a==b ？</li><li>p==t ？</li></ul></li><li>二叉树非递归中序遍历。</li><li>讲一下因为保密协议不能说的笔试题</li><li>一个ip地址段（由首地址ip和尾地址ip组成，保证连续）表，怎么找到一个ip属于其中哪一个地址段？</li><li>（因为ip段不重合，根据首地址排序后二分找就可以了，感觉这题有点迷之简单。）</li><li>然后面试官就问ip段重合怎么办？然后当时没想出来，问题转化成查询覆盖一个点的所有线段。<ul><li>首先根据首地址排序,然后找到首地址比他小的</li><li>然后将首地址比他小的的段, 按照下限进行排序,然后找到比他大的,即可</li></ul></li></ul></li><li>二面：<ul><li>一致性哈希。<ul><li>为什么需要使用一致性哈希</li><li>哈希环</li><li>容错性和可扩展性</li><li>哈希环倾斜问题</li><li><a href="https://www.cnblogs.com/study-everyday/p/8629100.html">一致性哈希(hash)算法</a></li></ul></li><li>手撕智能指针。</li><li>给一个情景题，设想产生很多要求保序的请求从多个机器上发到一个多线程的—上，再由—调用分布式的数据库，怎么保证这个过程中的顺序不乱。<ul><li>如果这些命令需要串行执行的话, 那就不要使用并发, 使用同一个线程来串行完成这些执行</li><li>如果这些命令只需要顺序开始执行, 那么互斥的方式顺序加入任务队列,是一个不错的选择, 或则使用一个单线程来进行任务分发</li></ul></li><li>求一个数组左边之和最接近右边之和的节点。我想的是用前缀和来搞。</li><li>求中位数。<ul><li>求一个流动数组的中位数，每次加入元素都要返回中位数，两个堆解决。</li><li>对的两个堆, 大根堆(less)存小值, 小根堆(greater)存大值</li><li>第一个数存入小根堆</li><li>后面的每一个数根小根堆中的最小值比较, 如果比他大则将这个值加入小根堆中,并将小根堆的最小值放入大根堆</li></ul></li></ul></li></ul></li><li><p>网易互娱校招面经：<a href="https://www.nowcoder.com/discuss/111018">https://www.nowcoder.com/discuss/111018</a></p><ul><li>一面面经<ul><li>1，c++多态的实现。讲了c++虚函数表，单继承，多继承，虚继承以及为什么虚继承，调用过程</li><li>2，智能指针。</li><li>3，熟悉stl的什么结构。我说的是看过sgi 的stl源码。就问了什么情况用vector什么情况用list，以及vector的insert，erase，remove的实现还有重新申请内存的情况</li><li>4，红黑树，插入这么做。算法导论书上有<ul><li>首先当做二叉查找树进行查找, 新节点被当做为红色节点</li><li>着色<ul><li>此节点作为根节点或, 直接把本节点变成黑色</li><li>如果被插节点为黑色, 不用做</li><li>然后就是被插节点为红色:<ul><li>叔叔节点是红色<ul><li>(01) 将“父节点”设为黑色。</li><li>(02) 将“叔叔节点”设为黑色。</li><li>(03) 将“祖父节点”设为“红色”。</li><li>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</li></ul></li><li>叔叔节点是黑色，且当前节点是其父节点的右孩子<ul><li>(01) 将“父节点”作为“新的当前节点”。</li><li>(02) 以“新的当前节点”为支点进行左旋。</li></ul></li><li>叔叔节点是黑色，且当前节点是其父节点的左孩子    <ul><li>(01) 将“父节点”设为“黑色”。</li><li>(02) 将“祖父节点”设为“红色”。</li><li>(03) 以“祖父节点”为支点进行右旋。</li></ul></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/xuxinstyle/p/9556998.html">红黑树(R-B Tree)</a></li></ul></li><li>5，操作系统，虚拟内存，进程同步</li></ul></li><li>二面面经<ul><li>1，如何实现一个定时任务的模块，支持大量，不同时间的定时任务</li><li>最小堆实现，任务过多即使是o(log n)也不行，如何解决。<ul><li>多个不同时间范围的堆，来实现</li></ul></li><li>问了会不会linux时间轮算法，不会</li><li>2，快排，</li><li>TCP为什么是三次握手，两次握手什么时候会出错，</li><li>select和epoll的区别</li><li>3，一条直线上多个点运动 知道所有点的位置，和速度包括方向。当两个点相碰时，追及或对撞两个点消失</li><li>问什么时候达到稳定状态，也就是以后都不会发生碰撞。问时间<ul><li>用动态规划法, 每个点都跟前面的最大值比较如果比他小, 则会相撞</li></ul></li><li>4，英文文章，反转文章，单词的顺序改变。</li></ul></li></ul></li></ul><ul><li>字节跳动后端一面被一个巨水的面试官给毙了：<a href="https://www.nowcoder.com/discuss/128236">https://www.nowcoder.com/discuss/128236</a><ul><li>问了反转链表，要求空间复杂度o1，我在循环内用了一个局部指针变量，虽然不优雅，但是局部变量每次循环完都会被析构，他硬说我的空间复杂度是on。</li><li>然后问了虚函数，这是唯一问的c++，我感觉他也就会个虚函数了。</li><li>然后问找前k大的数。</li><li>我： 如果内存放得下的话，用类似快排的思想，partition把大的放左边，小的放右边，调用partition之后，如果分界元素等于k，则返回最左边的k个值；否则对k所在的半边递归调用parition，平均时间复杂度是on。</li><li>面试官（惊讶）： 时间复杂度是on？</li><li>我： 是啊</li><li>面试官： 真的是么？</li><li>我： 是啊，假如每次分界完，平均下次要处理的元素占总元素数的a/b，那么时间近似是（1+a/b+（a/b）^2+…）n= b/a*n</li><li>面试官： 那我的k要是很大，接近n，你这个不就是n平方了么</li><li>我： a/b是平均下次要处理的元素占本次处理的总元素的比值，跟k无关</li><li>面试官： 那最坏时间复杂度是多少</li><li>我： on^2 当数组已经有序，每次处理完规模减少1。 如果你觉得这个方法不好，在内存放得下的情况下，那我们用堆做，建一个最大堆，建堆的时间复杂度是on，调整k次，调整一次的时间复杂度是ologn，一共是o（n+klogn）</li><li>面试官： 建堆的时间复杂度是on？   </li><li>我： 建堆是从最后一个非叶结点开始调整，倒数第二层最多有n/2个需要调整的元素，最多需要调整1次，倒数第三层最多有n/4个需要调整的元素，每个最多需要调整2次，以此类推，最后累加起来接近线性时间复杂度。</li><li>面试官： 额…</li><li>我： 换一种方法，如果数据比较大，内存放不下，可以用优先队列，实现也是堆。优先队列是用一个最大堆，我们求前k大要用最小堆，所以要重载小于号运算符，优先队列重载时候要指定底层容器，我一般指定的是vector。执行时候如果队列里面的元素少于k个，则直接插入；否则将该元素与top（）比较，如果大则删掉top把这个元素放到队列中。</li><li>面试官：额..</li><li>我： 如果重复元素算一个，就用set，set是默认从小到大排列的，所以不需要重载运算符。</li><li>然后面试官没有回话，思考了一会，用“你会数据库么”结束了对算法的问询。在得知我不会数据库之后，面试官开始了他的主导，一直问数据库。我说，我不会数据库，要不你问问别的吧。然后他问我会网络么，我说曾经会一些，很久没用了，于是就问我tcp连接的终止，在我答完四次握手之后，问我服务器单方面终止链接之后，客户端继续发送数据会怎么样； 双方都终止了之后，客户端继续向服务器发送数据会怎么样。</li></ul></li></ul><ul><li><p>今日头条三面面经：<a href="https://www.nowcoder.com/discuss/109167">https://www.nowcoder.com/discuss/109167</a></p><ul><li><p>一面</p><ul><li><p>如何处理get和post</p></li><li><p>tcp接收窗口和拥塞窗口</p></li><li><p>什么时候会向对端传窗口大小</p><ul><li>tcp协议头里面就有, 为16位的滑窗大小</li></ul></li><li><p>extern C的意义</p></li><li><p>假设rtt（数据从两端一来一回） 100ms，那么从输入一个<a href="http://url到得到网页要多少时间/">http://url到得到网页要多少时间</a></p><ul><li>dns</li><li>建立连接需要3次握手,也就是150毫秒</li><li>传输数据需要至少需要一次, 也就是50ms</li><li>客户端解析html</li><li>然后四次挥手结束</li></ul></li><li><p>https呢？</p><ul><li>连续发送两次http请求，会得到两次结果吗？可能第二次比第一次快吗？</li></ul></li><li><p>是否了解TCP包头阻塞?</p><p>  - </p></li><li><p>服务器状态502 503 504什么问题，怎么排查</p><ul><li>501　　服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502　　Bad Gateway错误</li><li>503　　服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。（服务不可用）</li><li>504　　Bad Gateway timeout 网关错误</li><li>505　　服务器不支持请求中所用的 HTTP 协议版本。（HTTP 版本不受支持）</li></ul></li><li><p>netstat具体查看什么问题</p><ul><li>netstat 查看内核访问网络相关信息的进程, 还提供TCP链接, tcp,udp监听等功能</li></ul></li><li><p>写题：多路归并（用了堆，在细节上有一些问题）</p></li><li><p>看代码中的问题：构造函数可能会抛出异常, 从而造成内存泄漏, delete也可能异常, 最好把_p设置为const</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>_p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">delete</span> _p<span class="token punctuation">;</span> _p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span><span class="token operator">*</span> _p<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>sql：三句查询，要求建立索引来优化查询</p><ul><li>CREATE INDEX index_name ON table_name (column_name)</li><li>CREATE UNIQUE INDEX index_name ON table_name (column_name)</li><li>select * from where ddd</li></ul></li><li><p>一些linux语句的作用：</p><ul><li>less more </li><li>sed awk </li><li>du df dd (显示文件和目录的磁盘空间, 磁盘分区的详细信息, 指定内存块拷贝并进行转换)</li><li>at tee crotab </li><li>xargs </li></ul></li></ul></li><li><p>二面</p><ul><li>linux IO模型，区别在哪<ul><li>阻塞</li><li>非阻塞</li><li>IO复用</li><li>异步</li><li>信号</li></ul></li><li>线程独立拥有哪些资源</li><li>协程和线程有什么差别，优势呢？</li><li>get和post有什么差别</li><li>sendfile的优势在哪？<ul><li>不用经过用户层拷贝, 内核态进行</li><li><a href="https://blog.csdn.net/u014303647/article/details/82081451">高级I/O函数之sendfile函数</a></li></ul></li><li>代码：随机播放100首歌（洗牌算法/这个我把自己绕进去了，洗一次直接输出就完了，我当时脑子短路了，洗一次播一首非要再洗一次来手动提升复杂度，最后没绕出去，然后换题了）</li><li>两个倒序数组找最第k大的（框架差不多，最后发现漏了一种情况，感觉还在想洗牌的事情）<ul><li>第一个数组的倒数第k, 然后和第二个数组进行比较</li><li>直到第二个数组的值 大于等于第一个数组的值</li></ul></li></ul></li><li><p>三面</p><ul><li>C/C++内存问题有哪些，尽量说</li><li>free和delete在具体实现上的差异</li><li>free之后的指针使用有什么问题</li><li>缓冲区溢出如何避免，有哪些场景<ul><li><a href="https://blog.csdn.net/penngrove/article/details/48466249">避免缓冲区溢出的方法</a></li></ul></li><li>如何检查/处理越界</li><li>野指针和悬空指针分别是什么</li><li>试图使用野指针有什么问题</li><li>内存上还有别的问题吗？</li><li>C++11用过什么特性</li><li>之前讲的内存问题有什么好的方法吗？</li><li>智能指针讲一下</li><li>shared_ptr讲一下，怎么实现的，unique_ptr呢？</li><li>是不是所有要用指针的地方都应该用智能指针，有什么问题和不足？（我答了两次寻址和额外空间）</li><li>这些缺陷，在不用shared_ptr的前提下有减少成本的策略吗？（跳过了）</li><li>include，头文件里面一般放了些什么</li><li>声明和实现要写在一起吗？是不是一定要分开写？</li><li>写在一起和分开对最后的代码有什么影响，怎么确认（这个我不会，面试官让我试着分析一下，结合include的行为来谈）</li><li>gdb怎么查看一个函数的地址？</li><li>你在Linux使用经常哪些指令</li><li>如何探查CPU负载情况</li><li>在什么时候CPU被认为是繁忙/空闲的？</li><li>看过哪些比较大的代码？（后面很多问题是从这来的）</li><li>服务器：</li><li>多线程服务器和nginx在工作方式有什么不一样的地方</li><li>nginx怎么处理请求</li><li>进程唤醒（惊群问题）的额外成本主要在哪？</li><li>nginx的负载均衡（我只答了那个worker的负载均衡）</li><li>为什么它要用多进程，优势在哪，劣势在哪</li><li>多线程怎么应付同样的问题，能够解决吗，讲一讲方案</li><li>你的方案有什么问题？</li><li>http了解多少？</li><li>http缓存机制了解吗？</li><li>长连接讲一下</li><li>如何实现长连接（保活）</li><li>带外数据如何使用？</li><li>你的这个方法有什么问题，可以直接兼容不同的浏览器吗？</li><li>了解nginx的解决方案吗？</li><li>redis</li><li>你对redis怎么理解的？</li><li>redis的总体结构</li><li>单线程的优势和缺点</li><li>redis的事件分发</li><li>讲一讲文件事件有哪些</li><li>client功能是怎么实现的</li><li>时间事件（serverCron函数）</li><li>serverCron做了什么</li><li>redis所有事情都只有一个单线程吗？</li><li>bgsave讲一下，为什么要fork一个进程来做</li><li>interrupt与signal有什么差别</li><li>interrupt的发起和接受者是谁</li><li>操作系统在interrupt中发挥了什么作用</li><li>signal呢，发起者又是谁，接收者呢？（这里答得有点混乱）</li><li>TCP</li><li>ack什么时候发送，丢失了会怎么样？</li><li>sack了解吗？</li><li>重传ack的时机只有ack超时吗？</li><li>重复报文被接收会发生什么？</li><li>拥塞窗口要不要把自己的大小发给接收方，意义何在？（这个问题一面也问了，没有答出来）</li><li>延迟ACK的意义在哪？</li><li>为什么不能每次都直接发大的窗口？</li><li>进程地址空间布局讲一下</li><li>BSS为什么要叫这个名字？（后来查了，block started by symbol）</li><li>static关键字有什么作用，如果用来修饰函数呢？</li><li>多个线程使用static数据会开启多个副本吗？</li><li>C++OO</li><li>多重继承怎么实现</li><li>虚拟继承怎么实现</li><li>对于函数寻址在时间成本上有什么差异？</li><li>对于继承体系很复杂的情况这个成本会被拉高吗？</li></ul></li></ul></li></ul><h2 id="未看-1"><a href="#未看-1" class="headerlink" title="未看"></a>未看</h2><ul><li><p>头条1 2 3面经：<a href="https://www.nowcoder.com/discuss/99287">https://www.nowcoder.com/discuss/99287</a></p></li><li><p>今日头条三面面经：<a href="https://www.nowcoder.com/discuss/102612">https://www.nowcoder.com/discuss/102612</a></p></li><li><p>头条三面（攒一波人品）<a href="https://www.nowcoder.com/discuss/93423">https://www.nowcoder.com/discuss/93423</a></p></li><li><p>今日头条c++后台开发 一二面，二面gg <a href="https://www.nowcoder.com/discuss/95939">https://www.nowcoder.com/discuss/95939</a></p></li><li><p>平安科技一面又懵逼凉经：<a href="https://www.nowcoder.com/discuss/113464">https://www.nowcoder.com/discuss/113464</a></p></li><li><p>2019校招盛大游戏cocos凉经：<a href="https://www.nowcoder.com/discuss/109360">https://www.nowcoder.com/discuss/109360</a></p></li><li><p>趋势windows platform developer：<a href="https://www.nowcoder.com/discuss/111933">https://www.nowcoder.com/discuss/111933</a></p></li><li><p>【后台C++】360后台C++ 2面凉：<a href="https://www.nowcoder.com/discuss/103844">https://www.nowcoder.com/discuss/103844</a></p></li><li><p>360面筋！！：<a href="https://www.nowcoder.com/discuss/98392">https://www.nowcoder.com/discuss/98392</a></p></li><li><p>360面经：<a href="https://www.nowcoder.com/discuss/97830">https://www.nowcoder.com/discuss/97830</a></p></li><li><p>360一面二面，估计凉<a href="https://www.nowcoder.com/discuss/96670">https://www.nowcoder.com/discuss/96670</a></p></li><li><p>刚刚出炉的360一面二面挂经<a href="https://www.nowcoder.com/discuss/96310">https://www.nowcoder.com/discuss/96310</a></p></li><li><p>360一面凉经C++ <a href="https://www.nowcoder.com/discuss/97182">https://www.nowcoder.com/discuss/97182</a></p></li><li><p>360面经<a href="https://www.nowcoder.com/discuss/97830">https://www.nowcoder.com/discuss/97830</a></p></li><li><p>360面经<a href="https://www.nowcoder.com/discuss/97741">https://www.nowcoder.com/discuss/97741</a></p></li><li><p>360奇葩挂经<a href="https://www.nowcoder.com/discuss/98188">https://www.nowcoder.com/discuss/98188</a></p></li><li><p>贡献一波知乎面经。。：<a href="https://www.nowcoder.com/discuss/120463">https://www.nowcoder.com/discuss/120463</a></p></li><li><p>快手提前批面经：<a href="https://www.nowcoder.com/discuss/112954">https://www.nowcoder.com/discuss/112954</a></p></li><li><p>美图C++研发工程师（算法落地）面经~：<a href="https://www.nowcoder.com/discuss/103212">https://www.nowcoder.com/discuss/103212</a></p></li><li><p>【C++研发岗】贝壳三面面经。：<a href="https://www.nowcoder.com/discuss/102429">https://www.nowcoder.com/discuss/102429</a></p></li><li><p>米哈游引擎渲染挂面：<a href="https://www.nowcoder.com/discuss/120197">https://www.nowcoder.com/discuss/120197</a></p></li><li><p>微软面经：<a href="https://www.nowcoder.com/discuss/136414">https://www.nowcoder.com/discuss/136414</a></p></li><li><p>研发工程师面经（C++）：<a href="https://www.nowcoder.com/discuss/126102">https://www.nowcoder.com/discuss/126102</a></p></li><li><p>秋招结束，春招再战！（附面经）：<a href="https://www.nowcoder.com/discuss/125248">https://www.nowcoder.com/discuss/125248</a></p></li><li><p>offer选择，随便附上秋招面筋头条百度贝壳电信IT研发华为：<a href="https://www.nowcoder.com/discuss/123320">https://www.nowcoder.com/discuss/123320</a></p></li><li><p>某菜鸡的头条+百度菜鸡实习面试记录：<a href="https://www.nowcoder.com/discuss/118629">https://www.nowcoder.com/discuss/118629</a></p></li><li><p>秋招的面经：百度+中兴+链家+烽火：<a href="https://www.nowcoder.com/discuss/123214">https://www.nowcoder.com/discuss/123214</a></p></li><li><p>写个秋招总结C++开发岗：<a href="https://www.nowcoder.com/discuss/124174">https://www.nowcoder.com/discuss/124174</a></p></li><li><p>秋招结束，整理一下。内含面筋 ：<a href="https://www.nowcoder.com/discuss/124030">https://www.nowcoder.com/discuss/124030</a></p></li><li><p>一个失败者的秋招面经：<a href="https://www.nowcoder.com/discuss/123798">https://www.nowcoder.com/discuss/123798</a></p></li><li><p>2018年秋招游戏公司面经+面试准备心得：<a href="https://www.nowcoder.com/discuss/123714">https://www.nowcoder.com/discuss/123714</a></p></li><li><p>结束秋招，总结自己的秋招之旅，回馈牛客（面经大礼包）：<a href="https://www.nowcoder.com/discuss/123111">https://www.nowcoder.com/discuss/123111</a></p></li><li><p>弱鸡的游戏秋招之路：<a href="https://www.nowcoder.com/discuss/123043">https://www.nowcoder.com/discuss/123043</a></p></li><li><p>2018面经总结：<a href="https://www.nowcoder.com/discuss/122973">https://www.nowcoder.com/discuss/122973</a></p></li><li><p>终于轮到我了——来自非科班渣硕的秋招之路：<a href="https://www.nowcoder.com/discuss/122105">https://www.nowcoder.com/discuss/122105</a></p></li><li><p>非科班985水硕秋招经历：<a href="https://www.nowcoder.com/discuss/122056">https://www.nowcoder.com/discuss/122056</a></p></li><li><p>总结一下到目前为止的秋招，发C++面经攒人品：<a href="https://www.nowcoder.com/discuss/121780">https://www.nowcoder.com/discuss/121780</a></p></li><li><p>秋招结束，回馈牛友~（建议和面经）：<a href="https://www.nowcoder.com/discuss/121478">https://www.nowcoder.com/discuss/121478</a></p></li><li><p>和女朋友都已完成秋招，发出面经回馈牛客：<a href="https://www.nowcoder.com/discuss/120275">https://www.nowcoder.com/discuss/120275</a></p></li><li><p>总结一个菜鸡的秋招之路，望博牛油们一乐：<a href="https://www.nowcoder.com/discuss/120185">https://www.nowcoder.com/discuss/120185</a></p></li><li><p>C++开发渣硕妹纸BAT春招秋招面经：<a href="https://www.nowcoder.com/discuss/117644">https://www.nowcoder.com/discuss/117644</a></p></li><li><p>不一样的面经（攒人品）：<a href="https://www.nowcoder.com/discuss/116175">https://www.nowcoder.com/discuss/116175</a></p></li><li><p>回馈牛客，渣本的秋招总结（BAT）：<a href="https://www.nowcoder.com/discuss/114087">https://www.nowcoder.com/discuss/114087</a></p></li><li><p>腾讯、网易互娱面经：<a href="https://www.nowcoder.com/discuss/111543">https://www.nowcoder.com/discuss/111543</a></p></li><li><p>【C++后台研发工程师】C++后台研发工程师2018年BAT华为网易等面经总结：<a href="https://www.nowcoder.com/discuss/103939">https://www.nowcoder.com/discuss/103939</a></p></li><li><p>美团，快手面经~：<a href="https://www.nowcoder.com/discuss/101667">https://www.nowcoder.com/discuss/101667</a></p></li><li><p>贝壳现场面（C++）+京东技术管培生专业面：<a href="https://www.nowcoder.com/discuss/99274">https://www.nowcoder.com/discuss/99274</a></p></li><li><p>【C++/后端】2019秋招C++/后端 今日头条等公司面经 ：<a href="https://www.nowcoder.com/discuss/137145">https://www.nowcoder.com/discuss/137145</a></p></li><li><p>2018年秋招面试经验总结 ：<a href="https://www.nowcoder.com/discuss/140814">https://www.nowcoder.com/discuss/140814</a></p></li><li><p>秋招总结-奋斗没有结束，这只是一个开始：<a href="https://www.nowcoder.com/discuss/138258">https://www.nowcoder.com/discuss/138258</a></p></li><li><p>前来还愿啦，一波面经给需要的人：<a href="https://www.nowcoder.com/discuss/137775">https://www.nowcoder.com/discuss/137775</a></p></li><li><p>全凉经：<a href="https://www.nowcoder.com/discuss/142903">https://www.nowcoder.com/discuss/142903</a></p></li><li><p>一个非科班普通211硕士如何拿到腾讯、百度等offer：<a href="https://www.nowcoder.com/discuss/142151">https://www.nowcoder.com/discuss/142151</a></p></li><li><p>致下一级毕业生：如何将自身强化到斩获国内大厂Offer的水平：<a href="https://www.nowcoder.com/discuss/141516">https://www.nowcoder.com/discuss/141516</a></p></li><li><p>非计算机专业苦逼的秋招路：<a href="https://www.nowcoder.com/discuss/128187">https://www.nowcoder.com/discuss/128187</a></p></li><li><p>秋招结束，总结一下，说下个人经验：<a href="https://www.nowcoder.com/discuss/127797">https://www.nowcoder.com/discuss/127797</a></p></li><li><p>秋招over，回馈牛客网的帮助 ：<a href="https://www.nowcoder.com/discuss/122760">https://www.nowcoder.com/discuss/122760</a></p></li><li><p>秋招总结与技巧，回馈与感谢：<a href="https://www.nowcoder.com/discuss/122640">https://www.nowcoder.com/discuss/122640</a></p></li><li><p>(C++向)从零开始，游戏程序员学习之路(还愿贴)：<a href="https://www.nowcoder.com/discuss/121834">https://www.nowcoder.com/discuss/121834</a></p></li><li><p>2018年9月秋招个人总结 ：<a href="https://www.nowcoder.com/discuss/121665">https://www.nowcoder.com/discuss/121665</a></p></li><li><p>秋招结束，回馈牛客一波！：<a href="https://www.nowcoder.com/discuss/118716">https://www.nowcoder.com/discuss/118716</a></p></li><li><p>C++面试题目总结：<a href="https://www.nowcoder.com/discuss/124724">https://www.nowcoder.com/discuss/124724</a></p></li><li><p>秋招总结（C++）：<a href="https://www.nowcoder.com/discuss/124525">https://www.nowcoder.com/discuss/124525</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点后日谈</title>
      <link href="/2021/05/27/ji-lu/c/c-zhi-shi-dian-hou-ri-tan/"/>
      <url>/2021/05/27/ji-lu/c/c-zhi-shi-dian-hou-ri-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++ 基础"></a>C++ 基础</h1><h2 id="1、引用和指针的区别？"><a href="#1、引用和指针的区别？" class="headerlink" title="1、引用和指针的区别？"></a>1、引用和指针的区别？</h2><ul><li><p>初始化:</p><ul><li>引用在定义的时候必须进行初始化，并且不能够改变</li><li>指针在定义的时候不一定要初始化，并且指向的空间可变</li></ul></li><li><p>访问逻辑不同:</p><ul><li>通过指针访问对象, 用户需要使用间接访问</li><li>通过引用访问对象, 用户只需使用直接访问, 编译器负责将其处理为间接访问</li></ul></li><li><p>运算结果不同:</p><ul><li>自增运算结果不同</li><li><code>sizeof</code>运算的结果不同</li><li>下标运算: <ul><li>指针通过下标运算结果是指针所指值为基地址加上偏移, 且基地址可变.</li><li>引用通过下标运算结果是引用的是数组才能有这个操作.</li></ul></li><li>函数参数:<ul><li>传指针的实质是传值，传递的值是指针内储存的变量地址；</li><li>传引用的实质是传地址，传递的是变量的地址。</li></ul></li><li>多级: 有多级指针，但是没有多级引用，只能有一级引用。</li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/toyijiu/article/details/99729949">C++ 引用占用内存？ - toyijiu的专栏 - CSDN博客</a></li></ul><hr><h2 id="2、从汇编层去解释一下引用"><a href="#2、从汇编层去解释一下引用" class="headerlink" title="2、从汇编层去解释一下引用"></a>2、从汇编层去解释一下引用</h2><ul><li>参考两个语句<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// </span>mov ptr <span class="token punctuation">[</span>ebp<span class="token number">-4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span>lea eax<span class="token punctuation">,</span> <span class="token punctuation">[</span>ebp<span class="token number">-4</span><span class="token punctuation">]</span>mov dword ptr <span class="token punctuation">[</span>ebp<span class="token number">-8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> eax</code></pre></li><li><code>a</code>的地址为<code>ebp-4</code>,<code> b</code>的地址为<code>ebp-8</code>, 栈地址由高到底分配.</li><li>可以发现这个和指针的复制几乎一样,所以引用其实是通过指针来实现的</li></ul><h2 id="3、C-中的指针参数传递和引用参数传递"><a href="#3、C-中的指针参数传递和引用参数传递" class="headerlink" title="3、C++中的指针参数传递和引用参数传递"></a>3、C++中的指针参数传递和引用参数传递</h2><ul><li><strong>指针参数传递的本质是值传递, 传递的值是对象的地址</strong>, 在调用时形参会在函数栈中开辟空间用于存放传递过来的对象的地址,此时形参相当于是实参的副本, 对形参的任何操作都不会反映到实参上, 但是通过形参间接访问对象的修改是会反应到函数之外的.</li><li><strong>引用参数传递的本质是传地址, 传递的是实参变量的地址</strong>, 首先形参会在函数栈中开辟空间用来存放实参变量的地址, 然后对该形参的任何操作都会被处理未间接寻址,即通过形参中的地址访问主调函数中的实参变量, 因为通过形参的任何操作都将被应用于主调函数中.</li><li>从逻辑上引用相当于对变量起了一个别名, 通过该别名可以对变量进行直接访问, 由编译器负责将直接访问转换为间接访问; 而指针访问变量都是间接访问.</li></ul><h2 id="4、形参与实参的区别？"><a href="#4、形参与实参的区别？" class="headerlink" title="4、形参与实参的区别？"></a>4、形参与实参的区别？</h2><ul><li>形参属于函数内部的局部变量, 在调用函数时才会分配内存, 在函数调用之后会被释放掉, 因此在函数内部才有效</li><li>实参可以使常量, 表达式, 函数等, 无论是何种类型,在函数调用时都必须有一个确定的值,以便把函数的值传递给形参</li><li>实参和形参的个数一定要严格匹配(当然可以忽略有默认值形参), 通常情况下函数类型也是应该严格匹配的, 但是允许隐式类型变换,如果类中定义了零参数构造函数,甚至可以使用空初始化列表<code>&#123;&#125;</code>的方式调用零参数构造函数</li><li>实参到形参的传递是单向的</li><li>形参类型为非指针非引用, 则传递方式为值传递则, 形参为实参的副本, 对形参的任何修改都不会反应在主调函数中</li></ul><h2 id="4-2-三种传递方式"><a href="#4-2-三种传递方式" class="headerlink" title="4-2 三种传递方式"></a>4-2 三种传递方式</h2><ul><li>值传递是通过拷贝构造函数实现的</li><li>指针传递是属于值传递,实参指针向形参传递的是对象的地址</li><li>引用传是属于传地址, 相当于对变量起了一个别名, 本质上和指针传递类似传递的都是对象的地址,区别在于对该引用形参的任何操作都会被处理为间接云芝, 也就是会反应到调用函数中</li></ul><h2 id="5、static的用法"><a href="#5、static的用法" class="headerlink" title="5、static的用法"></a>5、<code>static</code>的用法</h2><ul><li>主要可以分为五个类型: 全局静态变量, 局部静态变量, 静态函数, 静态成员变量, 静态成员函数</li></ul><ol><li><p>全局静态变量</p><ul><li>在全局变量前加上关键字<code>static</code>，全局变量就定义成一个全局静态变量.</li><li>内存中的位置：静态存储区，在整个程序运行期间一直存在。</li><li>初始化：未经初始化的全局静态变量会被自动初始化为<code>0</code>(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败);</li><li>作用域：<strong>全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</strong></li></ul></li><li><p>局部静态变量</p><ul><li>在局部变量之前加上关键字<code>static</code>，局部变量就成为一个局部静态变量。</li><li>内存中的位置：静态存储区</li><li>初始化：未经初始化的全局静态变量会被自动初始化为<code>0</code>(对于自动对象,如果没有显示初始化,会调用零参数构造函数,如不存在则编译失败)；</li><li>作用域：作用域仍为局部作用域，<ul><li>当定义它的函数或者语句块结束的时候，作用域结束。</li><li>但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li></ul></li></ul></li><li><p>静态函数</p><ul><li>在函数返回类型前加<code>static</code>，函数就定义为静态函数。<strong>函数的定义和声明在默认情况下都是<code>extern</code>的</strong>，但<strong>静态函数只是在声明他的文件当中可见，不能被其他文件所用</strong>。</li><li>函数的实现使用<code>static</code>修饰，<strong>那么这个函数只可在本<code>cpp</code>内使用，不会同其他<code>cpp</code>中的同名函数引起冲突；</strong></li><li><code>warning</code>：不要再头文件中声明<code>static</code>的全局函数，不要在<code>cpp</code>内声明非<code>static</code>的全局函数，如果你要在多个<code>cpp</code>中复用该函数，就把它的声明提到头文件里去，否则<code>cpp</code>内部声明需加上<code>static</code>修饰；</li></ul></li><li><p>类的静态成员</p><ul><li>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。</li><li>因此，<strong>静态成员是类的所有对象中共享的成员，而不是某个对象的成员</strong>。对多个对象来说，静态数据成员只存储一处，供所有对象共用</li></ul></li><li><p>类的静态函数</p><ul><li><strong>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员</strong>。因此，对静态成员的引用不需要用对象名。</li><li>*<em>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员(这点非常重要)**。</em>如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);*</li><li>不能被<code>virtual</code>修饰,静态成员函数没有<code>this</code> 指针，虚函数的实现是为每一个对象分配一个<code>vptr</code> 指针，而<code>vptr</code> 是通过<code>this</code> 指针调用的，所以不能为<code>virtual</code>；虚函数的调用关系，<code>this</code>-&gt;<code>vptr</code>-&gt;<code>ctable</code>-&gt;<code>virtual function</code></li></ul></li></ol><h2 id="6、静态变量什么时候初始化"><a href="#6、静态变量什么时候初始化" class="headerlink" title="6、静态变量什么时候初始化"></a>6、静态变量什么时候初始化</h2><ul><li>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，</li><li>但在<code>C </code>和<code>C++</code>中静态局部变量的初始化节点又有点不太一样。<ul><li>在<code>C</code>中，<strong>初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化</strong>，所以我们看到==在<code>C </code>语言中无法使用变量对静态局部变量进行初始化==，在程序运行结束，变量所处的全局内存会被全部回收。</li><li>而在<code>C++</code>中，<strong>初始化时在执行相关代码时才会进行初始化</strong>，主要是由于<code>C++</code>引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以  <strong><code>C++</code>标准规定为全局或静态对象是有首次用到时才会进行构造</strong> ，并通过<code>atexit()</code>来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在 <strong><code>C++</code>中是可以使用变量对静态局部变量进行初始化的。</strong></li></ul></li></ul><h2 id="7、const"><a href="#7、const" class="headerlink" title="7、const?"></a>7、const?</h2><ul><li>一般可以分为如下六种类型<ul><li><code>const</code>变量(<code>const int *p1</code>): 表明标了为<code>const</code>类型, 通常需要被初始化否则后面将不能被修改, 对该变量的修改操作都会被编译器阻止.(起始就是<code>top-level const</code>)</li><li><code>const</code>指针对象(<code>int * const p2</code>): 标明该指针为普通的左值类型可以进行修改, 但是不能通过该变量修改做指向的对象, 则通过该指针只能访问<code>const</code>类型的成员函数.(<code>bottom-level const</code>)</li><li><code>const</code>引用: 它所绑定的对象不能被修改</li><li><code>const</code>形参: 和普通的实参分类一样分为const 变量, const指针对象, const 引用, 作用也类似,表示不能修改该变量.</li><li><code>const</code>返回值: 通常是为了表明返回值是一个<strong>const类型防止返回值被修改</strong>, 或则<strong>被当做左值放在赋值运算的左边</strong></li><li><code>const</code>成员函数: 是指成员函数不会修改类对象的任何成员变量, 如果返回值为对象成员的引用则必须返回<code>const</code>引用, 同时<code>const</code>成员函数不能调用非<code>const</code>函数, 其主要是因为<code>const</code>成员函数所持有的<code>this</code>指针是一个<code>const</code>类型的指针, 因为不能调用非<code>const</code>类型的成员函数.</li></ul></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/Azhu/p/4352613.html">c++函数返回类型什么情况带const - A_zhu - 博客园</a></li></ul><hr><h2 id="8、const-成员函数的理解和应用？"><a href="#8、const-成员函数的理解和应用？" class="headerlink" title="8、const 成员函数的理解和应用？"></a>8、<code>const </code>成员函数的理解和应用？</h2><ul><li><code>① const Stock &amp; Stock::topval (②const Stock &amp; s) ③const</code></li><li>① 处<code>const</code>：确保返回的<code>Stock </code>对象在以后的使用中不能被修改</li><li>② 处<code>const</code>：确保此方法不修改传递的参数<code>s</code></li><li>③ 处<code>const</code>：保证此方法不修改调用它的对象，<code>const </code>对象只能调用<code>const </code>成员函数,不能调用非<code>const </code>函数</li></ul><h2 id="9、指针和const的用法"><a href="#9、指针和const的用法" class="headerlink" title="9、指针和const的用法"></a>9、指针和<code>const</code>的用法</h2><ul><li>当<code>const </code>修饰指针时，由于<code>const </code>的位置不同，它的修饰对象会有所不同。</li><li><strong>(常指针对象)</strong> <code>int *const p2 </code>中<code>const </code>修饰<code>p2 </code>的值,所以理解为<code>p2 </code>的值不可以改变，即<code>p2 </code>只能指向固定的一个变量地址，但可以通过<code>*p2 </code>读写这个变量的值。顶层指针表示指针本身是一个常量</li><li><strong>(常指针)</strong> <code>int const *p1 </code>或者<code>const int *p1 </code>两种情况中<code>const </code>修饰<code>*p1</code>，所以理解为<code>*p1 </code>的值不可以改变，即不可以给<code>*p1 </code>赋值改变<code>p1 </code>指向变量的值，但可以通过给<code>p </code>赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。</li></ul><h2 id="10、mutable"><a href="#10、mutable" class="headerlink" title="10、mutable"></a>10、<code>mutable</code></h2><ul><li>如果需要在<code>const </code>成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为<code>mutable</code>。<strong>即用<code>mutable </code>修饰的成员变量不受<code>const </code>成员方法的限制;</strong></li><li>可以认为<code>mutable </code>的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于<code>const_cast</code>的存在，这个概念很多时候用处不是很到了。</li></ul><hr><ul><li>通常情况下<ul><li><code>const</code>成员函数时不能被类对象的成员变量的, 但是可以修改被<code>mutable</code>修饰的成员变量</li><li>通常我们任务<code>mutable</code>位类的辅助状态, 只是类的一些表诉功能, <strong>修改它不会改变对象的状态</strong></li><li>通常我们可以是用<code>const_cast</code>在<code>const</code>成员函数中修改所有的成员变量</li></ul></li></ul><hr><h2 id="11、extern-用法？"><a href="#11、extern-用法？" class="headerlink" title="11、extern 用法？"></a>11、<code>extern </code>用法？</h2><ul><li><code>extern </code>修饰变量的声明<ul><li>如果文件<code>a.c </code>需要引用<code>b.c </code>中变量<code>int v</code>，就可以在<code>a.c </code>中声明<code>extern int v</code>，然后就可以引用变量<code>v</code>。</li></ul></li><li><code>extern </code>修饰函数的声明<ul><li>如果文件<code>a.c </code>需要引用<code>b.c </code>中的函数，比如在<code>b.c </code>中原型是<code>int fun(int mu)</code>，那么就可以在<code>a.c </code>中声明<code>extern int fun(int mu)</code>，然后就能使用<code>fun </code>来做任何事情。</li><li>就像变量的声明一样，<code>extern int fun(int mu)</code>可以放在<code>a.c </code>中任何地方，而不一定非要放在<code>a.c </code>的文件作用域的范围中。</li><li>默认情况情况下函数都是<code>extern</code>的, 除非使用<code>static</code>对函数进行了隐匿</li></ul></li><li><code>extern </code>修饰符可用于指示<code>C </code>或者<code>C++</code>函数的调用规范。<ul><li>比如在<code>C++</code>中调用<code>C </code>库函数，就需要在<code>C++</code>程序中用<code>extern “C”</code>声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用<code>C </code>函数规范来链接。主要原因是<code>C++</code>和<code>C </code>程序编译完成后在目标代码中命名规则不同。</li></ul></li></ul><h2 id="12、int-转字符串-字符串转int"><a href="#12、int-转字符串-字符串转int" class="headerlink" title="12、int 转字符串, 字符串转int"></a>12、<code>int</code> 转字符串, 字符串转<code>int</code></h2><ul><li><code>C++11</code> 标准增加了全局函数<code>std::to_string</code></li><li>可以使用<code>std::stoi</code>/<code>std::stol</code>/<code>std::stoll</code> 等等函数</li></ul><h2 id="12-1-strcat-strcpy-strncpy-memset-memcpy-的内部实现？"><a href="#12-1-strcat-strcpy-strncpy-memset-memcpy-的内部实现？" class="headerlink" title="12.1 strcat,strcpy,strncpy,memset,memcpy 的内部实现？"></a>12.1 <code>strcat</code>,<code>strcpy</code>,<code>strncpy</code>,<code>memset</code>,<code>memcpy</code> 的内部实现？</h2><ul><li><code>strcat</code>: <code>char *strcat(char *dst, char const *src);</code><ul><li>头文件: <code>#include &lt;string.h&gt;</code></li><li>作用: 将<code>dst</code>和<code>src</code>字符串拼接起来保存在<code>dst</code>上</li><li>注意事项:<ul><li><code>dst</code>必须有足够的空间保存整个字符串</li><li><code>dst</code>和<code>src</code>都必须是一个由<code>\0</code>结尾的字符串(空字符串也行)</li><li><code>dst</code>和<code>src</code>内存不能发生重叠</li></ul></li><li>函数实现:<ul><li>首先找到<code>dst</code>的<code>end</code></li><li>以<code>src</code>的<code>\0</code>作为结束标志, 将<code>src</code>添加到<code>dst</code>的<code>end</code>上</li></ul></li><li><code>Code</code><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcat</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> src<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> dst <span class="token operator">&amp;&amp;</span> <span class="token constant">NULL</span> <span class="token operator">!=</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 源码里没有断言检测</span>  <span class="token keyword">char</span> <span class="token operator">*</span> cp <span class="token operator">=</span> dst<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>cp <span class="token punctuation">)</span>       cp<span class="token operator">++</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">/* find end of dst */</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">/* Copy src to end of dst */</span>  <span class="token keyword">return</span><span class="token punctuation">(</span> dst <span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">/* return dst */</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><code>strcpy</code>: <code>char *strcpy(char *dst, const char *src);</code><ul><li>头文件:<code>#include &lt;string.h&gt;</code></li><li>作用: 将<code>src</code>的字符串复制到<code>dst</code>字符串内</li><li>注意事项:<ul><li><code>src</code>必须有结束符(<code>\0</code>), 结束符也会被复制</li><li><code>src</code>和<code>dst</code>不能有内存重叠</li><li><code>dst</code>必须有足够的内存</li></ul></li><li>函数实现:<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 实现src到dst的复制</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>dst <span class="token operator">==</span> src<span class="token punctuation">)</span> <span class="token keyword">return</span> dst<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//源码中没有此项</span>　  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dst <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>src <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//源码没有此项检查，判断参数src和dst的有效性</span>　　<span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> dst<span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">//保存目标字符串的首地址</span>　　<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>cp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//把src字符串的内容复制到dst下</span>　　<span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><code>strncpy</code>: <code>char *strncpy(char *dst, char const *src, size_t len);</code><ul><li>头文件: <code>#include &lt;string.h&gt;</code></li><li>作用: 从<code>src</code>中复制<code>len</code>个字符到<code>dst</code>中, 如果不足<code>len</code>则用<code>NULL</code>填充, 如果<code>src</code>超过<code>len</code>, 则<code>dst</code>将不会以<code>NULL</code>结尾</li><li>注意事项:<ul><li><code>strncpy </code>把源字符串的字符复制到目标数组，它总是正好向<code>dst</code>写入<code>len</code>个字符。</li><li>如果<code>strlen(src)</code>的值小于<code> len</code>，<code>dst </code>数组就用额外的<code>NULL</code>字节填充到<code>len</code>长度。</li><li>如果<code> strlen(src)</code>的值大于或等于<code> len</code>，那么只有<code>len</code>个字符被复制到<code>dst</code>中。这里需要注意它的结果将不会以<code>NULL</code>字节结尾。</li></ul></li><li>函数实现:<pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>dst <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> src <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//源码没有此项</span>  <span class="token keyword">char</span> <span class="token operator">*</span>cp <span class="token operator">=</span> dst<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>len<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>src <span class="token operator">!=</span> <span class="token string">'\0'</span><span class="token punctuation">)</span>      <span class="token operator">*</span>cp<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">//源码没有此项</span>  <span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><code>memset</code>: <code>void *memset(void *a, int ch, size_t length);</code><ul><li>头文件: <code>#include &lt;string.h&gt;</code></li><li>作用: <ul><li>将参数<code>a</code>所指的内存区域前<code>length</code>个字节以参数<code>ch</code>填入，然后返回指向<code>a</code>的指针。</li><li>在编写程序的时候，若需要将某一数组作初始化，<code>memset()</code>会很方便。</li><li>一定要保证<code>a</code>有这么多字节</li></ul></li><li>函数实现:<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> ch<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">void</span> <span class="token operator">*</span>s <span class="token operator">=</span> a<span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>length<span class="token operator">--</span><span class="token punctuation">)</span>       <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> ch<span class="token punctuation">;</span>           s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> a<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><code>memcpy</code><ul><li>头文件: <code>#include &lt;string.h&gt;</code></li><li>作用: <ul><li>从<code>src</code>所指的内存地址的起始位置开始，拷贝<code>n</code>个字节的数据到<code>dest</code>所指的内存地址的起始位置。</li><li>可以用这种方法复制任何类型的值，</li><li><strong>如果<code>src</code>和<code>dst</code>以任何形式出现了重叠，它的结果将是未定义的。</strong></li></ul></li><li>函数实现:<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dst <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>src <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token keyword">char</span> <span class="token operator">*</span>tempSrc<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>src<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//保存src首地址</span>　　<span class="token keyword">char</span> <span class="token operator">*</span>tempDst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>dst<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//保存dst首地址</span>　　<span class="token keyword">while</span><span class="token punctuation">(</span>length<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">//循环length次，复制src的值到dst中</span>     　　<span class="token operator">*</span>tempDst<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>tempSrc<span class="token operator">++</span> <span class="token punctuation">;</span>　　<span class="token keyword">return</span> dst<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul><hr><ul><li><code>strcpy </code>和<code>memcpy</code>的主要区别：<ul><li>复制的内容不同:<code>strcpy</code>只能复制字符串，而<code>memcpy</code>可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同:<code>strcpy</code>不需要指定长度，它遇到被复制字符的串结束符<code>\0</code>才结束，所以容易溢出。<code>memcpy </code>则是根据其第<code>3</code>个参数决定复制的长度，遇到<code>\0</code>并不结束。</li><li>用途不同: 通常在复制字符串时用<code> strcpy</code>，而需要复制其他类型数据时则一般用<code> memcpy</code></li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/nyist_zxp/article/details/80982472">各种C语言处理函数 strcat，strcpy，strncpy，memset，memcpy 总结 - New World - CSDN博客</a></li></ul><h2 id="13、深拷贝与浅拷贝？"><a href="#13、深拷贝与浅拷贝？" class="headerlink" title="13、深拷贝与浅拷贝？"></a>13、深拷贝与浅拷贝？</h2><ul><li>浅复制: <ul><li>只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“(浅复制)浅拷贝”，</li><li>换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</li></ul></li><li>深复制: 在计算机中开辟了一块新的内存地址用于存放复制的对象。</li></ul><hr><ul><li>浅复制的问题:<ul><li>在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。</li><li>这时，如果B 中有一个成员变量指针已经申请了内存，那A 中的那个成员变量也指向同一块内存。</li><li>这就出现了问题：当B把内存释放了(如：析构)，这时A 内的指针就是野指针了，出现运行错误。</li></ul></li></ul><hr><h2 id="14、C-模板是什么，底层怎么实现的？"><a href="#14、C-模板是什么，底层怎么实现的？" class="headerlink" title="14、C++模板是什么，底层怎么实现的？"></a>14、<code>C++</code>模板是什么，底层怎么实现的？</h2><ul><li><p><strong>编译器并不是把函数模板处理成能够处理任意类的函数</strong>；编译器从函数模板通过具体类型产生不同的函数；</p></li><li><p>编译器会对函数模板进行两次编译：</p><ul><li>在声明的地方对模板代码本身进行编译，</li><li>在调用的地方对参数替换后的代码进行编译。</li></ul></li><li><p>这是因为<strong>函数模板要被实例化后才能成为真正的函数</strong>，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p></li><li><p>模板可以重载返回值, 函数重载不行</p></li></ul><hr><ul><li>如果我们试图通过在头文件中定义函数模板, 在<code>cpp</code>文件中实现函数模板, 那么我们必须在在实现的那个<code>cpp</code>文件中<strong>手动实例化</strong>, 也就是使用你需要使用的参数替换模板, 从而使得编译器为你编译生成相应参数的模板函数.</li></ul><hr><h2 id="15、C-语言struct-和C-struct-区别"><a href="#15、C-语言struct-和C-struct-区别" class="headerlink" title="15、C 语言struct 和C++ struct 区别"></a>15、<code>C </code>语言<code>struct </code>和<code>C++</code> <code>struct </code>区别</h2><ul><li><code>struct </code>在<code>C语言</code>中:<ul><li>是**用户自定义数据类型<code>(UDT)</code>**；</li><li>只能是一些<strong>变量的集合体</strong>, 成员不能为函数</li><li>没有权限设置</li><li>一个<strong>结构标记</strong>声明后，在<code>C</code>中必须在<strong>结构标记</strong>前加上<code>struct</code>，才能做<strong>结构类型名</strong>;</li></ul></li></ul><hr><ul><li><code>struct </code>在<code>C++</code>中:<ul><li>是**抽象数据类型<code>(ADT)</code>**，支持成员函数的定义，(能继承，能实现多态)。</li><li>增加了访问权限, 默认访问限定符为<code>public</code>(为了与<code>C </code>兼容)，<code>class </code>中的默认访问限定符为<code>private</code></li><li>定义完成之后, 可以直接使用<strong>结构体名字</strong>作为<strong>结构类型名</strong></li><li>可以使用模板</li></ul></li></ul><hr><h2 id="16、虚函数可以声明为inline吗"><a href="#16、虚函数可以声明为inline吗" class="headerlink" title="16、虚函数可以声明为inline吗?"></a>16、虚函数可以声明为<code>inline</code>吗?</h2><ul><li><strong>虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换, 所以不能</strong></li></ul><hr><ul><li>虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。</li><li>内联函数用于提高效率, 对于程序中需要频繁使用和调用的小函数非常有用。它是在<strong>编译期间</strong>，对调用内联函数的地方的代码<strong>替换</strong>成函数代码。</li></ul><hr><h2 id="17、类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？"><a href="#17、类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？" class="headerlink" title="17、类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？"></a>17、类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？</h2><ul><li><p>概念</p><ul><li>赋值初始化，通过在函数体内进行赋值初始化；</li><li>列表初始化，在冒号后使用初始化列表进行初始化。</li></ul></li><li><p>这两种方式的主要区别在于：</p><ul><li>对于在<strong>函数体中初始化</strong>,是在所有的成员函数分配空间后才进行的。<strong>对于类对象类型成员变量, 则是先调用零参数构造函数, 如果零参数构造函数不存在编译器将会报错.</strong></li><li>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)。</li></ul></li><li><p>快的原因: 所以对于列表初始化: 只进行了一次初始化操作, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数.</p></li><li><p>一个派生类构造函数的执行顺序如下：</p><ul><li><strong>虚基类</strong>的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。</li><li><strong>基类</strong>的构造函数(多个普通基类也按照继承的顺序执行构造函数)。</li><li><strong>类类型的成员对象</strong>的构造函数(按照初始化顺序)</li><li>派生类<strong>自己的构造函数</strong>。</li></ul></li></ul><h2 id="18、成员列表初始化？"><a href="#18、成员列表初始化？" class="headerlink" title="18、成员列表初始化？"></a>18、成员列表初始化？</h2><ul><li><strong>必须</strong>使用成员初始化的四种情况<ul><li>当初始化一个<strong>引用</strong>成员时；</li><li>当初始化一个<strong>常量成员</strong>时；</li><li><strong>基类</strong>， <strong>无零参数构造函数</strong>时</li><li><strong>成员类</strong>，  <strong>无零参数构造函数</strong>时</li></ul></li><li>成员初始化列表做了什么<ul><li>编译器在调用用户代码之前, 会按照类成员声明顺序一一初始化成员变量, 如果成员初始化类别中有初值,则使用初值构造成员函数. </li><li>初始化顺序由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</li></ul></li></ul><h2 id="19、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#19、构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="19、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>19、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h2><h3 id="构造函数为什么不能为虚函数"><a href="#构造函数为什么不能为虚函数" class="headerlink" title="构造函数为什么不能为虚函数?"></a>构造函数为什么不能为虚函数?</h3><ul><li><p>首先是没必要使用虚函数:</p><ul><li>由于使用间接调用(通过引用或则指针)导致类<strong>类型不可信</strong>, 而使用虚函数机制完成正确的函数调用.</li><li>但是构造函数本身是为了初始化对象实例, 创建对象必须制定它的类型, 其类类型是明确的, 因此在编译期间即可确定调用函数入口地址</li><li>因而没必要使用虚函数, 其调用在编译时由编译器已经确定. </li></ul></li><li><p>其次不能使用虚函数:</p><ul><li>虚函数的调用依赖于虚函数表, 虚函数表储存于静态储存区, 在存在虚函数的对象中都将插入一个指向虚函数表的指针, </li><li>在对象中插入一个指向虚函数表的指针是由构造函数完成的, 也就是说在调用构造函数时并没有指向虚函数表的指针, 也就不能完成虚函数的调用. </li></ul></li></ul><h3 id="析构函数为什么要虚函数？"><a href="#析构函数为什么要虚函数？" class="headerlink" title="析构函数为什么要虚函数？"></a>析构函数为什么要虚函数？</h3><ul><li><code>C++</code>中基类采用<code>virtual </code>虚析构函数是为了防止内存泄漏。<ul><li>如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</li><li>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</li><li>所以，为了防止这种情况的发生，<code>C++</code>中基类的析构函数应采用<code>virtual </code>虚析构函数。    </li></ul></li></ul><h2 id="20、析构函数的作用，如何起作用？"><a href="#20、析构函数的作用，如何起作用？" class="headerlink" title="20、析构函数的作用，如何起作用？"></a>20、析构函数的作用，如何起作用？</h2><ul><li>析构函数名与类名相同,只是在函数名前增加了取反符号<code>~</code>以区别于构造函数,其不带任何参数, 也<strong>没有返回值</strong>.  也<strong>不允许重载</strong>. </li><li>析构函数与构造函数的作用相反, 当对象生命周期结束的时候,如对象所在函数被调用完毕时,析构函数负责结束对象的生命周期. <strong>注意如果类对象中分配了堆内存一定要在析构函数中进行释放.</strong> </li><li>和拷贝构造函数类似,如果用户未定义析构函数, 编译器<strong>并不是一定</strong>会自动合成析构函数, 只有在<strong>成员变量或则基类</strong>拥有析构函数的情况下它才会自动合成析构函数. </li><li>如果<strong>成员变量或则基类</strong>拥有析构函数, 则编译器一定会合成析构函数, 负责调用成员变量或则基类的析构函数, 此时如果用户提供了析构函数,则编译器会在用户析构函数之后添加上述代码.</li><li>类析构的顺序为: 派生类析构函数, 对象成员析构函数, 基类析构函数. </li></ul><h2 id="21、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#21、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="21、构造函数和析构函数可以调用虚函数吗，为什么"></a>21、构造函数和析构函数可以调用虚函数吗，为什么</h2><ul><li>在C++中，提倡不在构造函数和析构函数中调用虚函数；</li><li>在构造函数和析构函数调用的所有函数(包括虚函数)都是编译时确定的, 虚函数将运行该类中的版本. <ul><li>因为<strong>父类对象会在子类之前进行构造</strong>，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li></ul></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/lidabo/p/9328323.html">C++构造函数和析构函数的调用顺序 - DoubleLi - 博客园</a></li></ul><hr><h2 id="22、构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"><a href="#22、构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？" class="headerlink" title="22、构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"></a>22、构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？</h2><ul><li>构造函数顺序:<ul><li><strong>基类</strong>构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li><li><strong>成员类对象</strong>构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li><li><strong>派生类</strong>构造函数。</li></ul></li><li>析构函数顺序:<ul><li>调用<strong>派生类</strong>的析构函数；</li><li>调用<strong>成员类对象</strong>的析构函数；</li><li>调用<strong>基类</strong>的析构函数。</li></ul></li></ul><h2 id="23、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><a href="#23、虚析构函数的作用，父类的析构函数是否要设置为虚函数？" class="headerlink" title="23、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"></a>23、虚析构函数的作用，父类的析构函数是否要设置为虚函数？</h2><ul><li><code>C++</code>中基类采用<code>virtual </code>虚析构函数是为了防止内存泄漏。<ul><li>如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</li><li>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</li><li>所以，为了防止这种情况的发生，<code>C++</code>中基类的析构函数应采用<code>virtual </code>虚析构函数。    </li></ul></li></ul><hr><ul><li><strong>纯虚析构函数一定得有定义</strong>，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。<strong>因此缺乏任何一个基类析构函数的定义，就会导致链接失败。</strong>==因此，最好不要把虚析构函数定义为纯虚析构函数。==</li></ul><hr><h2 id="24、构造函数-析构函数可以调用虚函数吗？"><a href="#24、构造函数-析构函数可以调用虚函数吗？" class="headerlink" title="24、构造函数``析构函数可以调用虚函数吗？"></a>24、<code>构造函数``析构函数</code>可以调用虚函数吗？</h2><ul><li>在<code>构造函数</code>和<code>析构函数</code>中最好不要调用虚函数；</li><li>在<code>构造函数</code>和<code>析构函数</code>中调用的成员函数都是属于<strong>编译时确定</strong>的,并<strong>不具有虚函数的动态绑定特性</strong>, 有如下原因:<ul><li><strong>在构造时, 父类对象总是先于子类对象构造</strong>的, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的</li><li><strong>在析构时, 子类的析构函数总是先于父类</strong>执行, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的</li></ul></li></ul><hr><ul><li><strong>参考</strong>: <a href="#21%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88">21、构造函数和析构函数可以调用虚函数吗，为什么</a></li></ul><hr><h2 id="25、构造函数-析构函数可否抛出异常"><a href="#25、构造函数-析构函数可否抛出异常" class="headerlink" title="25、构造函数, 析构函数可否抛出异常"></a>25、<code>构造函数</code>, <code>析构函数</code>可否抛出异常</h2><ul><li>构造函数异常<ul><li>后果:<ul><li><strong>(原因):</strong><code>C++</code>拒绝为<strong>没有完成构造函数的对象</strong>调用<strong>析构函数</strong>，原因是避免开销</li><li>构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏</li><li>例如: 在对象<code>b </code>的构造函数中发生异常，对象<code>b </code>的析构函数不会被调用。<strong>因此会造成内存泄漏</strong>。</li></ul></li><li>解决方案:<ul><li>使用<strong>智慧指针</strong>来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏. </li><li><strong>一般建议不要在构造函数里做过多的资源分配。</strong></li></ul></li></ul></li><li>析构函数异常<ul><li>后果:<ul><li>在异常传递的<strong>堆栈辗转开解</strong>的过程中, 如果发生析构异常, <code>C++</code>会调用<code>terminate</code>终止程序</li><li>如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。</li></ul></li><li>解决方法：<ul><li>如果异常不可避免，则应在析构函数内捕获，而不应当抛出。</li><li>在析构函数中使用<code>try-catch</code>块屏蔽所有异常。</li></ul></li><li>附加说明:<ul><li><strong>(后果1):</strong> 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)</li></ul></li></ul></li></ul><hr><ul><li>参考: <ul><li><code>More Effective</code>: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102504097#M9__116">M9 使用析构函数防止资源泄漏</a></li><li><code>More Effective</code>: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102504097#M10__139">M10 在构造函数中防止资源泄漏</a></li><li><code>More Effective</code>: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102504097#M11__destructors__142">M11 禁止异常流出 destructors 之外</a></li></ul></li></ul><hr><h2 id="26、类如何实现只能静态分配和只能动态分配"><a href="#26、类如何实现只能静态分配和只能动态分配" class="headerlink" title="26、类如何实现只能静态分配和只能动态分配"></a>26、类如何实现<code>只能静态分配</code>和<code>只能动态分配</code></h2><ul><li>建立类的对象有两种方式：<ul><li>静态建立(栈空间)<ul><li>静态建立一个类对象，就是由编译器为对象在栈空间中分配内存, 然后调用构造函数初始化这片内存空间.</li><li>使用这种方法，<strong>直接调用类的构造函数</strong>。</li></ul></li><li>动态建立(堆空间)，<code>A *p = new A()</code>; <ul><li>动态建立类对象, 使用new操作符将在堆空间分配内存, 然后调用构造函数初始化这片内存空间.</li><li>这种方法，<strong>间接调用类的构造函数</strong>。</li></ul></li></ul></li><li>只能在堆上建立<ul><li>分析: 类对象只能建立在堆上，就是不能<strong>静态建立类对象</strong>，即不能<strong>直接调用类的构造函数</strong>。</li><li>实现方式: 将<strong>析构函数设为私有或则受保护</strong></li><li>方法分析:<ul><li>静态建立:<ul><li>当对象<code>建立</code>在栈上面时，是由编译器分配内存空间的，调用<code>构造函数</code>来<code>构造</code>栈对象。</li><li>当对象使用<code>完</code>后，编译器会调用<code>析构函数</code>来<code>释放</code>栈对象所占的空间。</li><li>编译器管理了对象的整个生命周期。</li></ul></li><li>编译器在为类对象<strong>分配栈空间</strong>时，会<strong>先检查类的析构函数的访问性</strong>，<ul><li>其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。</li><li>如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。</li><li>因此，将析构函数设为私有，类对象就无法建立在栈上了。</li></ul></li><li>由此引发的问题:<ul><li>因为析构函数设置为了私有</li><li>需要设置一个<code>public函数</code>来调用析构函数</li></ul></li><li>代码如下：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span>  <span class="token class-name">A</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">protected</span> <span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token operator">:</span>    <span class="token keyword">static</span>  A<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>   <span class="token keyword">new</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">void</span>  <span class="token function">destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">delete</span>   <span class="token keyword">this</span> <span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  </code></pre></li></ul></li></ul></li><li>只能在栈上建立<ul><li>只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。<strong>将operator new()设为私有即可</strong>。</li><li><strong>注意: 重载了<code>new</code>就需要重载<code>delete </code></strong></li><li>代码如下：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span>  <span class="token class-name">A</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token operator">:</span>      <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span>  <span class="token keyword">new</span> <span class="token punctuation">(</span> size_t  t<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 注意函数的第一个参数和返回值都是固定的   </span>    <span class="token keyword">void</span>  <span class="token keyword">operator</span>  <span class="token keyword">delete</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 重载了new就需要重载delete   </span><span class="token keyword">public</span> <span class="token operator">:</span>      <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> </code></pre></li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://zhaostu4.github.io/2019/11/28/%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97-%E7%BB%93%E8%AE%BA%E9%9B%86%E5%90%88/#%E5%9C%A8%E5%A0%86%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1">在堆/栈上建立对象</a></li><li><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?</a></li></ul></li></ul><hr><h2 id="27、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#27、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="27、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>27、如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><ul><li>因为在继承体系下, 子类会继承父类的成员, 并且编译器会在子类的构造函数和析构函数中插入父类的构造和析构部分, 因而父类必须有定义. </li></ul><h2 id="28、什么情况会自动生成默认构造函数？"><a href="#28、什么情况会自动生成默认构造函数？" class="headerlink" title="28、什么情况会自动生成默认构造函数？"></a>28、什么情况会自动生成默认构造函数？</h2><ul><li><p>四种情况:</p><ul><li>类成员对象带有默认构造函数.</li><li>基类带有默认构造函数</li><li>类中存在虚函数</li><li>继承体系中存在虚继承</li></ul></li><li><p><strong>在合成的默认构造函数中，只有基类子对象和类类型对象会被初始化</strong>，而其他所有的非静态成员(如整数，指针，数组等)，都不会初始化，对他们进行初始化的应该是程序员，而非编译器。</p></li><li><p>注意：值类型的默认值并不是默认构造的初始化。</p></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/zjc0202/p/4504227.html">C++关于编译器合成的默认构造函数 - Cheny# - 博客园</a></li></ul><hr><h2 id="29、什么是类的继承？"><a href="#29、什么是类的继承？" class="headerlink" title="29、什么是类的继承？"></a>29、什么是类的继承？</h2><ul><li>类与类之间的关系<ul><li><code>(has-A)</code>包含关系，即一个类的成员属性是另一个已经定义好的类</li><li><code>(use-A)</code>使用关系, 一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式实现；</li><li><code>(is-A)</code>继承关系, 继承关系，关系具有传递性；</li></ul></li><li>继承的相关概念<ul><li>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，</li><li>被称为子类或者派生类，被继承的类称为父类或者基类；</li></ul></li><li>继承的特点<ul><li>子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；</li><li>子类可以拥有父类没有的属性和方法；</li></ul></li><li>继承中的访问控制<ul><li><code>public</code>、<code>protected</code>、<code>private</code></li></ul></li><li>继承中的构造和析构函数<ul><li>子类中构造函数的调用顺序为: 基类构造函数, 成员对象构造函数, 派生类构造函数</li><li>子类中析构函数的调用顺序为: 派生类析构函数, 成员对象析构函数, 基类析构函数</li></ul></li><li>继承中的兼容性原则<ul><li>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</li><li>参考: <a href="https://www.cnblogs.com/zhangyaoqi/p/4591571.html">继承中的类型兼容性原则 - Say舞步 - 博客园</a></li></ul></li></ul><h2 id="30、什么是组合？"><a href="#30、什么是组合？" class="headerlink" title="30、什么是组合？"></a>30、什么是组合？</h2><ul><li>一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员；</li><li>如果内嵌类没有零参数构造函数， 则必须使用初始化列表进行初始化</li><li>构造函数的执行顺序：<ul><li>按照内嵌对象成员在组合类中的定义顺序调用内嵌对象的构造函数。</li><li>然后执行组合类构造函数的函数体，析构函数调用顺序相反。</li></ul></li></ul><h2 id="31、抽象基类为什么不能创建对象？"><a href="#31、抽象基类为什么不能创建对象？" class="headerlink" title="31、抽象基类为什么不能创建对象？"></a>31、抽象基类为什么不能创建对象？</h2><ul><li>抽象类的定义：<strong>带有纯虚函数的类</strong>为抽象类。</li><li>抽象类的作用：<ul><li>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</li><li>所以抽象类实际上刻画了一组子类的<strong>操作接口</strong>的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</li></ul></li><li>使用抽象类时注意：<ul><li>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。</li><li>如果<strong>派生类中没有给出所有纯虚函数的实现</strong>，而只是继承基类的纯虚函数，则这个<strong>派生类仍然是一个抽象类</strong>。</li><li>如果<strong>派生类中给出了所有纯虚函数的实现</strong>，则该<strong>派生类就不再是抽象类</strong>了，它是一个可以建立对象的具体的类。</li><li><strong>抽象类是不能定义对象的</strong>。</li></ul></li></ul><hr><ul><li>纯虚函数定义: 纯虚函数是一种特殊的虚函数，它的一般格式如下：<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token operator">&lt;</span>类名<span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token operator">&lt;</span>类型<span class="token operator">></span><span class="token operator">&lt;</span>函数名<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>参数表<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    …<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li><li>纯虚函数引入原因<ul><li>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</li><li>在很多情况下，基类本身生成对象是不合情理的。</li><li>例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</li></ul></li><li>为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数(方法: <code>virtual ReturnType Function()= 0;</code>)。<ul><li>若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。</li><li><strong>同时含有纯虚函数的类称为抽象类</strong>，它不能生成对象。</li></ul></li></ul><hr><ul><li>相似概念<ul><li>多态性<ul><li>指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。</li><li>C++支持两种多态性：编译时多态性，运行时多态性。<ul><li>编译时多态性(静态多态)：通过重载函数实现。</li><li>运行时多态性(动态多态)：通过虚函数实现。</li></ul></li></ul></li><li>虚函数<ul><li>虚函数是在基类中被声明为<code>virtual</code>，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。</li></ul></li><li>抽象类<ul><li>包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</li></ul></li></ul></li></ul><h2 id="32、类什么时候会析构？"><a href="#32、类什么时候会析构？" class="headerlink" title="32、类什么时候会析构？"></a>32、类什么时候会析构？</h2><ul><li>对于静态对象: 当离开作用区域之后, 对象生命周期结束, 编译器会自动调用析构函数</li><li>对于动态对象: 当对对象指针调用delete时, 会调用析构函数终止对象生命周期并释放内存. 其中对象指针指针可以对象类型的指针, 也可以时基类指针(注意基类析构函数位虚函数)</li><li>第三种情况: 当对象中存在嵌入对象时, 该对象析构时, 嵌入对象也会被析构</li></ul><h2 id="33、为什么友元函数必须在类内部声明？"><a href="#33、为什么友元函数必须在类内部声明？" class="headerlink" title="33、为什么友元函数必须在类内部声明？"></a>33、为什么友元函数必须在类内部声明？</h2><ul><li>因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。</li><li>有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。</li></ul><hr><ul><li>编译器通过读取类的声明从而进行类的访问权限控制, 而友元函数有权访问本类的所有成员, 因而它必须在类内部进行声明, 使得编译器可以正确处理他的权限. </li></ul><hr><h2 id="34、介绍一下C-里面的多态？"><a href="#34、介绍一下C-里面的多态？" class="headerlink" title="34、介绍一下C++里面的多态？"></a>34、介绍一下C++里面的多态？</h2><ul><li>静态多态(重载, 模板): 是在编译的时候，就确定调用函数的类型。</li><li>动态多态(覆盖, 虚函数实现): 在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。</li></ul><hr><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81">理解的虚函数和多态</a></li><li>函数重载: <ul><li>同一可访问区域内, 存在多个不同参数列表的同名函数, 由编译器根据调用参数决定那个函数应该被调用</li><li>函数重载不关心返回值类型, 但是对于函数类型时关心的, 例如类中的两个函数拥有相同参数列表的同名函数, 一个为const类型, 一个为非const类型, 依旧时属于函数重载.</li></ul></li><li>函数模板:<ul><li>模板函数会经历两遍编译: <ul><li>(模板编译)在定义模板函数时对模板本身进行编译</li><li>(模板实例化)在调用时对参数进行替换, 对替换参数后的代码进行编译</li></ul></li><li>虽然它和函数重载类似都可以根据参数确定将要调用的函数版本, 但是函数模板只会生成将要用到的函数版本, 而函数模板无论是否调用其代码都会生成.</li></ul></li><li>覆盖: 是指派生类中重新定义了基类中的<code>virtual</code>函数</li><li><strong>隐藏</strong>：是指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同，基类函数都会被隐藏. 不管参数列表是否相同。</li></ul><hr><h2 id="35、用C-语言实现C-的继承"><a href="#35、用C-语言实现C-的继承" class="headerlink" title="35、用C 语言实现C++的继承"></a>35、用C 语言实现C++的继承</h2><ul><li><p>关键点:</p><ul><li><p>使用函数指针保存函数</p></li><li><p>将基类放在结构题的头部, 这样强转的就不会出错了</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//C++中的继承与多态</span><span class="token keyword">struct</span> A<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//C++中的多态:通过虚函数实现</span>      cout<span class="token operator">&lt;&lt;</span><span class="token string">"A:fun()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> B<span class="token operator">:</span><span class="token keyword">public</span> A <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//C++中的继承:B 类公有继承A 类</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//C++中的多态:通过虚函数实现（子类的关键字virtual 可加可不加）</span>      cout<span class="token operator">&lt;&lt;</span><span class="token string">"B:fun()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//C 语言模拟C++的继承与多态</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FUN<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个函数指针来实现对成员函数的继承</span><span class="token keyword">struct</span> _A <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父类</span>  FUN _fun<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由于C 语言中结构体不能包含函数，故只能用函数指针在外面实现</span>  <span class="token keyword">int</span> _a<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> _B <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//子类</span>  _A _a_<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在子类中定义一个基类的对象即可实现对父类的继承</span>  <span class="token keyword">int</span> _b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_fA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父类的同名函数</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"_A:_fun()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_fB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//子类的同名函数</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"_B:_fun()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//测试C++中的继承与多态</span>  A a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个父类对象a</span>  B b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个子类对象b</span>  A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个父类指针指向父类的对象</span>  p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用父类的同名函数</span>  p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//让父类指针指向子类的对象</span>  p1<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用子类的同名函数</span>  <span class="token comment" spellcheck="true">//C 语言模拟继承与多态的测试</span>  _A _a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个父类对象_a</span>  _B _b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个子类对象_b</span>  _a<span class="token punctuation">.</span>_fun <span class="token operator">=</span> _fA<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//父类的对象调用父类的同名函数</span>  _b<span class="token punctuation">.</span>_a_<span class="token punctuation">.</span>_fun <span class="token operator">=</span> _fB<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//子类的对象调用子类的同名函数</span>  _A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>_a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义一个父类指针指向父类的对象</span>  p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用父类的同名函数</span>  p2 <span class="token operator">=</span> <span class="token punctuation">(</span>_A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span>  p2<span class="token operator">-</span><span class="token operator">></span><span class="token function">_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用子类的同名函数</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li></ul><h2 id="36、继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#36、继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="36、继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>36、继承机制中对象之间如何转换？指针和引用之间如何转换？</h2><ul><li><p>派生类的对象可以当做基类对象使用， 例如赋值或则初始化等</p></li><li><p>派生类对象的地址可以赋给指向基类的指针。 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。</p></li><li><p>向上类型转换(派生类转基类, 总是安全的)</p><ul><li>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，<strong>向上类型转换会自动进行</strong>，而且向上类型转换是安全的。</li></ul></li><li><p>向下类型转换(基类转派生类, 不安全)</p><ul><li>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。</li><li><code>RTTI</code>技术，用dynamic_cast进行向下类型转换, 只有存在虚函数的类才能使用<code>RTTI</code></li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://blog.csdn.net/qq_22660775/article/details/88715548">浅谈C++类型转换的安全性 - freshman94的博客 - CSDN博客</a></li><li><a href="https://blog.csdn.net/vjhghjghj/article/details/90677092#%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99">继承的赋值兼容规则</a>update </li></ul></li></ul><hr><h2 id="37、组合与继承优缺点？"><a href="#37、组合与继承优缺点？" class="headerlink" title="37、组合与继承优缺点？"></a>37、组合与继承优缺点？</h2><ul><li>继承: 继承是Is a 的关系，比如说Student 继承Person,则说明Student is a Person。</li><li>继承的优点: 是子类可以重写父类的方法来方便地实现对父类的扩展。</li><li>继承的缺点有以下几点：<ul><li>①：父类的<strong>内部细节</strong>对子类是<strong>可见</strong>的。(可以自己调用父类的方法)</li><li>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</li><li>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</li></ul></li></ul><hr><ul><li>组合(嵌入式对象): 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</li><li>组合的优点：<ul><li>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的<strong>内部细节</strong>对当前对象时<strong>不可见</strong>的。(必须通过嵌入式对象调用嵌入式对象的方法)</li><li>②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</li><li>③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set 方法给所包含对象赋值。</li></ul></li><li>组合的缺点：<ul><li>①：容易产生过多的对象。</li><li>②：为了能组合多个对象，必须仔细对接口进行定义。</li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/u013675978/article/details/82628710">继承的优点和缺点</a></li></ul><hr><h2 id="38、左值右值"><a href="#38、左值右值" class="headerlink" title="38、左值右值"></a>38、左值右值</h2><ul><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102943714#_45">什么是右值引用，跟左值又有什么区别？</a></li></ul><h2 id="39、移动构造函数"><a href="#39、移动构造函数" class="headerlink" title="39、移动构造函数"></a>39、移动构造函数</h2><ul><li>右值的概念: 将亡值, 不具名变量</li><li>右值引用<ul><li>概念: 其本身是一个左值, 但是它绑定了一个右值, 此右值的生命周期将和此右值引用一致.</li><li>优点:<ul><li>转移语意</li><li>精确语意传递(参数列表分别为<strong>左值引用</strong>和<strong>右值引用</strong>形成参数重载)</li></ul></li></ul></li><li>移动构造函数: <ul><li>概念: 当我们使用一个即将消亡的对象A初始化对象B时, 使用移动语意可以避免额外的无意义的复制构造操作, 也避免了释放内存, 新分配内存的开销.  </li><li>实现: <ul><li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。</li><li>也就是说，只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。</li><li><strong>作为参数的右值将不会再调用析构函数。</strong></li><li><code>move</code>语句，就是将一个左值变成一个将亡值。</li></ul></li><li>优点<ul><li>避免了无畏的对下销毁和构造的开销</li><li>当该类对象申请了堆内存, 并在析构函数中进行释放时, 使用拷贝构造函数可能会存产生也野指针, 而使用移动构造可以避免野指针的产生.</li></ul></li></ul></li></ul><h2 id="40、C-语言的编译链接过程？"><a href="#40、C-语言的编译链接过程？" class="headerlink" title="40、C 语言的编译链接过程？"></a>40、C 语言的编译链接过程？</h2><ul><li>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</li><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102990773#_1128">源码到可执行文件的过程</a></li></ul><h2 id="41、vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#41、vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="41、vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>41、<code>vector</code>与<code>list</code>的区别与应用？怎么找某<code>vector</code>或者<code>list</code>的倒数第二个元素</h2><ul><li><code>vector</code><ul><li><code>vector</code>和数组类似，拥有一段连续的内存空间，并且起始地址不变。</li><li>因此能高效的进行随机存取，时间复杂度为<code>o(1)</code>;</li><li>连续存储结构：<ul><li><code>vector</code>是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</li><li>它与数组最大的区别就是<code>vector</code>不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</li></ul></li></ul></li></ul><hr><pre><code>    - 随机访问    - 高效的尾部操作(增/删)    - 不那么高效的非尾部操作(增/删), 后面的迭代器会失效    - 动态扩容, 迁移, 迭代器全部失效</code></pre><ul><li><code>list</code><ul><li><code>list</code>是由双向链表实现的，因此内存空间是不连续的。</li><li>非连续存储结构：<ul><li><code>list </code>是一个双链表结构，支持对链表的双向遍历。</li><li>每个节点包括三个信息：元素本身，指向前一个元素的节点<code>(prev)</code>和指向下一个元素的节点<code>(next)</code>。</li><li>因此<code>list </code>可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</li></ul></li></ul></li></ul><hr><pre><code>    - 高效的插入和删除, 后续迭代器不失效    - 指针维护开销大    - 不支持随机访问</code></pre><ul><li><p>区别：</p><ul><li><code>vector </code>的随机访问效率高，但在插入和删除时(不包括尾部)需要挪动数据，不易操作。</li><li><code>list </code>的访问要遍历整个链表，它的随机访问效率低。</li><li>但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</li><li><code>list </code>是单向的，<code>vector </code>是双向的。<code>vector </code>中的迭代器在使用后就失效了，而<code>list </code>的迭代器在使用之后还可以继续使用。</li></ul></li><li><p><code>int mySize = vec.size()</code>;<code>vec.at(mySize -2);</code></p></li><li><p><code>list</code>不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问<code>list</code>里的元素只能遍历，</p></li><li><p>不过你要是只需要访问<code>list </code>的最后<code>N </code>个元素的话，可以用<strong>反向迭代器</strong>来遍历：</p></li></ul><h2 id="42、STL-vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#42、STL-vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="42、STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>42、<code>STL vector</code>的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</h2><ul><li>vector相关函数:<ul><li><code>size / capacity</code>: 已用空间 / 总空间</li><li><code>resize / reserve</code>: 改变容器的元素数目 / 概念容器的空间大小</li><li><code>push_back / pop_back</code>: 尾插 / 尾减</li><li><code>insert / erase</code>: 任意位置插入 / 任意位置删除</li></ul></li><li>迭代器失效问题:<ul><li>在<code>capacity</code>内<code>insert</code>和<code>erase</code>都会导致在后续元素发生移动, 进而迭代器失效或则改变</li><li>如果<code>insert</code>或则<code>push_back</code>导致空间不足, 则会发生整体的移动操作, 所有迭代器都将失效.</li></ul></li><li>两倍扩容问题:<ul><li>为什么呈倍数扩容(时间复杂度更优)<ul><li>对于<code>n</code>次插入操作, 采用成倍方式扩容可以保证时间复杂度<code>O(n)</code>, 而指定大小扩容的时间复杂度为<code>O(n^2)</code></li></ul></li><li>为什么是<code>1.5</code>倍扩容(空间可重用)<ul><li>当<code>k == 2</code>时:<ul><li>第n次扩容的时候需要分配的内存是：<code>an = a1*q^(n-1) = 4*2^(n-1)</code></li><li>而前n-1项的内存和为：<code>Sn = a1*(1-q^(n-1))/(1-q) = 4*(1-2^(n-1)) /(1-2) = 4*2^(n-1)-4</code></li><li><code>差值 = an - Sn = 4 &gt; 0</code></li><li>所以第<code>n</code>次扩容需要的空间恰好比前<code>n-1</code>扩容要求的空间总和要大，那么即使在前<code>n-1</code>次分配空间都是连续排列的最好情况下，也无法实现之前的内存空间重用</li></ul></li><li>当<code>k = 1.5</code>时:<ul><li>第<code>n</code>次扩容的时候需要分配的内存是：<code>an = a1*q^(n-1) = 4*1.5^(n-1)</code></li><li>而前<code>n-1</code>项的内存和为：<code>Sn = a1*(1-q^(n-1))/(1-q) = 4*(1-1.5^(n-1)) /(1-1.5) = 8*1.5^(n-1)-8</code></li><li><code>差值 = an - Sn = 8 - 4*1.5^(n-1)</code></li><li>当<code>n</code>增长到一定的数值后，差值就会变为小于<code>0</code>，那么如果前<code>n-1</code>次分配的空间都是连续的情况下, 就可以实现内存空间复用</li></ul></li></ul></li></ul></li><li>释放空间:<ul><li>使用<code>swap</code>: <code>vector&lt;int&gt;().swap(a);</code></li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://blog.csdn.net/bryant_xw/article/details/89524910">STL中vector 扩容为什么要以1.5倍或者2倍扩容？ - Bryant_xw Is Growing~~ - CSDN博客</a></li><li><a href="https://www.zhihu.com/question/36538542/answer/67929747">C++ STL中vector内存用尽后，为啥每次是两倍的增长，而不是3倍或其他数值？ - 知乎</a></li></ul></li></ul><hr><h2 id="43、容器内部删除一个元素"><a href="#43、容器内部删除一个元素" class="headerlink" title="43、容器内部删除一个元素"></a>43、容器内部删除一个元素</h2><ul><li>顺序容器<ul><li><code>erase 迭代器</code>不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(<code>list除外</code>)，所以不能使用<code>erase(it++)</code>的方式，但是<code>erase</code>的返回值是下一个有效迭代器；</li><li><code>it = c.erase(it);</code></li></ul></li><li>关联容器<ul><li><code>erase 迭代器</code>只使被删除元素的迭代器失效, 其他迭代器不失效，但是返回值是<code>void</code>，所以要采用<code>erase(it++)</code>的方式删除迭代器；</li><li><code>c.erase(it++)</code></li></ul></li></ul><h2 id="44、STL-迭代器如何实现"><a href="#44、STL-迭代器如何实现" class="headerlink" title="44、STL 迭代器如何实现"></a>44、<code>STL</code> 迭代器如何实现</h2><ul><li><p>迭代器<code>Iterator</code></p><ul><li>(总结)<code>Iterator</code>使用聚合对象, 使得我们在不知道对象内部表示的情况下, 按照一定顺序访问聚合对象的各个元素.</li><li><code>Iterator</code>模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</li><li>由于<code>Iterator</code>模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如<code>STL</code>的<code>list</code>、<code>vector</code>、<code>stack</code>等容器类及<code>ostream_iterator</code>等扩展<code>iterator</code>。</li></ul></li><li><p>迭代器的基本思想:</p><ul><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，<code>-&gt;</code>、<code>*</code>、<code>++</code>、<code>--</code>等。</li><li>迭代器封装了指针，是一个“可遍历<code>STL( Standard Template Library)</code>容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升<code>(lift)</code>，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的<code>++</code>，<code>--</code>等操作。</li><li>迭代器返回的是对象引用而不是对象的值。</li></ul></li><li><p>迭代器产生原因</p><ul><li><code>Iterator</code>类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构就可以实现集合的遍历,是算法和容器之间的桥梁.</li></ul></li><li><p>最常用的迭代器的相应型别有五种：<code>value type</code>、<code>difference type</code>、<code>pointer</code>、<code>reference</code>、<code>iterator catagoly</code>;</p></li></ul><h2 id="45、set-与hash-set-的区别"><a href="#45、set-与hash-set-的区别" class="headerlink" title="45、set 与hash_set 的区别"></a>45、<code>set </code>与<code>hash_set </code>的区别</h2><ul><li><code>set </code>底层是以<code>RB-Tree </code>实现，<code>hash_set </code>底层是以<code>hash_table </code>实现的；</li><li><code>RB-Tree </code>有自动排序功能，而<code>hash_table </code>不具有自动排序功能；</li><li><code>set </code>和<code>hash_set </code>元素的键值就是实值；</li><li><code>hash_table </code>有一些无法处理的型别；(例如字符串无法对<code>hashtable</code>的大小进行取模)</li></ul><h2 id="46、hashmap-与map-的区别"><a href="#46、hashmap-与map-的区别" class="headerlink" title="46、hashmap 与map 的区别"></a>46、<code>hashmap </code>与<code>map </code>的区别</h2><ul><li>底层实现不同；</li><li><code>map</code>具有自动排序的功能，<code>hash_map</code>不具有自动排序的功能；</li><li><code>hashtable</code>有一些无法处理的型别；(例如字符串无法对<code>hashtable</code>的大小进行取模)</li></ul><h2 id="47、map、set-是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#47、map、set-是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="47、map、set 是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>47、<code>map</code>、<code>set </code>是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h2><ul><li><code>map</code>和<code>set</code>都是<code>STL</code>中的关联容器，其底层实现都是红黑树(<code>RB-Tree</code>)。由于 <code>map</code> 和<code>set</code>所开放的各种操作接口，<code>RB-tree</code> 也都提供了，所以几乎所有的<code>map</code>和<code>set</code>的操作行为，都只是转调<code>RB-tree</code>的操作行为。</li><li><code>map</code>中的元素是<code>key-value(关键字—值)对</code>：关键字起到索引的作用，值则表示与索引相关联的数据， 红黑树的每个节点包括<code>key</code>和<code>value</code>；</li><li><code>set</code>只是关键字的简单集合，它的每个元素只包含一个<code>关键字</code>， 红黑树每个节点只包括<code>key</code>。</li><li>红黑树的插入删除都可以在<code>O(logn)</code>时间内完成, 性能优越</li></ul><h2 id="48、如何在共享内存上使用STL标准库？"><a href="#48、如何在共享内存上使用STL标准库？" class="headerlink" title="48、如何在共享内存上使用STL标准库？"></a>48、如何在共享内存上使用STL标准库？</h2><ul><li>为什么要在共享内存中使用模板容器？<ul><li>共享内存可以在多进程间共享，到达进程间通信的方式。</li><li>共享内存可以在进程的生命周期以外仍然存在。这就可以保证在短暂停止服务(服务进程<code>coredump</code>，更新变更)后，服务进程仍然可以继续使用这些共享内存的数据。</li><li>如果这些优势在加上<code>C++</code>容器模板使用方便，开发快速的优势，无疑是双剑合璧，成为服务器开发的利刃。</li></ul></li></ul><hr><p><strong>………..太难了……….</strong></p><ul><li>参考: <a href="https://blog.csdn.net/fullsail/article/details/8540078">C++容器模板在共享内存中的使用</a></li></ul><hr><h2 id="49、map插入方式有几种？"><a href="#49、map插入方式有几种？" class="headerlink" title="49、map插入方式有几种？"></a>49、<code>map</code>插入方式有几种？</h2><ul><li>下表运算符插入<code>[]</code></li><li><code>insert</code>插入<code>pair</code></li></ul><h2 id="50、STL-中unordered-map和map的区别，unordered-map如何解决冲突以及扩容"><a href="#50、STL-中unordered-map和map的区别，unordered-map如何解决冲突以及扩容" class="headerlink" title="50、STL 中unordered_map和map的区别，unordered_map如何解决冲突以及扩容"></a>50、STL 中<code>unordered_map</code>和<code>map</code>的区别，<code>unordered_map</code>如何解决冲突以及扩容</h2><ul><li><p><code>unordered_map </code>和<code>map</code>都是键值对不可重复的关联容器, </p></li><li><p>区别:</p><ul><li><code>map</code>的底层实现为红黑树, 会根据键值进行排序, 所以键值需要定义小于操作<code>(operator&lt;)</code></li><li><code>unordered_map</code>底层实现为<code>hash_table</code>, 不会根据键值进行排序, 但是需要键值提供等于操作<code>(operator ==)</code>, 以防止重复键值</li></ul></li><li><p>哈希表解决冲突常见办法:</p><ul><li>开放定址法: 线性探测, 二次探测, 二次哈希</li><li><strong>(STL使用):</strong> 拉链法: 使用单链表来保存具有相同哈希值得集合</li></ul></li><li><p>哈希表扩容</p><ul><li>什么时候扩容: 哈希表键值发生碰撞的概率, 随着负载因子(负载/容量)的增加而增加, 所以当负载因子大于阈值(0.75)的时候就需要扩容了.</li><li>怎么扩容<code>(resize)</code>: 通过增加桶的数量(两倍扩张)以达到扩容的目的, 然后将原来的所有键值<code>rehash</code>到新的哈希表中, 增大哈希表并不会影响哈希表的插入删除时间,  那是<code>rehash</code>需要的时间复杂度为<code>n</code>, 所以对实时性非常严格的情况下不要使用</li></ul></li></ul><hr><ul><li>参考:     <ul><li><a href="https://blog.csdn.net/chenhanzhun/article/details/38091431">数据结构——哈希表(散列表)</a></li><li><a href="https://blog.csdn.net/qq_22238021/article/details/78258605">散列表(哈希表)(散列函数构造、处理冲突、查找)</a></li><li><a href="https://www.cnblogs.com/downey-blog/p/10471875.html">C++ STL hash表用法</a></li><li><a href="https://www.cnblogs.com/yyxt/p/4985894.html">hashtable详解</a></li><li>扩容:<ul><li><a href="http://zheming.wang/blog/2014/06/17/05E21D24-A791-4D97-993D-98B7E6C88BC2/">Hash table详解</a></li><li><a href="http://www.algolist.net/Data_structures/Hash_table/Dynamic_resizing">HASH TABLE::DYNAMIC RESIZING (Java, C++)</a><ul><li><a href="https://zrj.me/archives/1248">对 c++ unordered_map 源码的解析 | ZRJ</a></li></ul></li></ul></li></ul></li></ul><hr><h2 id="51、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#51、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="51、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>51、<code>vector</code>越界访问下标，<code>map</code>越界访问下标？<code>vector</code>删除元素时会不会释放空间？</h2><ul><li><p><code>vector </code>通过下标访问时不会做边界检查，即便下标越界。</p><ul><li>也就是说，下标与<code>first </code>迭代器相加的结果超过了<code>finish </code>迭代器的位置，程序也不会报错，而是返回这个地址中存储的值。</li><li>如果想在访问<code>vector </code>中的元素时首先进行边界检查，可以使用<code>vector </code>中的<code>at </code>函数。</li><li>通过使用<code>at </code>函数不但可以通过下标访问<code>vector </code>中的元素，而且在<code>at </code>函数内部会对下标进行边界检查。</li></ul><hr><ul><li><strong>我去是真的</strong>: <a href="https://blog.csdn.net/zrh_CSDN/article/details/80959258">访问vector元素时的越界问题</a></li></ul><hr></li><li><p><code>map</code>通过校表访问会将不存在的<code>key</code>插入到<code>map</code>中</p></li><li><p><code>map </code>的下标运算符<code>[]</code>的作用是：将<code>key </code>作为下标去执行查找，并返回相应的值；如果不存在这个<code>key</code>，就将一个具有该<code>key </code>和<code>value </code>的某人值插入这个<code>map</code>。</p></li><li><p><code>erase()</code>函数，只能删除内容，不能改变容量大小;<code>erase</code>成员函数，它删除了<code>itVect</code>迭代器指向的元素，并且返回要被删除的<code>itVect </code>之后的迭代器，迭代器相当于一个智能指针;<code>clear()</code>函数，只能清空内容，不能改变容量大小;</p><hr><ul><li>如果要想在删除内容的同时释放内存，那么你可以选择<code>deque</code>容器。(<code>deque</code>也不总是<code>erase</code>之后就会释放内存， 当内存块不在被使用时会释放)</li><li>参考： <a href="https://blog.csdn.net/weixin_30247159/article/details/97269861">STL容器删除元素时内存释放情况</a></li></ul><hr></li></ul><h2 id="52、map-与find的区别？"><a href="#52、map-与find的区别？" class="headerlink" title="52、map[]与find的区别？"></a>52、<code>map[]</code>与<code>find</code>的区别？</h2><ol><li>map 的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项<strong>插入</strong>这个map。</li><li>map 的find 函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</li></ol><h2 id="53、STL-中list-queue之间的区别"><a href="#53、STL-中list-queue之间的区别" class="headerlink" title="53、STL 中list, queue之间的区别"></a>53、STL 中<code>list</code>, <code>queue</code>之间的区别</h2><ul><li><code>vector</code>: 连续空间存储, 支持随机访问, 高效尾部操作(增/删), 动态空间分配, 迭代器易失效</li><li><code>list</code>: 双向链表, 不支持随机访问(可以反向迭代), 任意位置操作(增/删)高效, 插入时分配空间, 迭代器不易失效</li><li><code>deque</code>: 双向开口的分段连续线性空间，可以在头尾端进行元素的插入和删除, 允许于常数时间内对头端进行插入或删除元素；可以增加一段新的空间, 不过迭代器设置复杂. </li><li><code>queue</code>: 先进先出队列, 默认基于<code>deque</code>容器, 可以对两端进行操作，但是只能在队列头部进行移除元素，只能在队列尾部新增元素，可以访问队列尾部和头部的元素，但是不能遍历容器</li></ul><hr><ul><li><code>deque</code>和<code>vector</code>的差异<ul><li><code>deque</code>允许于常数时间内对头端进行插入或删除元素；</li><li><code>deque</code>没有空间包括, 当空间不足时, <code>deque</code>可以增加一段新的空间, 而不用进行整体迁移</li><li><code>vector</code>的迭代器是对指针的封装, <code>deque</code>的迭代器相对复杂</li></ul></li><li><code>list</code>和<code>vector</code>的差异<ul><li><code>vector</code>空间是预先分配的, <code>list</code>是插入时分配的</li><li><code>vector</code>是连续数组, 增删操作都可能会造成内存迁移, 后续迭代器失效, <code>list</code>是双向链表, 增删操作都可以在常数时间内完成, 迭代器不会失效</li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://blog.csdn.net/chenhanzhun/article/details/39430973">STL源码剖析——序列容器之deque</a></li><li><a href="http://c.biancheng.net/view/351.html">C++ list，STL list(双向链表)详解</a></li><li><a href="https://blog.csdn.net/chenhanzhun/article/details/39430973">STL源码剖析——序列容器之deque</a></li></ul></li></ul><hr><h2 id="54、STL-中的allocator-deallocator"><a href="#54、STL-中的allocator-deallocator" class="headerlink" title="54、STL 中的allocator,deallocator"></a>54、STL 中的allocator,deallocator</h2><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c-stl-%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96">C++ STL 的内存优化</a></li></ul><h2 id="55、STL-中hash-map-扩容发生什么？"><a href="#55、STL-中hash-map-扩容发生什么？" class="headerlink" title="55、STL 中hash_map 扩容发生什么？"></a>55、STL 中hash_map 扩容发生什么？</h2><ol><li><p><code>hash table</code>表格内的元素称为桶<code>(bucket)</code>,而由桶所链接的元素称为节点<code>(node)</code>,其中存入桶元素的容器为<code>STL</code>本身很重要的一种序列式容器——<code>vector </code>容器。之所以选择<code>vector </code>为存放桶元素的基础容器，主要是因为<code>vector </code>容器本身具有动态扩容能力，<br>无需人工干预。</p></li><li><p>向前操作：首先尝试从目前所指的节点出发，前进一个位置(节点)，由于节点被安置于<code>list </code>内，所以利用节点的<code>next </code>指针即可轻易完成前进操作，如果目前正巧是<code>list </code>的尾端，就跳至下一个<code>bucket </code>身上，那正是指向下一个<code>list </code>的头部节点。</p></li></ol><hr><ul><li><code>hash table</code>表格内的元素称为桶<code>(bucket)</code>,而由桶所链接的元素称为节点<code>(node)</code>, 由线性表来储存所有的桶, 其底层实现为<code>vector</code>, 因为它支持随机访问, 和动态扩容</li><li>哈表表键值发生碰撞的概率和负载因子正相关, 当负载因子过大, 哈希表的性能显著降低, 一般负载因子大于阈值(0.75)则对哈希表进行扩容, 然后通过rehash对所有节点进行重映射, 注意扩容并不会增加哈希表插入删除的复杂度, 但是rehash本身的的时间复杂度为n, 所以对高时效性的需求下, 要注意.</li><li>参考: <ul><li><a href="https://zrj.me/archives/1248">对 c++ unordered_map 源码的解析 | ZRJ</a><ul><li><a href="http://zheming.wang/blog/2014/06/17/05E21D24-A791-4D97-993D-98B7E6C88BC2/">Hash table详解</a></li></ul></li><li><a href="http://www.algolist.net/Data_structures/Hash_table/Dynamic_resizing">HASH TABLE::DYNAMIC RESIZING (Java, C++)</a></li><li><a href="https://zrj.me/archives/1248">对 c++ unordered_map 源码的解析 | ZRJ</a></li></ul></li></ul><hr><h2 id="56、map-如何创建？"><a href="#56、map-如何创建？" class="headerlink" title="56、map 如何创建？"></a>56、map 如何创建？</h2><ul><li><code>vector </code>底层数据结构为数组，支持快速随机访问</li><li><code>list </code>底层数据结构为双向链表，支持快速增删</li><li><code>deque </code>底层数据结构为一个中央控制器和多个缓冲区，详细见<code>STL </code>源码剖析<code>P146</code>，支持首尾(中间不能)快速增删，也支持随机访问,<code>deque</code>是一个双端队列<code>(double-ended queue)</code>，也是在堆中保存内容的.它的保存形式<br>如下:<code>[堆1] --&gt; [堆2] --&gt;[堆3] --&gt; ...</code>, 每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list 和vector 的结合品.</li><li><code>stack </code>底层一般用<code>list </code>或<code>deque </code>实现，封闭头部即可，不用<code>vector </code>的原因应该是容量大小有限制，扩容耗时</li><li><code>queue </code>底层一般用<code>list </code>或<code>deque </code>实现，封闭头部即可，不用<code>vector </code>的原因应该是容量大小有限制，扩容耗时<code>(stack </code>和<code>queue </code>其实是适配器,而不叫容器，因为是对容器的再封装)</li><li><code>priority_queue </code>的底层数据结构一般为<code>vector </code>为底层容器，堆<code>heap </code>为处理规则来管理底层容器实现</li><li><code>set </code>底层数据结构为红黑树，有序，不重复</li><li><code>multiset </code>底层数据结构为红黑树，有序，可重复</li><li><code>map </code>底层数据结构为红黑树，有序，不重复</li><li><code>multimap </code>底层数据结构为红黑树，有序，可重复</li><li><code>hash_set </code>底层数据结构为<code>hash </code>表，无序，不重复</li><li><code>hash_multiset </code>底层数据结构为<code>hash </code>表，无序，可重复</li><li><code>hash_map </code>底层数据结构为<code>hash </code>表，无序，不重复</li><li><code>hash_multimap </code>底层数据结构为<code>hash </code>表，无序，可重复</li></ul><hr><ul><li><p>红黑树的性质：</p><ul><li>每个节点或是红色的，或是黑色的。</li><li>根节点是黑色的。</li><li>每个叶节点<code>(NULL)</code>是黑色的。</li><li>如果一个节点是红色的，则它的两个孩子节点都是黑色的。</li><li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</li></ul></li><li><p><a href="https://blog.csdn.net/chenhanzhun/article/details/38405041">数据结构——红黑树(RB-Tree)</a></p></li></ul><hr><h2 id="57、vector-的增加删除都是怎么做的？为什么是1-5-倍？"><a href="#57、vector-的增加删除都是怎么做的？为什么是1-5-倍？" class="headerlink" title="57、vector 的增加删除都是怎么做的？为什么是1.5 倍？"></a>57、vector 的增加删除都是怎么做的？为什么是1.5 倍？</h2><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80%E5%86%8D%E6%8E%A2/#42stl-vector%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%A0%E9%99%A4%E5%85%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E5%80%8D%E6%89%A9%E5%AE%B9%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4">42、STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</a></li></ul><hr><ol><li><p>新增元素：vector 通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p></li><li><p>对vector 的任何操作，一旦引起空间重新配置，指向原vector 的所有迭代器就都失效了；</p></li><li><p>初始时刻vector 的capacity 为0，塞入第一个元素后capacity 增加为1；</p></li><li><p>不同的编译器实现的扩容方式不一样，VS2015 中以1.5 倍扩容，GCC 以2 倍扩容。对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p><ol><li>考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2 二倍的方式扩容，或者以1.5 倍的方式扩容。</li><li>以2 倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：</li></ol></li><li><p>向量容器vector 的成员函数pop_back()可以删除最后一个元素.</p></li><li><p>而函数erase()可以删除由一个iterator 指出的元素，也可以删除一个指定范围的元素。</p></li><li><p>还可以采用通用算法remove()来删除vector 容器中的元素.</p></li><li><p>不同的是：采用remove 一般情况下不会改变容器的大小，而pop_back()与erase()</p></li></ol><h2 id="58、函数指针？"><a href="#58、函数指针？" class="headerlink" title="58、函数指针？"></a>58、函数指针？</h2><ul><li>什么是函数指针?<ul><li>函数指针本质是一个指针, 它指向的是函数的入口地址, 它的类型是由函数的参数列表和返回值共同确定.</li></ul></li><li>函数指针的声明方法<ul><li><code>int (*pf)(const int&amp;, const int&amp;); (1)</code></li><li><code>pf</code>是一个返回类型为int, 参数为两个const int&amp;的函数。*<em>注意</em>pf 两边的括号是必须的**<ul><li>否则上面的定义就变成了：</li><li><code>int *pf(const int&amp;, const int&amp;); // 这声明了一个函数pf, 其返回类型为int *, 带有两个const int&amp;参数. </code></li></ul></li></ul></li><li>为什么有函数指针<ul><li>可以通过函数指针进行函数调用</li><li>而且函数指针本质是一个指针, 可以把它指向返回值类型和形参列表相同的不同函数</li><li>另外还能将函数指针作为函数参数进行传递. </li><li>通过函数指针可以把函数的调用者与被调函数分开。<ul><li>调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数,</li><li>而不需要知道具体是哪个函数被调用.</li></ul></li></ul></li><li>两种方法赋值：<ul><li><code>指针名 = 函数名</code></li><li><code>指针名 = &amp;函数名</code></li></ul></li></ul><h2 id="59、说说你对c-和c-的看法，c-和c-的区别？"><a href="#59、说说你对c-和c-的看法，c-和c-的区别？" class="headerlink" title="59、说说你对c 和c++的看法，c 和c++的区别？"></a>59、说说你对c 和c++的看法，c 和c++的区别？</h2><ul><li>面向过程 / 面向对象</li><li>C中的函数编译时不会保留形参列表, 也不能重载; 而C++中的函数在编译时会保留形参列表, 有重载</li><li>struct<ul><li>C中: struct是自定义数据类型; 是变量的集合, 不能添加拥有成员函数; 没有访问权限控制的概念; 结构体名称不能作为参数类型使用, 必须在其前加上struct才能作为参数类型</li><li>C++中: struct是抽象数据类型, 是一个特殊的类, 可以有成员函数, 默认访问权限和继承权限都是public, 结构体名可以作为参数类型使用</li></ul></li><li>动态管理内存的方法不一样: <code>malloc/free</code> 和 <code>new/delete</code></li><li>C语言没有引用的概念, 更没有左值引用, 右值引用</li><li>C语言不允许只读数据(const修饰)用作下标定义数组, C++允许</li><li>C语言的局部静态变量初始化发生于编译时，所以在函数中不能使用变量对局部静态变量进行初始化， 而C++因为增加了对象的概念，而对象需要调用构造函数进行初始化，所以编译器将局部静态变量的初始化推迟至该变量使用之前，也就是说可以使用变量来初始化局部静态变量。</li><li>C++相比C，增加多许多类型安全的功能，比如强制类型转换</li><li>C++支持范式编程，比如模板类、函数模板等</li></ul><hr><ul><li><code>PS:</code>C/C++的全局变量默认连接属性都是<code>extern</code>的啊, 参考:<a href="https://blog.csdn.net/sinat_27706697/article/details/47679329">C语言：链接属性与存储类型</a></li><li>参考: <ul><li><a href="https://blog.csdn.net/sinat_27706697/article/details/47679329">C语言：链接属性与存储类型</a></li><li><a href="https://blog.csdn.net/weixin_43054397/article/details/90417740">为什么用C语言中const常量定义数组大小会报错？</a></li><li><a href="https://blog.csdn.net/zzxiaozhao/article/details/103188945#15_C_struct_C_struct__228">15、C 语言struct 和C++ struct 区别</a></li></ul></li></ul><hr><h2 id="60、c-c-的内存分配，详细说一下栈、堆、静态存储区？"><a href="#60、c-c-的内存分配，详细说一下栈、堆、静态存储区？" class="headerlink" title="60、c/c++的内存分配，详细说一下栈、堆、静态存储区？"></a>60、c/c++的内存分配，详细说一下栈、堆、静态存储区？</h2><ul><li>栈区<code>(stack)</code>— 由编译器自动分配释放，存放函数的参数值，局部变量的值等其操作方式类似于数据结构中的栈。</li><li>堆区<code>(heap) </code>— 一般由程序员分配释放，若程序员不释放，程序结束时可能由<code>OS</code>(操作系统)回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局区(静态区)<code>(static)</code>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li><li>文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。</li><li>程序代码区—存放函数体的二进制代码。</li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102943714#CC_116">C++/C的内存分配</a></li></ul><hr><h2 id="61、堆与栈的区别？"><a href="#61、堆与栈的区别？" class="headerlink" title="61、堆与栈的区别？"></a>61、堆与栈的区别？</h2><ul><li>管理方式: 栈由编译器自动管理，无需我们手工控制；堆需要手动释放不再使用的堆空间<code>memory leak</code>。</li><li>空间大小: <ul><li><code>32</code>位系统下, 堆内存可以达到<code>4G</code>(<code>3G</code>用户空间, <code>1G</code>内核空间). </li><li>栈空间是受限的, 默认大小为<code>1M</code></li></ul></li><li>碎片问题：<ul><li>对于堆来说，频繁的<code>new/delete</code> 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。</li><li>对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出</li></ul></li><li>生长方向：<ul><li>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；</li><li>对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</li></ul></li><li>分配方式：<ul><li>堆都是动态分配的，没有静态分配的堆。</li><li>栈有2种分配方式：静态分配和动态分配。<ul><li>静态分配是编译器完成的，比如局部变量的分配。</li><li>动态分配由<a href="(https://baike.baidu.com/item/alloca/7621487?fr=aladdin)">alloca</a>函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。</li></ul></li></ul></li><li>分配效率：<ul><li>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</li><li>堆则是<code>C/C++</code>函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法(具体的算法可以参考数据结构<code>/</code>操作系统)在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</li></ul></li></ul><hr><ul><li>参考: 动态栈: <a href="https://baike.baidu.com/item/alloca/7621487?fr=aladdin">alloca_百度百科</a></li></ul><h2 id="62、野指针是什么？如何检测内存泄漏？"><a href="#62、野指针是什么？如何检测内存泄漏？" class="headerlink" title="62、野指针是什么？如何检测内存泄漏？"></a>62、野指针是什么？如何检测内存泄漏？</h2><ul><li>野指针：指向内存被释放的内存或者没有访问权限的内存的指针。</li><li>“野指针”的成因主要有<code>3</code> 种：<ul><li><strong>指针变量没有被初始化</strong>。任何指针变量刚被创建时不会自动成为<code>NULL</code> 指针，它的缺省值是随机的。</li><li><strong>指针被<code>free</code></strong> 或者<code>delete</code> 之后，没有置为<code>NULL</code>；</li><li><strong>指针操作超越了变量的作用范围</strong>。</li></ul></li><li>如何避免野指针：<ul><li>对指针进行初始化, 或指向有效地址空间</li><li>指针用完后释放内存，将指针赋<code>NULL</code>。<ul><li><code>char * p = NULL;</code></li><li><code>char * p = (char * )malloc(sizeof(char));</code></li><li><code>char num[ 30] = &#123;0&#125;; char *p = num;</code></li><li><code>delete(p); p = NULL;</code></li></ul></li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/bqxdrs012/article/details/78531357">野指针和悬空指针</a></li></ul><hr><h2 id="63、悬空指针和野指针有什么区别？"><a href="#63、悬空指针和野指针有什么区别？" class="headerlink" title="63、悬空指针和野指针有什么区别？"></a>63、悬空指针和野指针有什么区别？</h2><ul><li>野指针：野指针指，访问一个已删除或访问受限的内存区域的指针，野指针不能判断是否为<code>NULL</code> 来避免。指针没有初始化，释放后没有置空，越界</li><li>悬空指针：一个指针的指向对象已被删除，那么就成了悬空指针。野指针是那些未初始化的指针。</li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/bqxdrs012/article/details/78531357">野指针和悬空指针</a></li></ul><hr><h2 id="64、内存泄漏"><a href="#64、内存泄漏" class="headerlink" title="64、内存泄漏"></a>64、内存泄漏</h2><ul><li><p>内存泄漏</p><ul><li>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</li><li>内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制, 导致此段内存不能被使用；</li></ul></li><li><p>后果</p><ul><li>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：<strong>性能下降到内存逐渐用完，导致另一个程序失败；</strong></li></ul></li><li><p>如何排除</p><ul><li>使用工具软件<code>BoundsChecker</code>，<code>BoundsChecker</code> 是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；调试运行<code>DEBUG</code> 版程序，运用以下技术：<code>CRT(C run-time libraries)</code>、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境<code>OUTPUT</code> 窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul></li><li><p>解决方法</p><ul><li>智能指针。</li></ul></li><li><p>检查、定位内存泄漏</p><ul><li>检查方法：在<code>main</code> 函数最后面一行，加上一句<code>_CrtDumpMemoryLeaks()</code>。调试程序，自然关闭程序让其退出，查看输出：输出这样的格式<code>&#123;453&#125;</code> <code>normal block at 0x02432CA8</code>,<code>868 bytes long</code>被<code>&#123;&#125;</code>包围的<code>453</code> 就是我们需要的内存泄漏定位值，<code>868 bytes long</code> 就是说这个地方有<code>868</code> 比特内存没有释放。</li></ul></li><li><p>定位代码位置</p><ul><li>在<code>main</code> 函数第一行加上<code>_CrtSetBreakAlloc(453);</code>意思就是在申请<code>453</code> 这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件<code>#include &lt;crtdbg.h&gt;</code></li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://www.cnblogs.com/hrhguanli/p/3890171.html">BoundsChecker使用</a></li><li><a href="https://www.cnblogs.com/jianqiang2010/archive/2010/12/02/1894327.html">(转)内存管理：_CrtDumpMemoryLeaks和_CrtSetBreakAlloc</a></li><li><a href="https://blog.csdn.net/fanyun_01/article/details/65938998">Linux 内存泄露检查工具valgrind简析</a></li></ul></li></ul><hr><h2 id="65、new和malloc的区别？"><a href="#65、new和malloc的区别？" class="headerlink" title="65、new和malloc的区别？"></a>65、<code>new</code>和<code>malloc</code>的区别？</h2><ul><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102604626#mallocnew_430">malloc和new的区别</a></li></ul><h2 id="66、delete-p-与delete-p，allocator"><a href="#66、delete-p-与delete-p，allocator" class="headerlink" title="66、delete p;与delete[]p，allocator"></a>66、<code>delete p</code>;与<code>delete[]p</code>，<code>allocator</code></h2><ul><li><p>动态数组管理<code>new</code>一个数组时，<code>[]</code>中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p></li><li><p><code>new</code> 动态数组返回的并不是数组类型，而是一个元素类型的指针；</p></li><li><p><code>delete[]</code>时，数组中的元素按逆序的顺序进行销毁；</p></li><li><p><code>new</code> 在内存分配上面有一些局限性，<code>new</code> 的机制是将内存分配和对象构造组合在一起，同样的，<code>delete</code> 也是将对象析构和内存释放组合在一起的。</p></li><li><p><code>allocator</code> 将这两部分分开进行，<code>allocator</code> 申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p></li><li><p>参考下一个问题:  <a href="#67new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86delete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%A2%9D">67、new和delete的实现原理，delete是如何知道释放内存的大小的额？</a></p></li></ul><h2 id="67、new和delete的实现原理，delete是如何知道释放内存的大小的额？"><a href="#67、new和delete的实现原理，delete是如何知道释放内存的大小的额？" class="headerlink" title="67、new和delete的实现原理，delete是如何知道释放内存的大小的额？"></a>67、<code>new</code>和<code>delete</code>的实现原理，<code>delete</code>是如何知道释放内存的大小的额？</h2><ul><li><code>new</code> <ul><li>简单类型直接调用<code>operator new</code> 分配内存；</li><li>对于复杂结构，先调用<code>operator new</code> 分配内存，然后在分配的内存上调用构造函数；</li></ul></li><li><code>delete</code> <ul><li>简单数据类型默认只是调用<code>free</code> 函数；</li><li>复杂数据类型先调用析构函数再调用<code>operator delete</code>；</li></ul></li></ul><hr><ul><li><code>new[]</code><ul><li>对于简单类型，<code>new[]</code>计算好大小后调用<code>operator new</code>；</li><li>对于复杂数据结构<ul><li><code>AA* P = new AA[10];</code></li><li><code>new[]</code>先调用<code>operator new[]</code>分配内存, <strong>分配内存时多分配四个字节用于存放元素个数.</strong>, 返回地址为<code>p</code></li><li><code>p</code>的最开始的<code>4</code>个字节用于存放元素个数<code>n</code>, 然后从调用<code>n</code>次构造函数从<code>p-4</code>开始构造对象. </li><li>返回地址,也就是<code>P</code>, 即为<code>p-4</code></li></ul></li></ul></li><li><code>delete[]</code><ul><li>对于简单类型, 直接调用<code>free</code>进行释放(注意简单类型并没有利用<code>4</code>个字节保存元素个数, 由编译器自行优化)</li><li>对于复制类型, <ul><li>首先将指针前移<code>4</code>个字节获得元素个数<code>n</code>, 然后执行<code>n</code>次析构函数, 最后并释放掉内存. </li><li>因为指针指向的是<code>p-4</code>并不是内存的起始地址, 所以使用<code>delete</code>将无法完成释放, 因为<code>free</code>需要通过起始地址进行释放, 而<code>p-4</code>不是起始地址</li></ul></li></ul></li></ul><hr><ul><li>参考: <strong>一定要看看:</strong><a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdHAtMTZiL3AvODY4NDI5OC5odG1s?x-oss-process=image/format,png">深入理解C++ new/delete, new/delete  动态内存管理</a>    </li></ul><hr><h2 id="68、malloc申请的存储空间能用delete释放吗"><a href="#68、malloc申请的存储空间能用delete释放吗" class="headerlink" title="68、malloc申请的存储空间能用delete释放吗"></a>68、<code>malloc</code>申请的存储空间能用<code>delete</code>释放吗</h2><ul><li>不能<ul><li><code>malloc /free</code> 主要为了兼容<code>C</code>，<code>new</code> 和<code>delete</code> 完全可以取代<code>malloc /free</code>的。</li><li><code>malloc /free</code> 的操作对象都是必须明确大小的。而且不能用在动态类上。</li><li><code>new</code> 和<code>delete</code> 会自动进行类型检查和大小，<code>malloc/free</code> 不能执行构造函数与析构函数，所以动态对象它是不行的。</li><li>当然从理论上说使用<code>malloc</code> 申请的内存是可以通过<code>delete</code> 释放的。不过一般不这样写的。而且也不能保证每个<code>C++</code>的运行时都能正常。</li></ul></li></ul><h2 id="69、malloc-与free-的实现原理？"><a href="#69、malloc-与free-的实现原理？" class="headerlink" title="69、malloc 与free 的实现原理？"></a>69、malloc 与free 的实现原理？</h2><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#malloc%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%A6%E5%A4%96brk%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Cmmap%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</a></li></ul><h2 id="70、malloc、realloc、calloc、alloca的区别"><a href="#70、malloc、realloc、calloc、alloca的区别" class="headerlink" title="70、malloc、realloc、calloc、alloca的区别"></a>70、<code>malloc</code>、<code>realloc</code>、<code>calloc</code>、<code>alloca</code>的区别</h2><ul><li><code>malloc</code>函数: 在堆上申请空间, 随机初始化<ul><li><code>void* malloc(unsigned int num_size);</code></li><li><code>int *p = malloc(20*sizeof(int)); // 申请20 个int 类型的空间；</code></li></ul></li><li><code>calloc</code>函数: 省去了人为空间计算；<code>malloc</code> 申请的空间的值是随机初始化的，<code>calloc</code> 申请的空间的值是初始化为<code>0</code> 的；<ul><li><code>void* calloc(size_t n,size_t size);</code></li><li><code>int *p = calloc(20, sizeof(int));</code></li></ul></li><li><code>realloc</code>函数: 给动态分配的空间分配额外的空间，用于扩充容量。(可能会导致内存迁移)<ul><li><code>void realloc(void *p, size_t new_size);</code></li></ul></li><li><code>alloca</code>函数: <code>_alloca</code>是在<strong>栈<code>(stack)</code></strong> 上申请空间,该变量离开其作用域之后被自动释放，无需手动调用释放函数。</li></ul><h2 id="71、-stdcall-和-cdecl-的区别？"><a href="#71、-stdcall-和-cdecl-的区别？" class="headerlink" title="71、__stdcall 和__cdecl 的区别？"></a>71、<code>__stdcall</code> 和<code>__cdecl</code> 的区别？</h2><ul><li>在进行函数调用的过程中, 参数入栈肯定是调用者干的事, 但是参数出栈, 可以由调用者干, 也可以由被调函数干; 所以就需要对函数调用者和被调函数之间责任进行划分, <code>stdcall</code>和<code>cdecl</code>正是两种划分方式</li><li><code>cdecl</code>:<ul><li>是<code>c语言</code>的默认定义, 它规定了由调用者负责回复堆栈,</li><li>好处: 参数数量可以是任意多个</li><li>缺点: 代码存在冗余, 例如100次调用, 就会右100段回复堆栈的代码</li></ul></li><li><code>stdcall</code>:<ul><li>一般用于跨语言的协作, 例如系统调用, 都会使用这种方式, 它规定堆栈的恢复由被调函数负责</li><li>好处: 不会存在代码冗余, 100次低调用, 只有一段恢复堆栈的代码</li><li>缺点: 只能允许规定的参数个数, 无法实现不定参数个数的调用</li></ul></li></ul><hr><ul><li><code>__stdcall</code><ul><li><code>__stdcall</code> 是被函数恢复堆栈，只有在函数代码的结尾出现一次恢复堆栈的代码；</li><li>在编译时就规定了参数个数，无法实现不定个数的参数调用；</li></ul></li><li><code>__cdecl</code><ul><li><code>__cdecl</code> 是调用者恢复堆栈，假设有<code>100</code> 个函数调用函数<code>a</code>，那么内存中就有<code>100</code> 端恢复堆栈的代码；</li><li>可以不定参数个数；</li><li>每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用<code>__stacall</code> 函数大。</li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/myjisgreat/article/details/46477769">__stdcall与__cdecl的区别</a></li></ul><hr><h2 id="72、使用智能指针管理内存资源，RAII"><a href="#72、使用智能指针管理内存资源，RAII" class="headerlink" title="72、使用智能指针管理内存资源，RAII"></a>72、使用智能指针管理内存资源，<code>RAII</code></h2><ul><li><p><code>RAII</code> 全称是“<code>Resource Acquisition is Initialization</code>”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</p></li><li><p>编译器保证, 栈对象在创建时自动调用构造函数，在超出作用域时自动调用析构函数。</p></li><li><p>所以<code>RAII</code>的思想下, 我们使用一个<strong>栈对象</strong>来管理资源, 将资源和对象的生命周期绑定。</p></li><li><p>智能指针<code>(std::shared_ptr</code> 和<code>std::unique_ptr)</code>即<code>RAII</code> 最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记<code>delete</code> 造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现<code>delete</code> 了。</p></li></ul><h2 id="73、手写实现智能指针类"><a href="#73、手写实现智能指针类" class="headerlink" title="73、手写实现智能指针类"></a>73、手写实现智能指针类</h2><ul><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102604626#shared_ptr_257">说一下shared_ptr的实现</a></li></ul><hr><ul><li>计数器: 取计数器, </li><li>指针相关: 取原始指针</li><li>运算符重载: <code>++</code>, <code>--</code>, <code>-&gt;</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>=</code></li><li>构造函数: 更新计数器</li><li>复制构造函数: 更新计数器</li><li>移动构造函数: 计数器不变</li><li>析构函数: 更新计数器, 按条件释放内存</li></ul><ul><li>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。</li><li>它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T 类型对象的引用计数为0，就释放该对象。</li><li>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。</li><li>新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</li><li>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</li><li>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数；</li></ul><h2 id="74、内存对齐？位域？"><a href="#74、内存对齐？位域？" class="headerlink" title="74、内存对齐？位域？"></a>74、内存对齐？位域？</h2><ul><li><p>字节对齐的原因:</p><ul><li>更快: 如果数据未对齐自然边界, 则处理器需要两次寻址才能得到完整的数据</li><li>通用: 部分硬件平面不支持访问未对齐的数据, 会抛出硬件异常</li></ul></li><li><p>具体操作</p><ul><li>自定义对齐系数<ul><li>可以通过预编译命令<code>#pragma pack(n)</code>，<code>n=1</code>,<code>2</code>,<code>4</code>,<code>8</code>,<code>16</code>来改变这一系数，其中的<code>n</code>就是指定的“对齐系数”</li></ul></li><li>数据成员对齐规则: <ul><li>结构<code>(struct)(</code>或联合<code>(union)</code>)的数据成员，第一个数据成员放在<code>offset</code>为<code>0</code>的地方，以后每个数据成员的对齐按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中，比较小的那个进行。</li><li>结构体作为成员：<ul><li>如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。</li></ul></li></ul></li><li>结构(或联合)的整体对齐规则：<ul><li>在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照<code>#pragma pack</code>指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</li></ul></li></ul></li><li><p>位域</p><ul><li><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。</p></li><li><p><code>Ｃ语言</code>又提供了一种数据结构，称为“位域”或“位段”。</p></li><li><p>所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。</p></li><li><p>位段成员必须声明为<code>int</code>、<code>unsigned int</code>或<code>signed int</code>类型<code>(short char long)</code>。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> 位域结构名<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   位域列表 <span class="token comment" spellcheck="true">// 其中位域列表的形式为： 类型说明符 位域名：位域长度</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> bs <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> a<span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> b<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> c<span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  </code></pre></li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90">操作系统中的结构体对齐，字节对齐</a></li><li><a href="https://blog.csdn.net/sty124578/article/details/79456405">位域的定义和使用</a></li></ul></li></ul><hr><h2 id="75、结构体变量比较是否相等"><a href="#75、结构体变量比较是否相等" class="headerlink" title="75、结构体变量比较是否相等"></a>75、结构体变量比较是否相等</h2><ul><li>重载了<code>==</code> 操作符<pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> foo <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    bool operator<span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> foo<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 操作运算符重载</span>        <span class="token keyword">return</span><span class="token punctuation">(</span> a <span class="token operator">==</span> rhs<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> rhs<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li><li>元素的话，一个个比；</li><li>指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；</li></ul><h2 id="76、位运算"><a href="#76、位运算" class="headerlink" title="76、位运算"></a>76、位运算</h2><ul><li>若一个数m 满足m = 2^n;那么k%m=k&amp;(m-1)</li></ul><hr><ul><li><p>判断奇偶</p><ul><li><code>a&amp;1 == 0; // 偶数</code></li><li><code>a&amp;1 == 1; // 奇数</code></li></ul></li><li><p><code>int</code>型变量循环左移<code>k</code>次，即<code>a=a&lt;&lt;k|a&gt;&gt;16-k</code>   <code>(设sizeof(int)=16)</code></p></li><li><p><code>int</code>型变量<code>a</code>循环右移<code>k</code>次，即<code>a=a&gt;&gt;k|a&lt;&lt;16-k</code>   <code>(设sizeof(int)=16)</code></p></li><li><p>整数的平均值</p><ul><li>对于两个整数<code>x</code>,<code>y</code>，如果用 <code>(x+y)/2</code> 求平均值，会产生溢出，因为 <code>x+y</code> 可能会大于<code>INT_MAX</code>，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法：<pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">average</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回X,Y 的平均值</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">^</span>y<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>判断一个整数是不是<code>2</code>的幂,对于一个数 <code>x &gt;= 0</code>，判断他是不是<code>2</code>的幂</p><pre class=" language-c"><code class="language-c">boolean <span class="token function">power2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span><span class="token punctuation">(</span>x<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>x<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span>；<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>不用 <code>temp</code>交换两个整数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    x <span class="token operator">^</span><span class="token operator">=</span> y<span class="token punctuation">;</span>    y <span class="token operator">^</span><span class="token operator">=</span> x<span class="token punctuation">;</span>    x <span class="token operator">^</span><span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>计算绝对值</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token punctuation">;</span>    y <span class="token operator">=</span> x <span class="token operator">>></span> <span class="token number">31</span> <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">^</span>y<span class="token punctuation">)</span><span class="token operator">-</span>y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//or: (x+y)^y</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>取模运算转化成位运算 (在不产生溢出的情况下)</p><ul><li><code>a % (2^n)</code> 等价于<code>a &amp; (2^n - 1)</code></li><li><code>a % 2</code> 等价于 <code>a &amp; 1</code></li></ul></li><li><p>乘法运算转化成位运算 (在不产生溢出的情况下)</p><ul><li><code>a * (2^n)</code> 等价于 <code>a&lt;&lt; n</code></li></ul></li><li><p>除法运算转化成位运算 (在不产生溢出的情况下)</p><ul><li><code>a / (2^n)</code> 等价于 <code>a&gt;&gt; n</code></li><li>例: <code>12/8 == 12&gt;&gt;3</code></li></ul></li><li><p><code>if (x == a) x= b; else x= a;</code> 等价于 <code>x= a ^ b ^ x;</code></p></li><li><p><code>x</code>的相反数表示为 <code>(~x+1)</code></p></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/black_ox/article/details/46411997">位运算总结 取模 取余</a></li></ul><hr><h2 id="77、为什么内存对齐"><a href="#77、为什么内存对齐" class="headerlink" title="77、为什么内存对齐"></a>77、为什么内存对齐</h2><ul><li>平台原因(移植原因)<ul><li>不是所有的硬件平台都能访问任意地址上的任意数据的；</li><li>某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异</li></ul></li><li>性能原因：<ul><li>数据结构(尤其是栈)应该尽可能地在自然边界上对齐。</li><li>原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li></ul></li></ul><h2 id="78、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#78、函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="78、函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>78、函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h2><ul><li><p>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</p></li><li><p>调用者函数使用<code>call</code> 指令调用被调函数,并把<code>call</code> 指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在<code>call</code> 指令中);</p></li><li><p>在被调函数中,被调函数会先保存调用者函数的栈底地址<code>(push ebp)</code>,然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址<code>(mov ebp,esp)</code>;</p></li><li><p>在被调函数中,从<code>ebp</code> 的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</p></li><li><p>关于返回值: </p><ul><li>如果 <code>返回值 &lt;= 4字节</code>，则返回值通过寄存器<code>eax</code>带回。</li><li>如果 <code>4&lt; 返回值 &lt;=8字节</code>，则返回值通过两个寄存器<code>eax</code>和<code>edx</code>带回。</li><li>如果 <code>返回值 &gt; 8字节</code>，则返回值通过产生的临时量带回。</li></ul></li></ul><hr><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#c%E8%AF%AD%E8%A8%80%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84">C语言是怎么进行函数调用的?</a><ul><li>参数逆序入栈</li><li>返回地址入栈</li><li>调用函数栈顶入栈</li><li>被调用函数栈底入栈</li><li>局部变量入栈</li></ul></li></ul><hr><h2 id="79、怎样判断两个浮点数是否相等？"><a href="#79、怎样判断两个浮点数是否相等？" class="headerlink" title="79、怎样判断两个浮点数是否相等？"></a>79、怎样判断两个浮点数是否相等？</h2><ul><li>对两个浮点数判断大小和是否相等不能直接用<code>==</code>来判断，会出错！</li><li>明明相等的两个数比较反而是不相等！</li><li>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！</li><li>浮点数与<code>0</code> 的比较也应该注意。与浮点数的表示方式有关。</li><li><code>fabs(a-b)&lt;=1.0e-9</code></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/liuyc/p/5933850.html">在程序中如何判断两个浮点数相等</a></li></ul><hr><h2 id="80、宏定义一个取两个数中较大值的功能"><a href="#80、宏定义一个取两个数中较大值的功能" class="headerlink" title="80、宏定义一个取两个数中较大值的功能"></a>80、宏定义一个取两个数中较大值的功能</h2><ul><li><code>#define MAX（x,y）((x&gt;y?)x:y)</code></li></ul><h2 id="81、define、const、typedef、inline-使用方法？"><a href="#81、define、const、typedef、inline-使用方法？" class="headerlink" title="81、define、const、typedef、inline 使用方法？"></a>81、<code>define</code>、<code>const</code>、<code>typedef</code>、<code>inline</code> 使用方法？</h2><ul><li><p><code>const</code> 与<code>#define</code> 的区别：<code>作用阶段不同</code>, <code>功能不同</code>, <code>define作用丰富</code>, <code>占用的空间不同</code>, <code>作用域</code></p><ul><li>作用阶段不同: <code>const</code>在编译和链接阶段其作用, <code>define</code>在预编译阶段起作用</li><li>功能不同: <ul><li><code>const</code>是定义一个变量, 拥有数据类型, 会进行语义语法检查</li><li><code>define</code>是宏定义, 简单的问题替代, 没有类型检查</li></ul></li><li><code>define</code>的作用更丰富: <code>define</code>可以配合条件预编译指令, 完成特殊的逻辑, 例如防止重复引用文件</li><li>编译后占用的空间: <code>const</code>定义的是变量, 会储存在数据段空间, <code>define</code>是宏替换, 其值会储存在代码段</li><li>作用域不同: <code>define</code>没有作用域限制, 而const定义的变量通常有作用域的限制(全局变量默认为extern)</li></ul></li><li><p><code>#define</code> 和别名<code>typedef</code> 的区别</p><ol><li>执行时间不同，<code>typedef</code> 在编译阶段有效，<code>typedef</code> 有类型检查的功能；#<code>define</code> 是宏定义，发生在预处理阶段，不进行类型检查；</li><li>功能差异，<code>typedef</code> 用来定义类型的别名，定义与平台无关的数据类型，与<code>struct</code>的结合使用等。#<code>define</code> 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li><li>作用域不同，<code>#define</code> 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而<code>typedef</code> 有自己的作用域。</li></ol></li><li><p><code>define</code> 与<code>inline</code> 的区别</p><ol><li><code>#define</code> 是关键字，<code>inline</code> 是函数；</li><li>宏定义在预处理阶段进行文本替换，<code>inline</code> 函数在编译阶段进行替换；</li><li><code>inline</code> 函数有类型检查，相比宏定义比较安全；</li></ol></li></ul><h2 id="82、printf-实现原理？"><a href="#82、printf-实现原理？" class="headerlink" title="82、printf 实现原理？"></a>82、<code>printf</code> 实现原理？</h2><ul><li>函数的调用过程: 参数逆序入栈, 返回地址入栈, 调用函数栈顶入栈, 设置被调函数栈底, 然后是被调函数的局部变量</li><li>在调用<code>printf</code>时, 首先获取第一个形参, 也就是字符指针, 然后解析所指向的字符串, 得到后续参数的个数和数据类型, </li><li>然后计算出偏移量, 并从当前函数栈的栈底往上偏移得到</li><li><code>printf(&quot;%d,%d&quot;,a,b);</code></li></ul><h2 id="83、-include的顺序以及尖叫括号和双引号的区别"><a href="#83、-include的顺序以及尖叫括号和双引号的区别" class="headerlink" title="83、#include的顺序以及尖叫括号和双引号的区别"></a>83、<code>#include</code>的顺序以及尖叫括号和双引号的区别</h2><ul><li>路径不同, 参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102943714#include_77">include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</a></li></ul><h2 id="84、lambda-函数"><a href="#84、lambda-函数" class="headerlink" title="84、lambda 函数"></a>84、lambda 函数</h2><ul><li>包括五大部分: 捕获列表, 参数列表, 修饰符, 返回类型, 函数体</li><li>捕获列表: 对参数的捕获, 捕获方式为<code>值传递([=], [val])</code>和<code>引用([&amp;], [&amp;val])</code></li><li>参数列表: 参数列表, 和不同函数一样, 如果没有可以省略</li><li>修饰符: 默认情况下lambda函数总是一个const函数，Mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略。</li><li>返回类型</li><li>函数体: 除了可以使用参数外, 还可以使用捕获的参数</li></ul><hr><ul><li><strong>参考:</strong> <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c11%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8Clambda">C++11中的可变参数模板、右值引用和lambda</a></li></ul><hr><h2 id="85、hello-world-程序开始到打印到屏幕上的全过程"><a href="#85、hello-world-程序开始到打印到屏幕上的全过程" class="headerlink" title="85、hello world 程序开始到打印到屏幕上的全过程?"></a>85、hello world 程序开始到打印到屏幕上的全过程?</h2><ul><li>应用程序</li><li>应用程序载入内存变成进程</li><li>进程获取系统的标准输出接口</li><li>系统为进程分配CPU</li><li>触发缺页中断</li><li>通过puts系统调用, 往标准输出接口上写字符串</li><li>操作系统将字符串发送到显示器驱动上</li><li>驱动判断该操作的合法性, 然后将该操作变成像素, 写入到显示器的储存映射区</li><li>硬件将该像素值改变转变成控制信号控制显示器显示</li></ul><hr><ul><li>用户告诉操作系统执行<code>HelloWorld</code> 程序(通过键盘输入等)</li><li>操作系统：找到<code>helloworld</code> 程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</li><li>操作系统：创建一个新进程，将<code>HelloWorld</code> 可执行文件映射到该进程结构，表示由该进程执行<code>helloworld</code> 程序。</li><li>操作系统：为<code>helloworld</code> 程序设置<code>cpu</code> 上下文环境，并跳到程序开始处。</li><li>执行<code>helloworld</code> 程序的第一条指令，发生缺页异常</li><li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行<code>helloworld</code> 程序</li><li><code>helloword</code> 程序执行<code>puts</code> 函数(系统调用)，在显示器上写一字符串</li><li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</li><li>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</li><li>视频硬件将像素转换成显示器可接收和一组控制数据信号</li><li>显示器解释信号，激发液晶屏</li><li><code>OK</code>，我们在屏幕上看到了<code>HelloWorld</code></li></ul><h2 id="86、模板类和模板函数的区别是什么？"><a href="#86、模板类和模板函数的区别是什么？" class="headerlink" title="86、模板类和模板函数的区别是什么？"></a>86、模板类和模板函数的区别是什么？</h2><ul><li>函数模板的实例化是由编译程序在处理函数调用时自动完成的</li><li>类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必</li></ul><h2 id="87、为什么模板类一般都是放在一个h-文件中"><a href="#87、为什么模板类一般都是放在一个h-文件中" class="headerlink" title="87、为什么模板类一般都是放在一个h 文件中"></a>87、为什么模板类一般都是放在一个h 文件中</h2><ul><li><p>编译器并不是把函数模板处理成能够处理<strong>任意类型</strong>的函数；编译器从<strong>函数模板</strong>通过<strong>具体类型</strong>==产生==不同的<strong>函数</strong>；</p></li><li><p>编译器会对函数模板进行两次编译：</p><ul><li>在声明的地方对模板代码本身进行编译，</li><li>在调用的地方对参数替换后的代码进行编译。</li></ul></li><li><p>如果模板函数不是定义在<code>.h</code>文件中</p><ul><li>编译器编译<code>.cpp</code>文件时并不知道另一个<code>.cpp</code>文件的存在, 也不会去查找(查找通常是链接阶段的事)<ul><li>在定义模板函数的<code>.cpp</code>文件中, 编译器对函数模板进行了第一次编译, 但是它并没有发现任何调用, 故而没有生产任何的函数实例</li><li>在调用了模板函数的<code>.cpp</code>文件中, 编译器发现调用其他函数, 但是在此<code>.cpp</code>文件中并没有定义, 所以将此次调用处理为外部连接符号, 期望链接阶段由连接器给出被调函数的函数地址. </li></ul></li><li>在链接阶段, 连接器找不到被调函数故而报不能识别的外部链接错误.</li></ul></li></ul><hr><ul><li><p>模板定义很特殊。</p><ul><li>由<code>template&lt;…&gt;</code>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。</li><li>在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li><li>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</li></ul></li><li><p>在分离式编译的环境下</p><ul><li>编译器编译某一个<code>.cpp</code> 文件时并不知道另一个<code>.cpp</code> 文件的存在，也不会去查找(当遇到未决符号时它会寄希望于连接器)。</li><li>这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</li><li>然而当实现该模板的<code>.cpp</code> 文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的<code>.obj</code>中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</li></ul></li></ul><hr><h2 id="88、C-中类成员的访问权限和继承权限问题。"><a href="#88、C-中类成员的访问权限和继承权限问题。" class="headerlink" title="88、C++中类成员的访问权限和继承权限问题。"></a>88、C++中类成员的访问权限和继承权限问题。</h2><ul><li>参考: <a href="https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/#c%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">C++中类成员的访问权限</a></li></ul><h2 id="89、cout-和printf-有什么区别？"><a href="#89、cout-和printf-有什么区别？" class="headerlink" title="89、cout 和printf 有什么区别？"></a>89、cout 和printf 有什么区别？</h2><ul><li><code>cout</code>有缓冲区, <code>printf</code>无缓冲区; 有缓冲区意味着<ul><li>操作系统可以待用户刷新缓冲区时输出, 或则缓冲区存满的时候输出, </li><li>如果操作系统空闲的话也会检查缓冲区是否有值, 如果有的话立即输出.</li><li><code>endl</code>相当于输出回车后，再强迫缓冲输出。</li><li><code>flush</code>立即强迫缓冲输出。</li></ul></li><li><code>cout &lt;&lt;</code>是一个函数, 它对常见数据类型进行了重载, 所以能自动识别数据的类型并进行输出.</li></ul><h2 id="90、重载运算符？"><a href="#90、重载运算符？" class="headerlink" title="90、重载运算符？"></a>90、重载运算符？</h2><ul><li>引入运算符重载，是为了实现类的多态性；</li><li>只能重载已有的运算符；对于一个重载的运算符，其<code>优先级</code>和<code>结合律</code>与内置类型一致才可以；不能改变运算符操作数个数；</li><li><code>.</code>, <code>：</code>, <code>？</code>, <code>sizeof</code>, <code>typeid</code> <code>**</code>不能重载；</li><li>两种重载方式，成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符(重载的箭头运算符必须返回类的指针)、解引用运算符必须是成员运算符；</li><li>当重载的运算符是成员函数时，<code>this</code> 绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</li><li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li><li>当运算符既是一元运算符又是二元运算符(<code>+</code>，<code>-</code>，<code>*</code>，<code>&amp;</code>)，从参数的个数推断到底定义的是哪种运算符；</li></ul><h2 id="91、函数重载函数匹配原则"><a href="#91、函数重载函数匹配原则" class="headerlink" title="91、函数重载函数匹配原则"></a>91、函数重载函数匹配原则</h2><ul><li>首先进行名字查找, 确定候选函数</li><li>然后按照以下顺序进行匹配:<ul><li>精确匹配：参数匹配而不做转换，或者只是做微不足道的转换，如数组名到指针、函数名到指向函数的指针、<code>T</code>到<code>const T</code>；</li><li>提升匹配：即整数提升(如<code>bool</code>到<code>int</code>、<code>char</code>到<code>int</code>、<code>short</code>到<code>int</code>、<code>float</code>到<code>double</code>)，；</li><li>使用标准转换匹配：如<code>int</code>到<code>double</code>、<code>double</code>到<code>int</code>、<code>double</code>到<code>long double</code>、<code>Derived*</code>到<code>Base*</code>、<code>T*</code>到<code>void*</code>、<code>int</code>到<code>unsigned int</code>；</li><li>使用用户自定义匹配；</li><li>使用省略号匹配：类似于<code>printf</code>中省略号参数。</li></ul></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/bonelee/p/5951718.html">重载函数的调用匹配规则</a></li></ul><hr><h2 id="92、定义和声明的区别"><a href="#92、定义和声明的区别" class="headerlink" title="92、定义和声明的区别"></a>92、定义和声明的区别</h2><ul><li>如果是指变量的声明和定义<ul><li>从编译原理上来说，<ul><li>变量声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。</li><li>变量定义就是分配了内存。</li></ul></li></ul></li><li>如果是指函数的声明和定义<ul><li>函数声明：一般在头文件里，对编译器说：这里我有一个函数叫<code>function()</code> 让编译器知道这个函数的存在。</li><li>函数定义：一般在源文件里，具体就是函数的实现过程写明函数体。</li></ul></li></ul><h2 id="93、C-类型转换有四种"><a href="#93、C-类型转换有四种" class="headerlink" title="93、C++类型转换有四种"></a>93、<code>C++</code>类型转换有四种</h2><ul><li><code>const_cast</code>: <ul><li>用来移除<code>const</code>或<code>volatile</code> 属性。但需要特别注意的是<code>const_cast</code>不是用于去除变量的常量性，而是去除<strong>指向常数对象的指针或引用</strong>的常量性，其去除常量性的对象必须为<strong>指针或引用</strong>。</li><li>如果对一个指向常量的指针,通过<code>const_cast</code>移除<code>const</code>属性, 然后进行修改, 编译通过,但是运行时会报段错误</li></ul></li><li><code>static_cast</code>: 静态类型转换(不能移除<code>const/volatile</code>属性)是最常看到的类型转换, 几个功能. <ul><li><strong>内置类型之间的转换</strong>, 精度耗损需要有程序员把握</li><li><strong>继承体系中的上下行转换</strong>(上行:子类转父类,安全转换; 下行:父类转子类, 不安全转换)</li><li><strong>指针类型转换</strong>: <code>空指针转换成目标类型的空指针</code>, <code>把任何类型转换成void 类型</code>。</li></ul></li><li><code>dynamic_cast</code>: 主要用在继承体系中的安全向下转型<ul><li>它能安全地将指向基类的<code>指针/引用</code>转型为指向子类的<code>指针/引用</code>, 转型失败会返回<code>null</code>(转型对象为指针时)或抛出异常<code>bad_cast</code>(转型对象为引用时)。</li><li><code>dynamic_cast</code> 会利用运行时的信息<code>(RTTI)</code>来进行动态类型检查，因此dynamic_cast 存在一定的效率损失。</li><li>而且<code>dynamic_cast</code>进行动态类型检查时, 利用了虚表中的信息, 所以只能用于函数虚函数的类对象中. </li></ul></li><li><code>reinterpret_cast</code> 强制类型转换,<strong>非常不安全</strong><ul><li>它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针(先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值)。</li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://www.cnblogs.com/lidabo/p/3651049.html">C++开发必看 四种强制类型转换的总结</a></li><li><a href="https://www.cnblogs.com/yizui/archive/2019/03/30/10628020.html">C++系列总结——volatile关键字</a></li></ul></li></ul><hr><h2 id="94、全局变量和static-变量的区别"><a href="#94、全局变量和static-变量的区别" class="headerlink" title="94、全局变量和static 变量的区别"></a>94、全局变量和static 变量的区别</h2><ul><li>static变量分为两个类型: 全局静态变量(在全局变量的类型前加上static)和局部静态变量(在局部变量的类型前加上static).</li><li>从储存形式看: 他们没有区别, 都储存于静态数据区</li><li>从作用域看: <ul><li>全局变量默认具有extern属性, 它的作用域为整个项目, 可能和其他cpp文件中的全局变量发生命名冲突.</li><li>全局静态变量,作用域受限, 它的作用域仅限于定义它的文件内有效, 不会和其他cpp文件中的全局变量发生命名冲突.</li><li>局部静态变量, 作用域依旧不管, 当时当离开作用域时不会变量不会被释放, 其值保持不变只是被屏蔽了, 直到再次进入作用域, 其也只会被初始化一次.</li></ul></li></ul><h2 id="static-函数与普通函数有什么区别？"><a href="#static-函数与普通函数有什么区别？" class="headerlink" title="static 函数与普通函数有什么区别？"></a><code>static</code> 函数与普通函数有什么区别？</h2><ul><li><code>static</code> 函数与普通函数有什么区别？<ul><li><code>static</code> 函数与普通的函数作用域不同。<ul><li>普通函数默认为<code>extern</code>属性, 作用域为整个项目, 可能会和其他<code>cpp</code>文件中的函数发生命名冲突.</li><li><code>static</code>修饰的函数, 作用域受限仅为定义的文件, 不会和其他<code>cpp</code>文件中的函数发生命名冲突.</li></ul></li></ul></li></ul><h2 id="95、静态成员与普通成员的区别"><a href="#95、静态成员与普通成员的区别" class="headerlink" title="95、静态成员与普通成员的区别"></a>95、静态成员与普通成员的区别</h2><ul><li>储存位置不同: 普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</li><li>声明周期不同:<ul><li>静态成员变量从类被加载开始到类被卸载，一直存在；</li><li>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</li></ul></li><li>初始化位置: 普通成员变量在类中初始化；<strong>静态成员变量在类外初始化</strong>；</li><li>拥有则不同: 静态成员变量可以理解为是属于类的变量,可以通过类名进行访问, 为本类的所有对象所共享；普通成员变量是每个对象单独享用的, 只能通过对象进行访问；</li></ul><h2 id="96、说一下理解ifdef-endif"><a href="#96、说一下理解ifdef-endif" class="headerlink" title="96、说一下理解ifdef endif"></a>96、说一下理解<code>ifdef</code> <code>endif</code></h2><ul><li>从源文件到可执行程序的过程, 通常要经历: <code>预编译</code>, <code>编译</code>, <code>汇编</code>, <code>链接</code>等过程</li><li><code>ifdef</code>, <code>endif</code>为条件预编译指令, 生效于预编译阶段, 根据条件可以完成一些特殊的逻辑, <strong>例如防止文件重复引用</strong></li><li><code>#ifdef</code>, <code>#else</code>,<code>#endif</code>为完整的逻辑, 分别表示, 如果定义了某个标识符, 则编译后续程序段, 否则编译另外一个程序段</li><li>因为预编译阶段处于编译链的第一阶段, 它可以直接影响应用程序的大小. </li></ul><h2 id="97、隐式转换，如何消除隐式转换？"><a href="#97、隐式转换，如何消除隐式转换？" class="headerlink" title="97、隐式转换，如何消除隐式转换？"></a>97、隐式转换，如何消除隐式转换？</h2><ul><li>隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换, <ul><li>例如: <ul><li>类型提升: <code>(bool, int)</code>; <code>(short, int)</code>; <code>(float, double)</code></li><li>类型转换: <code>(int, float)</code>; <code>(int, double)</code>, <code>(Derived*, Base*)</code></li></ul></li></ul></li><li>基本数据类型的转换, 通常发生于从小到大的变换, 以保证精度不丢失</li><li>对于用户自定义类型, 如果存在单参数构造函数, 或则除一个参数外其他参数都有默认参数的, 此时编译器可能完成由此参数类型到自定义类型的隐式变换, 消除方式为使用关键字<code>explicit</code>禁止隐式转换. </li></ul><h2 id="98、虚函数的内存结构，那菱形继承的虚函数内存结构呢"><a href="#98、虚函数的内存结构，那菱形继承的虚函数内存结构呢" class="headerlink" title="98、虚函数的内存结构，那菱形继承的虚函数内存结构呢"></a>98、虚函数的内存结构，那菱形继承的虚函数内存结构呢</h2><ul><li>如果一个类存在虚函数, 则会发生以下几个变化<ul><li>如果不存在构造函数, 则编译器一定会合成默认构造函数</li><li>编译器会为类生成一个虚表(储存在静态区, 不占用对象内存), 并给该类的每个对象插入一个指向虚表的指针(通常此指针位于对象的起始位置), 虚函数表的每一项为函数的入口地址.</li></ul></li><li>如果派生类的基类存在虚函数,则<ul><li>编译器会复制基类的虚表形成一个副本, 然后给该派生类对象插入一个指向该虚表副本的指针</li><li>如果该派生类对基类的虚函数进行了重定义, 则会替换虚表副本中的对应函数入口地址</li><li>如果该派生类新增了虚函数, 则对该虚表副本增加对应的项</li></ul></li><li>如果存在菱形结构的继承关系, 则通常回使用虚继承的方式, 防止同一类中存在基类的多个副本<ul><li>虚表的继承方式和普通继承一样, 但是在<ul><li>如果不存在构造函数, 则编译器一定会合成默认构造函数</li></ul></li><li>如果类<code>B</code>虚拟继承自类<code>A</code>, 则类<code>B</code>中存在一个虚基类表指针,指向一个虚基类表(储存在静态区, 不占用对象内存), 此虚基类表中存储中虚基类相对于当前类对象的偏移量.</li><li>不同的编译器对虚基类表指针的处理方式不同, 例如<code>VS</code>编译器将虚基类表指针插入到对象中(会占用对象内存), 而<code>SUN/GCC</code>公式的编译器则是插入到虚函数表中(不占用对象内存)</li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/zzxiaozhao/article/details/102990773#staticvirtual_731">给你一个类，里面有static，virtual，之类的，说一说这个类的内存分布</a></li></ul><hr><h2 id="99、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#99、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="99、多继承的优缺点，作为一个开发者怎么看待多继承"></a>99、多继承的优缺点，作为一个开发者怎么看待多继承</h2><ul><li><code>C++</code>允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</li><li>优点: 对象可以调用多个基类中的接口；</li><li>缺点:<ul><li>如果基类重存在多个相同的基类或则方法, 则会出现二义性(解决方案是调用时加上全局限定符)</li><li>容易存在菱形继承, 从而导致存在多个基类的副本(解决方案是使用虚拟继承)</li></ul></li></ul><hr><ul><li>个人觉得挺方便的, 虽然有缺点,但是也都用对应的解决方案</li></ul><h2 id="100、迭代器-it-it-哪个好，为什么"><a href="#100、迭代器-it-it-哪个好，为什么" class="headerlink" title="100、迭代器++it,it++哪个好，为什么"></a>100、迭代器++it,it++哪个好，为什么</h2><ul><li><code>略</code></li></ul><h2 id="101、C-如何处理多个异常的？"><a href="#101、C-如何处理多个异常的？" class="headerlink" title="101、C++如何处理多个异常的？"></a>101、C++如何处理多个异常的？</h2><ul><li><code>C++</code>中的错误情况：<ul><li>**语法错误(编译错误)**：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。</li><li><strong>运行时错误</strong>：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，<code>C++</code>中引入异常处理机制来解决此问题。</li></ul></li><li><code>C++</code>异常处理机制：<ul><li>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。</li><li><code>C++</code>异常处理机制由3 个模块组成：<code>try(检查)</code>、<code>throw(抛出)</code>、<code>catch(捕获)</code></li><li>首先是: 抛出异常的语句格式为：<code>throw 表达式</code>；</li><li>如果<code>try</code>块中程序段发现了异常则抛出异常, 则依次尝试通过<code>catch</code>进行捕获, 如果捕获成功则调用相应的函数处理段, 如果捕获失败, 则条用terminal终止程序.<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">try</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能抛出异常的语句；(检查)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>类型名<span class="token punctuation">[</span>形参名<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//捕获特定类型的异常</span>  <span class="token comment" spellcheck="true">//处理1；</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>类型名<span class="token punctuation">[</span>形参名<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//捕获特定类型的异常</span>  <span class="token comment" spellcheck="true">//处理2；</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//捕获所有类型的异常</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><code>C++</code>标准的异常<ul><li><code>std::exception</code>: 所有标准 <code>C++</code> 异常的父类。</li><li><code>std::logic_error</code>: 逻辑错误(无效的参数, 太长的<code>std::string</code>, 数组越界)</li><li><code>std::runtime_error</code>: 运行时错误(数据溢出)</li></ul></li><li>我们可以通过这些类派生出自己的错误类型,尤其是对<code>logic_error</code>进行重载</li></ul><hr><ul><li>参考: <a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">C++ 异常处理 | 菜鸟教程</a></li></ul><hr><h2 id="102、模板和实现可不可以不写在一个文件里面？为什么？"><a href="#102、模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="102、模板和实现可不可以不写在一个文件里面？为什么？"></a>102、模板和实现可不可以不写在一个文件里面？为什么？</h2><ul><li>参考: <a href="#87%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh-%E6%96%87%E4%BB%B6%E4%B8%AD">87、为什么模板类一般都是放在一个h 文件中</a></li></ul><h2 id="104、智能指针的作用；"><a href="#104、智能指针的作用；" class="headerlink" title="104、智能指针的作用；"></a>104、智能指针的作用；</h2><ul><li><code>C++11</code>中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露(忘记释放)，二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</li><li>三个指针指针: <code>unique_ptr</code>、<code>shared_ptr</code> 、<code>weak_ptr</code></li><li><code>unique_ptr</code><ul><li>语意为<strong>唯一</strong>拥有所指向对象</li><li>其只支持移动语义, 不允许拷贝语义, 不允许强制剥夺, 有条件支持赋值语义(等号右边为右值的时候). </li><li>当unique_ptr指针生命周期结束, 且没有被使用移动语义, 则会将所指向对象释放掉.</li></ul></li><li><code>shared_ptr</code><ul><li>语义为<strong>共享</strong>的拥有多指向的对象, 其支持拷贝语义, 支持移动语义, 支持赋值语义. </li><li><code>shared_ptr</code>内部存在一个计数器, 为指向该对象的所有<code>shared_ptr</code>所共享, </li><li>每减少一个<code>shared_ptr</code>则计数器减一, 没多一个则计数器加一</li><li>当计数器为零时则释放所指向的对象.</li></ul></li><li><code>weak_ptr</code>: 解决交叉引用问题, 房子内存泄漏. </li></ul><h2 id="105、auto-ptr作用"><a href="#105、auto-ptr作用" class="headerlink" title="105、auto_ptr作用"></a>105、<code>auto_ptr</code>作用</h2><hr><ul><li>已经被<code>unique_ptr</code>替代, 其允许强制剥夺所有权, 会存在野指针风险. </li></ul><hr><ol><li><code>auto_ptr</code> 的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针<code>p</code> 所指向的空间得不到释放而导致内存泄漏；</li><li><code>auto_ptr</code> 构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个<code>auto_ptr&lt;Type&gt;</code>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li><li><code>auto_ptr</code> 的构造函数是<code>explicit</code>，阻止了一般指针隐式转换为<code>auto_ptr</code> 的构造，所以不能直接将一般类型的指针赋值给<code>auto_ptr</code> 类型的对象，必须用<code>auto_ptr</code> 的构造函数创建对象；</li><li>由于<code>auto_ptr</code> 对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li><li><code>Auto_ptr</code> 内部实现，析构函数中删除对象用的是<code>delete</code> 而不是<code>delete</code>[]，所以<code>auto_ptr</code> 不能管理数组；</li><li><code>auto_ptr</code> 支持所拥有的指针类型之间的隐式类型转换。</li><li>可以通过<code>*</code>和<code>-&gt;</code>运算符对<code>auto_ptr</code> 所有用的指针进行提领操作；</li><li><code>T* get()</code>,获得<code>auto_ptr</code> 所拥有的指针；<code>T* release()</code>，释放<code>auto_ptr</code>的所有权，并将所有用的指针返回。</li></ol><h2 id="106、class、union、struct-的区别"><a href="#106、class、union、struct-的区别" class="headerlink" title="106、class、union、struct 的区别"></a>106、class、union、struct 的区别</h2><ul><li><p><code>struct</code>在<code>C</code>和<code>C++</code>中是不同的</p><ul><li><code>C</code>语言中: <ul><li><code>struct</code>为自定义数据类型, 结构体名不能单独作为类型使用, 其结构名前必须加<code>struct</code> 才行</li><li><code>struct</code>为变量的集合, 不能存定义函数(但是可以存在函数指针变量)</li><li><code>struct</code>不存在访问权限控制的概念</li></ul></li><li><code>C++</code>中:<ul><li><code>struct</code>为抽象数据类型, 只一个特殊的<code>class</code>, 支持成员函数的定义, 可以继承和实现多态</li><li>增加了访问权限控制的概念, 但是默认访问和继承权限为<code>public</code></li><li>结构体名字可以为直接做为类型使用</li></ul></li></ul></li><li><p><code>C++</code>中<code>struct</code>和<code>class</code>的区别</p><ul><li>默认的访问和继承权限不同</li><li>注意<code>C++</code>中<code>struct</code>可以使用模板</li></ul></li><li><p><code>union</code></p><ul><li><code>C语言</code>中:<ul><li><code>union</code>是一种数据格式，能够存储不同的数据类型，但只能同时存储其中的一种类型。</li><li><code>union</code>的数据成员是共享内存的, 以成员最大的做为结构体的大小</li><li>每个数据成员在内存中的起始地址是相同的。</li></ul></li><li><code>C++</code>中: <ul><li><code>union</code> 结构式一种特殊的类。 默认访问权限是<code>public</code>。</li><li>能包含访问权限、成员变量、成员函数(可以包含构造函数和析构函数)。</li><li>不能包含虚函数和静态数据变量。也不能被用作其他类的基类，它本身也不能从某个基类派生而来。</li><li><code>union</code>成员是共享内存的，以<code>size</code> 最大的结构作为自己的大小。</li><li>每个数据成员在内存中的起始地址是相同的。</li></ul></li><li>无论是<code>C/C++</code>, <code>union</code>的储存方式都是小端模式储存的</li></ul></li></ul><hr><ul><li>参考: <ul><li><a href="https://blog.csdn.net/zzxiaozhao/article/details/103188945#15_C_struct_C_struct__228">15、C 语言struct 和C++ struct 区别</a></li><li><a href="https://blog.csdn.net/zzxiaozhao/article/details/102943714#Cstructclass_35">C++中struct和class的区别</a></li><li><a href="https://blog.csdn.net/weixin_30817749/article/details/98037298">C++的struct可以使用template</a></li></ul></li></ul><hr><h2 id="107、动态联编与静态联编"><a href="#107、动态联编与静态联编" class="headerlink" title="107、动态联编与静态联编"></a>107、<code>动态联编</code>与<code>静态联编</code></h2><ul><li><p>在<code>C++</code>中，<strong>联编是指一个计算机程序的不同部分彼此关联的过程</strong>。按照联编所进行的<strong>阶段</strong>不同，可以分为<strong>静态联编</strong>和<strong>动态联编</strong>；</p></li><li><p><strong>静态联编</strong></p><ul><li>是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。</li><li>要实现静态联编，在编译阶段就必须确定程序中的操作调用(如函数调用)与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。</li><li><strong>静态联编</strong>对<strong>成员函数</strong>的选择是<strong>基于指向对象的指针或者引用的类型</strong>。</li><li>其优点是<strong>效率高</strong>，但<strong>灵活性差</strong>。</li></ul></li><li><p><strong>动态联编</strong></p><ul><li>是指联编在程序运行时动态地进行，根据当时的情况来确定调用哪个同名函数，<strong>实际上是在运行时虚函数的实现</strong>。这种联编又称为晚期联编，或动态束定。</li><li><strong>动态联编</strong>对<strong>成员函数</strong>的选择是<strong>基于对象的类型</strong>，针对不同的对象类型将做出不同的编译结果。</li><li><code>C++</code>中一般情况下的联编是静态联编，但是当涉及到<strong>多态性</strong>和<strong>虚函数</strong>时应该使用动态联编。</li><li>动态联编的优点是<strong>灵活性强</strong>，但<strong>效率低</strong>。</li><li><strong>动态联编规定，只能通过<code>指向基类的指针或基类对象的引用</code>来调用虚函数</strong>，其格式为：<ul><li><code>指向基类的指针变量名</code> <code>-&gt;</code> <code>虚函数名(实参表);</code> </li><li><code>或基类对象的引用名</code> <code>.</code> <code>虚函数名(实参表)</code></li></ul></li></ul></li></ul><hr><ul><li>实现动态联编三个条件：<ul><li>必须把动态联编的行为定义为<strong>类的虚函数</strong>；</li><li><strong>类之间应满足子类型关系</strong>，通常表现为一个类从另一个类公有派生而来；</li><li>必须先<strong>使用基类指针指向子类型的对象</strong>，然后直接或间接使用<strong>基类指针调用虚函数</strong>；</li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/neiloid/article/details/6934129">c++动态联编与静态联编</a></li></ul><hr><h2 id="108、动态编译与静态编译"><a href="#108、动态编译与静态编译" class="headerlink" title="108、动态编译与静态编译"></a>108、<code>动态编译</code>与<code>静态编译</code></h2><ul><li><p><code>静态编译</code></p><ul><li>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去</li><li>缺点: <strong>编译慢</strong>, <strong>可执行程序大</strong></li><li>优点: 使可执行文件在运行时<strong>不需要依赖于动态链接库</strong>；</li></ul></li><li><p><code>动态编译</code></p><ul><li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。</li><li>优点: <ul><li>一方面是<strong>缩小</strong>了执行文件本身的体积，</li><li>另一方面是<strong>加快了编译速度</strong>，节省了系统资源。</li></ul></li><li>缺点:<ul><li>哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；</li><li>二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li></ul></li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/weixin_38907560/article/details/81478981">动态编译、静态编译区别(转)</a></li></ul><hr><h2 id="109、动态链接和静态链接区别"><a href="#109、动态链接和静态链接区别" class="headerlink" title="109、动态链接和静态链接区别"></a>109、<code>动态链接</code>和<code>静态链接</code>区别</h2><ul><li><p><strong>静态链接</strong>：</p><ol><li>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</li><li><strong>空间浪费</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件在多个程序内都存在一个副本；</li><li><strong>更新困难</strong>：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</li><li><strong>运行速度快</strong>：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li></ol></li><li><p><strong>动态链接</strong>：</p><ol><li>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li><li><strong>共享库</strong>：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是这多个程序在执行时共享同一份副本；</li><li><strong>更新方便</strong>：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</li><li><strong>性能损耗</strong>：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</li></ol></li></ul><hr><ul><li>区别<ul><li>使用静态链接生成的可执行文件可能会存在共享库的多个复本, 而使用动态链接库的可执行文件只有存在一份</li><li>使用静态链接库的可执行程序不需要依赖动态链接库, 依赖关系简单; 而使用动态链接库的可执行程序需要引用动态链接库, 故而依赖关系复杂</li><li><strong>静态链接生成的静态链接库不能再包含其他的动态链接库或则静态库, 而动态链接库可以包括其他的动态库或则静态库.</strong></li></ul></li></ul><hr><ul><li>参考: <a href="https://blog.csdn.net/weixin_38907560/article/details/81478981">动态编译、静态编译区别(转)</a></li></ul><hr><h2 id="110、在不使用额外空间的情况下，交换两个数？"><a href="#110、在不使用额外空间的情况下，交换两个数？" class="headerlink" title="110、在不使用额外空间的情况下，交换两个数？"></a>110、在不使用额外空间的情况下，交换两个数？</h2><ul><li>算术<pre class=" language-c"><code class="language-c">x <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>y <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>x <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span></code></pre></li><li>异或<pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 原理 x ^= y ^= x; 能对int,char..</span>x <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span> y <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span>x <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span></code></pre></li></ul><h2 id="111、strcpy-和memcpy-的区别"><a href="#111、strcpy-和memcpy-的区别" class="headerlink" title="111、strcpy 和memcpy 的区别"></a>111、<code>strcpy</code> 和<code>memcpy</code> 的区别</h2><ul><li>复制的内容不同。<code>strcpy</code> 只能复制字符串，而<code>memcpy</code> 可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。<code>strcpy</code> 不需要指定长度，它遇到被复制字符的串结束符<code>\0</code>才结束，所以容易溢出。<code>memcpy</code> 则是根据其第<code>3</code> 个参数决定复制的长度。</li></ul><h2 id="112、执行int-main-int-argc-char-argv-时的内存结构"><a href="#112、执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="112、执行int main(int argc, char *argv[])时的内存结构"></a>112、执行<code>int main(int argc</code>, <code>char *argv</code>[])时的内存结构</h2><ul><li>参数的含义是程序在命令行下运行的时候，需要输入<code>argc</code> 个参数，每个参数是以<code>char</code>类型输入的，依次存在数组里面，数组是<code>argv[]</code>，所有的参数在指针<code>char *</code> 指向的内存中，数组的中元素的个数为<code>argc</code> 个，第一个参数为程序的名称。</li></ul><hr><ul><li><code>main</code>函数是用户代码的入口函数, 其调用过程依旧是函数调用过程, 区别在于main函数的参数有固定的规范<ul><li>main函数参数规范如下:<ul><li>第一个参数为: <code>int</code>型, 表示参数的个数</li><li>第二个参数为: <code>char* 数组</code>, 每一个<code>char*</code>元素指向一个以字符串形式储存在内存中的参数的首地址, 其中第一个参数为程序的名字</li></ul></li></ul></li><li>函数调用过程如下:<ul><li>首先将参数以字符串的形式保存在内存中, 然后利用字符串起始字符指针组成char* 数组, 并计算参数的个数.</li><li>然后将进行函数调用, <ul><li>首先, 将参数逆序入栈, 也就是(参数指针数组, 参数个数)</li><li>然后返回地址入栈</li><li>然后调用则栈顶入栈</li><li>将当前栈顶设置为被调函数栈底, 并将栈底入栈</li><li>然后被调函数建立形参以及局部变量, 处理相应的逻辑</li></ul></li></ul></li></ul><h2 id="113、volatile-关键字的作用？"><a href="#113、volatile-关键字的作用？" class="headerlink" title="113、volatile 关键字的作用？"></a>113、<code>volatile</code> 关键字的作用？</h2><ul><li><code>volatile</code> 关键字是一种类型修饰符，被它修饰的变量拥有三大特性: 易变性, 不可优化性, 顺序性<ul><li>易变性: 编译器对<code>valatile</code>的访问总是从内存中读取数据, 即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li><li>不可优化性: <code>volatile</code>告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</li><li>顺序性: 保证<code>Volatile</code>变量间的顺序性，编译器不会进行乱序优化。<strong>但是可能会被CPU优化</strong></li></ul></li><li>声明时语法：<code>int volatile vInt</code>; </li><li><code>volatile</code> 用在如下的几个地方：<ol><li>中断服务程序中修改的供其它程序检测的变量需要加<code>volatile</code>；</li><li>多任务环境下各任务间共享的标志应该加<code>volatile</code>；</li><li>存储器映射的硬件寄存器通常也要加<code>volatile</code> 说明，因为每次对它的读写都可能由不同意义；</li></ol></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/god-of-death/p/7852394.html">C/C++ Volatile关键词深度剖析</a></li></ul><hr><h2 id="114、讲讲大端小端，如何检测-三种方法"><a href="#114、讲讲大端小端，如何检测-三种方法" class="headerlink" title="114、讲讲大端小端，如何检测(三种方法)"></a>114、讲讲大端小端，如何检测(三种方法)</h2><p>大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址端。<br>小端模式，是指数据的高字节保存在内存的高地址中，低位字节保存在在内存的低地址端。</p><ul><li>直接读取存放在内存中的十六进制数值，取低位进行值判断(在GCC中测试,不可行!)<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x12345678</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x12</span> 大端模式c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x78</span> 小段模式 </code></pre></li><li>用union来进行判断(union总是小端储存)<pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">union</span> w<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">union</span> w p<span class="token punctuation">;</span>p<span class="token punctuation">.</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">bool</span> flag <span class="token operator">=</span> p<span class="token punctuation">.</span>ch<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="115、查看内存的方法"><a href="#115、查看内存的方法" class="headerlink" title="115、查看内存的方法"></a>115、查看内存的方法</h2><ul><li>首先打开vs 编译器，创建好项目，并且将代码写进去，这里就不贴代码了，你可以随便的写个做个测试;</li><li>调试的时候做好相应的断点，然后点击开始调试;</li><li>程序调试之后会在你设置断点的地方暂停，然后选择调试-&gt;窗口-&gt;内存，就打开了内存数据查看的窗口了。</li></ul><h2 id="116、空类会默认添加哪些东西？怎么写？"><a href="#116、空类会默认添加哪些东西？怎么写？" class="headerlink" title="116、空类会默认添加哪些东西？怎么写？"></a>116、空类会默认添加哪些东西？怎么写？</h2><ul><li>默认构造函数</li><li>拷贝构造函数</li><li>析构函数</li><li>赋值运算符<code>(operator=)</code></li><li>两个取址运算符<code>(operator&amp;)</code>(<code>const</code>和<code>非const</code>)</li><li><strong>当然所有的这些函数都是需要才生成, 例如你都没使用过复制运算, 肯定不会生成的</strong></li></ul><hr><ul><li>参考:<a href="https://blog.csdn.net/bug07250432/article/details/10099453">编译一个空类会默认生成哪些函数?</a></li></ul><hr><h2 id="117、标准库是什么？"><a href="#117、标准库是什么？" class="headerlink" title="117、标准库是什么？"></a>117、标准库是什么？</h2><ol><li>C++ 标准库可以分为两部分:<ul><li><strong>标准函数库</strong>: 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自<code>C语言</code>。</li><li><strong>面向对象类库</strong>: 这个库是类及其相关函数的集合。</li></ul></li></ol><ul><li>标准函数库: 输入<code>/</code>输出<code>I/O</code>、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</li><li>面向对象类库: 标准的<code>C++</code> <code>I/O</code> 类、<code>String</code> 类、数值类、<code>STL</code> 容器类、<code>STL</code> 算法、<code>STL</code> 函数对象、<code>STL</code> 迭代器、<code>STL</code> 分配器、本地化库、异常处理类、杂项支持库</li></ul><h2 id="118、const-char-与string-之间的关系，传递参数问题？"><a href="#118、const-char-与string-之间的关系，传递参数问题？" class="headerlink" title="118、const char* 与string 之间的关系，传递参数问题？"></a>118、<code>const char*</code> 与<code>string</code> 之间的关系，传递参数问题？</h2><ul><li><code>string</code> 是<code>c++</code>标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用 <code>const char*</code>给<code>string</code> 类初始化</li><li>三者的转化关系如下所示：<ul><li><code>string</code> 转<code>const char*</code><pre class=" language-c"><code class="language-c">string s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><code>const char*</code> 转<code>string</code>，直接赋值即可<pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>string <span class="token function">s</span><span class="token punctuation">(</span>c_s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><code>string</code> 转<code>char*</code><pre class=" language-c"><code class="language-c">string s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><code>char*</code> 转<code>string</code><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> c <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>string <span class="token function">s</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><code>const char*</code> 转<code>char*</code><pre class=" language-c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cpc <span class="token operator">=</span> “abc”<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cpc<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span>cpc<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><code>char*</code> 转<code>const char*</code>，直接赋值即可<br>  ```c<br>  char* pc =</li></ul></li></ul><p>**** “abc”;<br>        const char* cpc = pc;<br>        ```</p><h2 id="119、new、delete、operator-new、operator-delete、placement-new、placement-delete"><a href="#119、new、delete、operator-new、operator-delete、placement-new、placement-delete" class="headerlink" title="119、new、delete、operator new、operator delete、placement new、placement delete"></a>119、<code>new</code>、<code>delete</code>、<code>operator new</code>、<code>operator delete</code>、<code>placement new</code>、<code>placement delete</code></h2><ul><li><code>new operator</code><ul><li><code>new operator</code> 完成了两件事情：用于<strong>申请内存</strong>和<strong>初始化对象</strong>。</li><li>例如：<code>string* ps = new string(&quot;abc&quot;)</code>;</li></ul></li><li><code>operator new</code><ul><li><code>operator new</code> 类似于<code>C</code> 语言中的<code>malloc</code>，只是负责申请内存。</li><li>例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> buffer <span class="token operator">=</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意这里new 前要有个operator。</span></code></pre></li></ul></li><li><code>placement new</code><ul><li>用于在给定的内存中初始化对象。</li><li>例如：<pre class=" language-c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> buffer <span class="token operator">=</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li>调用了<code>placement new</code>，在<code>buffer</code> 所指向的内存中创建了一个<code>string</code> 类型的对象并且初始值为“<code>abc</code>”。</li></ul></li></ul><hr><ul><li>因此可以看出：<ul><li><code>new operator</code> 可以分解<code>operator new</code> 和<code>placement new</code> 两个动作，是<code>operator new</code> 和<code>placement new</code> 的结合。</li></ul></li><li>与<code>new</code> 对应的<code>delete</code> 没有<code>placement delete</code> 语法<ul><li>它只有两种，分别是<code>delete operator</code> 和<code>operator delete</code>。</li><li><code>delete operator</code> 和<code>new operator</code> 对应，完成<strong>析构对象</strong>和<strong>释放内存</strong>的操作。</li><li>而<code>operator delete</code> 只是用于<strong>内存的释放</strong>，与<code>C语言</code>中的<code>free</code> 相似。</li></ul></li></ul><hr><h2 id="120、为什么拷贝构造函数必须传引用不能传值？"><a href="#120、为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="120、为什么拷贝构造函数必须传引用不能传值？"></a>120、为什么拷贝构造函数必须传<code>引用</code>不能<code>传值</code>？</h2><ul><li><p>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</p></li><li><p>两种不同的参数传递方式：</p></li><li><p>值传递:</p><ul><li>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)； </li><li>如<code>void foo(class_type obj_local)&#123;&#125;</code>, 如果调用<code>foo(obj)</code>; 首先<code>class_type obj_local(obj)</code> ,这样就定义了局部变量<code>obj_local</code> 供函数内部使用</li></ul></li><li><p>引用传递:</p><ul><li>无论对内置类型还是类类型，传递引用或指针最终都是传递的<strong>地址值</strong>！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).</li></ul></li></ul><hr><ul><li>拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</li><li>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</li></ul><hr><h2 id="121、空类的大小是多少？为什么？"><a href="#121、空类的大小是多少？为什么？" class="headerlink" title="121、空类的大小是多少？为什么？"></a>121、空类的大小是多少？为什么？</h2><ul><li><code>C++</code>空类的大小不为<code>0</code>，不同编译器设置不一样，<code>vs</code> 设置为<code>1</code>；</li><li><code>C++</code>标准指出，不允许一个对象(当然包括类对象)的大小为<code>0</code>，<strong>因为不同的对象不能具有相同的地址</strong>；</li><li>带有虚函数的<code>C++</code>类大小不为<code>1</code>，因为每一个对象会有一个<code>vptr</code> 指向虚函数表，具体大小根据指针大小确定；</li><li><code>C++</code>中要求对于类的每个实例都必须有独一无二的地址,那么<strong>编译器自动为空类分配一个字节大小</strong>，这样便保证了每个实例均有独一无二的内存地址。</li></ul><h2 id="122、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#122、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="122、你什么情况用指针当参数，什么时候用引用，为什么？"></a>122、你什么情况用指针当参数，什么时候用引用，为什么？</h2><ul><li>使用引用参数的主要原因有两个：<ul><li>程序员能<strong>修改</strong>调用函数中的数据对象</li><li>通过传递引用而不是整个数据–对象，可以提高程序的<strong>运行速度</strong></li></ul></li><li>一般的原则：<ul><li>对于使用数据对象不做修改的函数：<ul><li>如果数据对象很<code>小(内置数据类型或者小型结构)</code>，则按<strong>照值传递</strong>；</li><li>如果数据对象是<code>数组</code>，则使用指针 <strong>(唯一的选择)**，并且指针声明为 **<code>const</code> 的指针</strong>；</li><li>如果数据对象是<code>较大的结构</code>，则使用 <strong><code>const</code> 指针或者引用</strong>，已提高程序的效率。这样可以节省结构所需的时间和空间；</li><li>如果数据对象是<code>类对象</code>，则使用 <strong><code>const</code> 引用</strong>(传递类对象参数的标准方式是按照引用传递)；</li></ul></li><li>对于修改函数中数据的函数：<ul><li>如果数据是<code>内置数据类型</code>，则使用<strong>指针</strong></li><li>如果数据对象<code>是数组</code>，则只能使用<strong>指针</strong></li><li>如果数据对象是<code>结构</code>，则使用<strong>引用或者指针</strong></li><li>如果数据是<code>类对象</code>，则使用<strong>引用</strong></li></ul></li></ul></li></ul><h2 id="123、大内存申请时候选用哪种？C-变量存在哪？变量的大小存在哪？符号表存在哪？"><a href="#123、大内存申请时候选用哪种？C-变量存在哪？变量的大小存在哪？符号表存在哪？" class="headerlink" title="123、大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"></a>123、大内存申请时候选用哪种？<code>C++</code>变量存在哪？变量的大小存在哪？符号表存在哪？</h2><ul><li>大内存申请时，采用堆申请空间，用<code>new</code> 申请， 当大于<code>128K</code>的时候会在映射区分配内存.</li><li>变量存储位置:<ul><li>全局变量</li><li>静态变量</li><li>局部变量</li><li>堆对象:大, 小</li></ul></li><li>符号表只存在于编译阶段, 符号表的每一项分别对应变量名和变量地址, 但是<code>C++</code>对变量名不作存储，在汇编以后不会出现变量名，变量名作用只是用于方便编译成汇编代码，是给编译器看的，是方便人阅读的</li></ul><h2 id="124、为什么会有大端小端，htol-这一类函数的作用"><a href="#124、为什么会有大端小端，htol-这一类函数的作用" class="headerlink" title="124、为什么会有大端小端，htol 这一类函数的作用"></a>124、为什么会有大端小端，<code>htol</code> 这一类函数的作用</h2><ul><li><p>计算机以字节为基本单位进行管理, 每个地址单元都对应着一个字节，一个字节为<code>8bit</code>。但是我们常用到大于一个字节的数据类型, 例如<code>short</code>, <code>int</code>, <code>float</code>等, 此时就会存在字节如何放置的问题, 从而出现了大端模式和小端模式. </p></li><li><p>大端: 低字节放于高地址处(网络字节序为大端)</p></li><li><p>小端: 低字节放于低地址处(通常主机字节序为小端)</p></li><li><p>例如(<code>16bit</code> 的<code>short型 x</code>)</p><ul><li>在内存中的地址为<code>0x0010</code>，<code>x</code>的值为<code>0x1122</code>，那么<code>0x11</code> 为高字节，<code>0x22</code> 为低字节。</li><li>对于大端模式，就将<code>0x11</code> 放在低地址中，即<code>0x0010</code> 中，<code>0x22</code> 放在高地址中，即<code>0x0011</code> 中。小端模式，刚好相反。</li></ul></li></ul><h2 id="125、静态函数能定义为虚函数吗？常函数"><a href="#125、静态函数能定义为虚函数吗？常函数" class="headerlink" title="125、静态函数能定义为虚函数吗？常函数?"></a>125、静态函数能定义为虚函数吗？常函数?</h2><ul><li><p>不能 !</p><ul><li><code>static</code>成员不属于任何类对象或类实例，没有this指针(静态与非静态成员函数的一个主要区别)。</li><li>虚函数调用链为: <code>vptr</code> -&gt; <code>vtable</code> -&gt; <code>virtual function</code></li><li>但是访问<code>vptr</code>需要使用<code>this</code>指针但是<code>static</code>成员函数没有<code>this</code>指针, 从而无法实现虚函数的调用</li></ul><hr><ul><li>虚函数依靠<code>vptr</code> 和<code>vtable</code> 来处理。<code>vptr</code> 是一个指针，在类的构造函数中创建生成，并且只能用<code>this</code> 指针来访问它，因为它是类的一个成员，并且<code>vptr</code> 指向保存虚函数地址的<code>vtable.</code>对于静态成员函数，它没有<code>this</code>指针，所以无法访问<code>vptr.</code> 这就是为何<code>static</code> 函数不能为<code>virtual.</code>虚函数的调用关系：<code>this</code> -&gt; <code>vtable</code> -&gt; <code>virtual function</code></li></ul></li></ul><h2 id="126、this-指针调用成员变量时，堆栈会发生什么变化？"><a href="#126、this-指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="126、this 指针调用成员变量时，堆栈会发生什么变化？"></a>126、<code>this</code> 指针调用成员变量时，堆栈会发生什么变化？</h2><ul><li>当我们在类中定义非静态成员函数时, 编译器会为此成员函数添加一个参数(最后一个形参), 类型为当前类型的指针</li><li>当我们进行通过对象或则对象指针调用此成员函数时, 编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是<code>this</code>指针。即使你并没有写<code>this</code> 指针，编译器在链接时也会加上<code>this</code> 的，对各成员的访问都是通过<code>this</code> 的。</li><li>函数调用时, <code>this</code>指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</li></ul><h2 id="127、静态绑定和动态绑定的介绍"><a href="#127、静态绑定和动态绑定的介绍" class="headerlink" title="127、静态绑定和动态绑定的介绍"></a>127、<strong>静态绑定</strong>和<strong>动态绑定</strong>的介绍</h2><ul><li><p>对象的静态类型：<strong>对象在声明时采用的类型</strong>。是在编译期确定的。</p></li><li><p>对象的动态类型：<strong>目前所指对象的类型</strong>。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p></li><li><p>静态绑定：绑定的是对象的静态类型，某特性(比如函数)依赖于对象的静态类型，发生在编译期。</p></li><li><p>动态绑定：绑定的是对象的动态类型，某特性(比如函数)依赖于对象的动态类型，发生在运行期。</p></li></ul><h2 id="128、设计一个类计算子类的个数"><a href="#128、设计一个类计算子类的个数" class="headerlink" title="128、设计一个类计算子类的个数"></a>128、设计一个类计算子类的个数</h2><ul><li>为类设计一个<code>static</code> 静态变量<code>count</code> 作为计数器；</li><li>类定义结束后初始化<code>count</code>;</li><li>在构造函数中对<code>count</code> 进行<code>+1</code>;</li><li>设计拷贝构造函数，在进行拷贝构造函数中进行<code>count +1</code>，操作；</li><li>设计复制构造函数，在进行复制函数中对<code>count+1</code> 操作；</li><li>在析构函数中对<code>count</code> 进行<code>-1</code>；</li></ul><h2 id="129、怎么快速定位错误出现的地方"><a href="#129、怎么快速定位错误出现的地方" class="headerlink" title="129、怎么快速定位错误出现的地方"></a>129、怎么快速定位错误出现的地方</h2><ul><li>如果是简单错误, 通常可以分析编译器辗转解栈过程, 定位到输出位置, 通常都是解栈的靠后位置</li><li>如果错误较复杂, 就最好使用gdb调试模式, 进行调试, 逐步定位错误位置, 或者添加更多的输出信息.</li></ul><h2 id="130、虚函数的代价？"><a href="#130、虚函数的代价？" class="headerlink" title="130、虚函数的代价？"></a>130、虚函数的代价？</h2><pre><code>1) 带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；</code></pre><ol><li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；</li><li><strong>不能再是内敛的函数</strong>，因为内敛函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内敛函数。</li></ol><h2 id="131、类对象的大小"><a href="#131、类对象的大小" class="headerlink" title="131、类对象的大小"></a>131、类对象的大小</h2><ol><li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li><li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li><li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li><li>虚函数的话，会在类对象插入vptr 指针，加上指针大小；</li><li>如果是虚拟继承而来的话, 还会存在一个虚基类表指针, 不同的编译器对这个虚基类指针的处理是不一样的, gcc是存放在虚函数表中(意味着虚函数表指针和虚基类表指针只会存在一个), vc是存放在对象中的(意味着可能会虚函数表指针和虚基类表指针共存)</li></ol><h2 id="132、移动构造函数"><a href="#132、移动构造函数" class="headerlink" title="132、移动构造函数"></a>132、移动构造函数</h2><ul><li>移动构造函数是C++11中引入的移动语义的具体实现. 它的主要目的是避免无谓的构造和析构</li><li>例如: 当我们用右值初始化一个左值时, 通常是使用复制构造函数构造左值,然后对右值调用析构函数, 此时存在大量的浪费. 而且复制构造函数对于指针通常是浅复制, 容易产生野指针.</li><li>移动构造函数的参数为右值引用, 它的作用就是将此右值的内容<strong>转移</strong>到左值内, 从而避免右值调用构造函数. 也避免了左值分配内存进行构造. <pre class=" language-cpp"><code class="language-cpp"><span class="token function">Example6</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">ptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    x<span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// move assignment</span>Example6<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> x<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>    x<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="133、何时需要合成构造函数"><a href="#133、何时需要合成构造函数" class="headerlink" title="133、何时需要合成构造函数"></a>133、何时需要合成构造函数</h2><ul><li>如果一个类没有构造函数，一共四种情况会合成构造函数:<ul><li><strong>存在虚函数</strong>的情况</li><li><strong>存在虚基类</strong>的情况</li><li><strong>基类成员</strong>存在构造函数的情况</li><li><strong>对象成员对象</strong>存在构造函数的情况</li></ul></li></ul><h2 id="134、何时需要合成复制构造函数"><a href="#134、何时需要合成复制构造函数" class="headerlink" title="134、何时需要合成复制构造函数"></a>134、何时需要合成复制构造函数</h2><ul><li><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p><ol><li>对一个对象做显示的初始化操作，<code>X xx = x;</code></li><li>当对象被当做参数交给某个函数时；</li><li>当函数传回一个类对象时；</li></ol></li><li><p>如果一个类没有拷贝构造函数，合成复制构造函数的情况:</p><ul><li>成员对象有拷贝构造函数</li><li>基类拷贝构造函数</li><li>存在虚函数</li><li>存在虚基类</li></ul></li></ul><h2 id="135、何时需要成员初始化列表？过程是什么？"><a href="#135、何时需要成员初始化列表？过程是什么？" class="headerlink" title="135、何时需要成员初始化列表？过程是什么？"></a>135、何时需要成员初始化列表？过程是什么？</h2><ul><li>需要成员初始化列表:<ul><li>引用类型的成员变量</li><li>const类型的成员变量</li><li>基类不存在零参数构造函数</li><li>成员对象不存在零参数构造函数</li></ul></li><li>过程: <ul><li>编译器会根据成员变量定义顺序一一初始化成员变量, 如果相应成员在成员初始化列表中有初始化参数, 则用成员初始化列表中的参数进行构造</li><li>发生在用户自定义代码段之前. </li></ul></li></ul><h2 id="136、程序员定义的析构函数被扩展的过程？"><a href="#136、程序员定义的析构函数被扩展的过程？" class="headerlink" title="136、程序员定义的析构函数被扩展的过程？"></a>136、程序员定义的析构函数被扩展的过程？</h2><ul><li>析构函数的执行顺序(和构造相反):<ul><li>析构函数函数体被执行</li><li>本类的成员对象析构函数被调用, 调用顺序和声明的顺序相反</li><li>非虚基类拥有析构函数，会以声明的相反顺序被调用；</li><li>虚基类被析构</li></ul></li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/haoyuanyuan/archive/2013/04/25/3041250.html">C++虚基类构造函数详解(调用顺序)之一</a></li></ul><hr><h2 id="137、构造函数的执行算法？"><a href="#137、构造函数的执行算法？" class="headerlink" title="137、构造函数的执行算法？"></a>137、构造函数的执行算法？</h2><ul><li><p>扩展过程:</p><ul><li>虚基类按照定义顺序被构造</li><li>基类按照定义顺序被构造</li><li>成员变量被构造</li><li>执行程序员所提供的代码</li></ul></li><li><p>一个类被构造的执行过程:</p><ul><li>虚基类按照定义顺序被构造</li><li>基类按照定义顺序被构造</li><li>然后是按照定义顺序构造成员变量, 如果某个成员在初始化成员变量列表内存在初始化参数, 则调用初始化成员变量列表内的参数初始化该成员变量</li><li>然后是执行构造函数函数体内用户提供的代码.</li></ul></li><li><p>注意事项:</p><ul><li>在构造函数函数体内的对虚函数的调用将不具备动态绑定的特性</li></ul></li></ul><hr><ul><li>参考:<ul><li><a href="https://blog.csdn.net/qingdujun/article/details/26626605">C++ 构造函数执行原理</a></li><li><a href="https://www.cnblogs.com/sylar5/p/11523992.html">构造函数和析构函数中可以调用调用虚函数吗</a></li></ul></li></ul><hr><h2 id="138、构造函数的扩展过程？"><a href="#138、构造函数的扩展过程？" class="headerlink" title="138、构造函数的扩展过程？"></a>138、构造函数的扩展过程？</h2><ul><li>虚基类按照定义顺序被构造</li><li>基类按照定义顺序被构造</li><li>成员变量被构造</li><li>执行程序员所提供的代码</li></ul><hr><ul><li>参考: <a href="https://www.cnblogs.com/sylar5/p/11523992.html">构造函数和析构函数中可以调用调用虚函数吗</a></li></ul><hr><h2 id="139、哪些函数不能是虚函数"><a href="#139、哪些函数不能是虚函数" class="headerlink" title="139、哪些函数不能是虚函数"></a>139、哪些函数不能是虚函数</h2><ul><li>构造函数: 首先是没必要使用虚函数, 其次不能使用虚函数</li><li>内联函数: 表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</li><li>静态函数: 静态函数不属于对象属于类，静态成员函数没有this 指针，因此静态函数设置为虚函数没有任何意义。</li><li>友元函数: 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li><li>普通函数: 普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</li></ul><hr><ul><li>参考: <a href="#19%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0">19. 构造函数为什么不能为虚函数？析构函数为什么要虚函数？</a></li></ul><hr><h2 id="140-sizeof-和strlen-的区别"><a href="#140-sizeof-和strlen-的区别" class="headerlink" title="140. sizeof 和strlen 的区别"></a>140. <code>sizeof</code> 和<code>strlen</code> 的区别</h2><ul><li><code>sizeof</code> 是一个<strong>取字节运算符</strong>，计算变量所占的内存数(字节大小), 可以用于任意类型</li><li><code>strlen</code> 是个<strong>函数</strong>, 计算字符串的具体长度(只能是字符串)，不包括字符串结束符(<code>\0</code>)。</li><li><code>strlen</code> 是个不安全的函数, 如果没有<code>\0</code>将会发生段错误。</li><li><code>sizeof</code>和<code>strlen</code>对同一个字符串求值, 结果差一.</li><li>数组做<code>sizeof</code> 的参数不退化，传递给<code>strlen</code>就退化为指针；</li></ul><h2 id="141、简述strcpy、sprintf-与memcpy-的区别"><a href="#141、简述strcpy、sprintf-与memcpy-的区别" class="headerlink" title="141、简述strcpy、sprintf 与memcpy 的区别"></a>141、简述<code>strcpy</code>、<code>sprintf</code> 与<code>memcpy</code> 的区别</h2><ul><li>复制操作: <code>strcpy</code>, <code>memcpy</code><ul><li>复制类容不一样: <code>strcpy</code>是用于复制字符串的, 不能用去其他类型, 而<code>memcpy</code>是用于复制任意类型的数据类型</li><li>复制防止不一样: <code>strcpy</code>是通过检测支付中的<code>\0</code>判断结束的, 存在溢出风险<code>(strncpy)</code>; 而<code>memcpy</code>是需要指定复制的字节数的.</li></ul></li><li>字符串格式化: <code>sprintf</code><ul><li>将格式化的数据写入字符串中</li><li>注意<code>sprintf</code>对写入字符串没有限制大小, 也就存在溢出风险, 建议采用<code>snprintf</code></li></ul></li></ul><h2 id="142、编码实现某一变量某位清0-或置1"><a href="#142、编码实现某一变量某位清0-或置1" class="headerlink" title="142、编码实现某一变量某位清0 或置1"></a>142、编码实现某一变量某位清<code>0</code> 或置<code>1</code></h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">define</span> BIT3 (0x1 &lt;&lt; 3 ) Satic int a;</span><span class="token comment" spellcheck="true">//设置a 的bit 3:</span><span class="token keyword">void</span> <span class="token function">set_bit3</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    a <span class="token operator">|</span><span class="token operator">=</span> BIT3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将a 第3 位置1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//清a 的bit 3</span><span class="token keyword">void</span> <span class="token function">set_bit3</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    a <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>BIT3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将a 第3 位清零</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="143、将“引用”作为函数参数有哪些特点？"><a href="#143、将“引用”作为函数参数有哪些特点？" class="headerlink" title="143、将“引用”作为函数参数有哪些特点？"></a>143、将“引用”作为函数参数有哪些特点？</h2><ol><li>传递引用给函数与传递指针的效果是一样的。<ol><li>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象(在主调函数中)的操作。</li></ol></li><li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；<ol><li>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</li><li>如果传递的是对象，还将调用拷贝构造函数。</li><li>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</li></ol></li><li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；<ol><li>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</li></ol></li></ol><hr><ul><li>引用传递 从逻辑上就好像是对主调函数中的实参取了一个别名, 在被调函数中对该别名的任何操作都会反应在主调函数中, 实际的实现过程中, 传递的其实是对象的地址, 和指针传递相似, 区别在于对该引用的任何操作都会被处理为间接寻址</li><li>引用传递 并没有对<code>对象</code>进行拷贝, 只是对指针进行了拷贝, 避免了对<code>对象</code>的复制, 效率更高.</li><li>引用传递 逻辑上相当于对主调函数中的实参取了一个别名, 阅读性更好.</li></ul><hr><h2 id="144、分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。"><a href="#144、分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。" class="headerlink" title="144、分别写出BOOL,int,float, 指针类型的变量a 与“零”的比较语句。"></a>144、分别写出<code>BOOL</code>,<code>int</code>,<code>float</code>, 指针类型的变量<code>a</code> 与“零”的比较语句。</h2><pre class=" language-cpp"><code class="language-cpp">BOOL <span class="token operator">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>a <span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">int</span> <span class="token operator">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">float</span> <span class="token operator">:</span> <span class="token keyword">const</span> EXPRESSION EXP <span class="token operator">=</span> <span class="token number">0.000001</span> <span class="token comment" spellcheck="true">// 1.0e-10 浮点数有精度限制, 所以只能通过阈值来判断是否相等</span><span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">&lt;</span> EXP <span class="token operator">&amp;&amp;</span> a <span class="token operator">></span><span class="token operator">-</span>EXP<span class="token punctuation">)</span>pointer <span class="token operator">:</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> a <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></code></pre><h2 id="145、局部变量全局变量的问题？"><a href="#145、局部变量全局变量的问题？" class="headerlink" title="145、局部变量全局变量的问题？"></a>145、局部变量全局变量的问题？</h2><ul><li>局部会屏蔽全局。<ul><li>要用全局变量，需要使用”::”, 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。</li><li>对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。</li></ul></li><li>如何引用一个已经定义过的全局变量，可以用引用头文件的方式，也可以用<code>extern</code>关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用<code>extern</code> 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。</li><li>全局变量可不可以定义在可被多个<code>.C</code> 文件包含的头文件中，在不同的<code>C</code> 文件中以<code>static</code> 形式来声明同名全局变量。可以在不同的<code>C</code> 文件中声明同名的全局变量，前提是其中只能有一个<code>C</code> 文件中对此变量赋初值，此时连接不会出错</li></ul><hr><ul><li>局部屏蔽全局</li><li>引用另一个文件中的变量, 使用<code>extern</code>关键字, 或则引用头文件</li><li>全局变量冲突</li></ul><hr><h2 id="146、数组和指针的区别？"><a href="#146、数组和指针的区别？" class="headerlink" title="146、数组和指针的区别？"></a>146、数组和指针的区别？</h2><ul><li>对数组使用<code>sizeof</code>操作符可以计算出数组的容量(字节数). 对指针使用<code>sizeof</code>操作符得到的是一个指针变量的字节数，而不是<code>p</code> 所指的内存容量。</li><li>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</li><li>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</li><li>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</li></ul><hr><ul><li>数组作为<code>sizeof</code>参数时, 不会退化</li><li>数组在内存中是连续存放的，开辟一块连续的内存空间；<ul><li>数组所占存储空间：<code>sizeof(</code>数组名)；</li><li>数组大小：<code>sizeof(</code>数组名<code>)/sizeof(</code>数组元素数据类型)；</li></ul></li><li>指针也可以使用下标, 表示指针指向地址<code>+</code>偏移<ul><li>参考: <a href="https://blog.csdn.net/qianxuedegushi/article/details/81699033">C语言指针变量加下标的作用意思意义</a></li></ul></li></ul><hr><h2 id="147、C-如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"><a href="#147、C-如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？" class="headerlink" title="147、C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？"></a>147、C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private？</h2><ol><li>将类定义为<code>抽象基类</code>或者将<code>构造函</code>数声明为<code>private</code>；</li><li>不允许类外部创建类对象(也就是杜绝了静态构建的可能性)，只能在类内部创建对象(成员函数通过<code>new</code>构建)</li></ol><h2 id="148、如何禁止自动生成拷贝构造函数？"><a href="#148、如何禁止自动生成拷贝构造函数？" class="headerlink" title="148、如何禁止自动生成拷贝构造函数？"></a>148、如何禁止自动生成拷贝构造函数？</h2><ol><li>为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用。</li><li>类的成员函数和friend 函数还是可以调用private 函数，如果这个private 函数只声明不定义，则会产生一个连接错误；</li><li>针对上述两种情况，我们可以定一个base 类，在base 类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base 类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。</li></ol><ul><li>参考: <a href="https://blog.csdn.net/qq_29422251/article/details/77850312">高效C++; 条款6：阻止编译器自动生成拷贝构造函数和赋值函数</a></li></ul><hr><ol><li>拷贝构造函数的定义后面使用 <code>=delete</code>关键字</li><li>将<code>base</code>类的拷贝构造函数和拷贝赋值构造函数设置为<code>private</code>, 这样编译器就不会自动生成这两个函数, 且由于<code>base</code>类的该函数为<code>private</code>, 所以编译器会阻止相关操作. </li></ol><h2 id="149、assert-与NDEBUG"><a href="#149、assert-与NDEBUG" class="headerlink" title="149、assert 与NDEBUG"></a>149、<code>assert</code> 与<code>NDEBUG</code></h2><ol><li><code>assert</code> 宏的原型定义在<code>&lt;assert.h&gt;</code>中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：<pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token keyword">void</span> <span class="token function">assert</span><span class="token punctuation">(</span> <span class="token keyword">int</span> expression <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>assert</code> 的作用是计算表达式<code>expression</code> ，如果其值为假(即为<code>0</code>)，那么它先向<code>stderr</code> 打印一条出错信息，然后通过调用<code>abort</code> 来终止程序运行。如果表达式为真，<code>assert</code> 什么也不做。</li></ul></li><li><code>NDEBUG</code> 宏是<code>Standard C</code> 中定义的宏，专门用来控制<code>assert()</code>的行为。<ul><li>如果定义了这个宏，则<code>assert</code> 不会起作用。</li><li>定义<code>NDEBUG</code> 能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。</li></ul></li></ol><h2 id="150、Debug-和release-的区别"><a href="#150、Debug-和release-的区别" class="headerlink" title="150、Debug 和release 的区别"></a>150、<code>Debug</code> 和<code>release</code> 的区别</h2><ol><li>调试版本，包含调试信息<ul><li><code>体积</code>比<code>Release</code> 大很多，并且<code>不进行任何优化</code>(优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂)，便于程序员调试。</li><li><code>Debug</code> 模式下生成两个文件，除了<code>.exe</code> 或<code>.dll</code> 文件外，还有一个<code>.pdb</code> 文件，该文件记录了代码中断点等调试信息；</li></ul></li><li>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。(调试信息可在单独的<code>PDB</code> 文件中生成)。<code>Release</code> 模式下生成一个文件<code>.exe</code> 或<code>.dll</code> 文件。</li><li>实际上，<code>Debug</code> 和<code>Release</code> 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</li></ol><h2 id="151、main-函数有没有返回值"><a href="#151、main-函数有没有返回值" class="headerlink" title="151、main 函数有没有返回值"></a>151、<code>main</code> 函数有没有返回值</h2><ol><li>程序运行过程入口点<code>main</code>函数，<code>main()</code>函数返回值类型必须是<code>int</code>，这样返回值才能传递给程序激活者(如操作系统)表示程序正常退出。</li><li><code>main(int args, char**argv)</code>参数的传递。参数的处理，一般会调用<code>getopt()</code>函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</li><li><code>main</code>函数事调用用户代码逻辑的接口有着固有的规范(或则逻辑):<ul><li>返回值: <code>int</code> 程序退出状态</li><li>参数: 用于传递到用户代码中<ul><li><code>int args</code>: 参数个数</li><li><code>char** argv</code>: 参数以字符串的形式储存, 然后将字符串首地址组成指针数组作为参数进行传递.</li></ul></li></ul></li></ol><hr><ul><li>参考: <a href="https://www.cnblogs.com/chenliyang/p/6633739.html">命令行选项解析函数(C语言)：getopt()和getopt_long()</a></li></ul><hr><h2 id="152、写一个比较大小的模板函数"><a href="#152、写一个比较大小的模板函数" class="headerlink" title="152、写一个比较大小的模板函数"></a>152、写一个比较大小的模板函数</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> type1<span class="token punctuation">,</span><span class="token keyword">typename</span> type2<span class="token operator">></span><span class="token comment" spellcheck="true">//函数模板</span>type1 <span class="token function">Max</span><span class="token punctuation">(</span>type1 a<span class="token punctuation">,</span>type2 b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Max = "</span><span class="token operator">&lt;&lt;</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="153、c-怎么实现一个函数先于main-函数运行"><a href="#153、c-怎么实现一个函数先于main-函数运行" class="headerlink" title="153、c++怎么实现一个函数先于main 函数运行"></a>153、<code>c++</code>怎么实现一个函数先于main 函数运行</h2><ol><li>全局对象/全局静态变量的生存期和作用域都高于<code>mian</code>函数, 在<code>main</code>函数之前初始化</li></ol><pre class=" language-c++"><code class="language-c++">    class simpleClass&#123;    public:        simpleClass( )&#123;            cout << "simpleClass constructor.." << endl;        &#125;    &#125;;    simpleClass g_objectSimple; //step1 全局对象    int _tmain(int argc, _TCHAR* argv[]) &#123; //step3        return 0;    &#125;</code></pre><ol start="2"><li>GCC编译器可以使用<code>__attribute((constructor/deconstrucor))</code>在<code>main</code><strong>之前</strong>和<strong>之后</strong>注册函数<pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 在main之前</span><span class="token function">__attribute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">before_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"befor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在main之后</span><span class="token function">__attribute</span><span class="token punctuation">(</span><span class="token punctuation">(</span>deconstructor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">after_main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"befor\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><hr><ul><li>附加<ul><li><code>Main</code> 函数执行之前，主要就是初始化系统相关资源；<ul><li>设置栈指针</li><li>初始化<code>static</code> 静态和<code>global</code> 全局变量，即<code>data</code> 段的内容</li><li>将未初始化部分的全局变量赋初值(即<code>.bss</code> 段的内容)：<ul><li>数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，</li><li><code>bool</code> 为<code>FALSE</code></li><li>指针为<code>NULL</code></li></ul></li><li>全局对象初始化，在<code>main</code> 之前调用构造函数</li><li>将<code>main</code> 函数的参数，<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li></ul></li><li><code>Main</code> 函数执行之后<ul><li>全局对象的析构函数会在<code>main</code>函数之后执行；</li><li>可以用<code>_onexit</code>注册一个函数，它会在<code>main</code>之后执行;</li></ul></li></ul></li><li>参考: <ul><li><a href="https://blog.csdn.net/zzxiaozhao/article/details/102604626#main_228">在main()之前执行前运行</a></li><li><a href="https://blog.csdn.net/cafuc46wingw/article/details/38587473">C++中_onexit()用法简述</a></li></ul></li></ul><hr><h2 id="154、虚函数与纯虚函数的区别在于"><a href="#154、虚函数与纯虚函数的区别在于" class="headerlink" title="154、虚函数与纯虚函数的区别在于"></a>154、虚函数与纯虚函数的区别在于</h2><ol><li>纯虚函数只有定义没有实现，虚函数既有定义又有实现；</li><li>含有纯虚函数的类不能定义对象，含有虚函数的类能定义对象；</li></ol><h2 id="155、智能指针怎么用？智能指针出现循环引用怎么解决？"><a href="#155、智能指针怎么用？智能指针出现循环引用怎么解决？" class="headerlink" title="155、智能指针怎么用？智能指针出现循环引用怎么解决？"></a>155、智能指针怎么用？智能指针出现循环引用怎么解决？</h2><ol><li><p><code>unique_ptr</code>: 独占式拥有一个对象, 当<code>unique_ptr</code>被销毁时，它所指向的对象也被销毁。</p></li><li><p><code>shared_ptr</code>: </p><ul><li>初始化:<ul><li><code>shared_ptr&lt;int&gt; p =make_shared&lt;int&gt;(42);</code></li><li>通常用<code>auto</code>更方便，<code>auto p =make_shared&lt;int&gt;(42);</code></li><li><code>shared_ptr&lt;int&gt; p2(new int(2));</code></li></ul></li><li>每个<code>shared_ptr</code>都有一个关联的计数器，通常称为引用计数，一旦一个<code>shared_ptr</code>的计数器变为<code>0</code>，它就会自动释放自己所管理的对象；</li><li><code>shared_ptr</code>的析构函数就会递减它所指的对象的引用计数。</li><li>如果引用计数变为<code>0</code>，<code>shared_ptr</code> 的析构函数就会销毁对象，并释放它占用的内存。</li></ul></li><li><p><code>weak_ptr</code>:是一种不控制所指向对象生存期的智能指针，它指向由一个<code>shared_ptr</code>管理的对象，将一个<code>weak_ptr</code> 绑定到一个<code>shared_ptr</code> 不会改变引用计数，一旦最后一个指向对象的<code>shared_ptr</code> 被销毁，对象就会被释放，即使有<code>weak_ptr</code> 指向对象，对象还是会被释放。</p></li><li><p>弱指针用于专门解决<code>shared_ptr</code> 循环引用的问题，<code>weak_ptr</code> 不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个<code>shared_ptr</code> 成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p></li></ol><h2 id="156、strcpy-函数和strncpy-函数的区别？哪个函数更安全？"><a href="#156、strcpy-函数和strncpy-函数的区别？哪个函数更安全？" class="headerlink" title="156、strcpy 函数和strncpy 函数的区别？哪个函数更安全？"></a>156、<code>strcpy</code> 函数和<code>strncpy</code> 函数的区别？哪个函数更安全？</h2><ol><li>函数原型<pre class=" language-c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> strDest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strSrc<span class="token punctuation">)</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> strDest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strSrc<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span></code></pre></li><li><code>strcpy</code> 函数: <ul><li>如果参数<code>dest</code> 所指的内存空间不够大，可能会造成缓冲溢出<code>(bufferOverflow)</code>的错误情况，在编写程序时请特别留意，或者用<code>strncpy()</code>来取代。</li><li><code>strncpy</code> 函数：用来复制源字符串的前<code>n</code> 个字符，<code>src</code> 和<code>dest</code> 所指的内存区域不能重叠，且<code>dest</code> 必须有足够的空间放置<code>n</code> 个字符。</li></ul></li><li>长度关系:<ul><li>如果<code>目标长</code>&gt;<code>指定长</code>&gt;<code>源长</code>，则将源长全部拷贝到目标长，自动加上<code>\0</code>; </li><li>如果<code>指定长</code>&lt;<code>源长</code>，则将源长中按指定长度拷贝到目标字符串，不包括<code>\0</code>; </li><li>如果<code>指定长</code>&gt;<code>目标长</code>，运行时错误；</li></ul></li></ol><h2 id="157、为什么要用static-cast转换而不用c语言中的转换？"><a href="#157、为什么要用static-cast转换而不用c语言中的转换？" class="headerlink" title="157、为什么要用static_cast转换而不用c语言中的转换？"></a>157、为什么要用<code>static_cast</code>转换而不用<code>c</code>语言中的转换？</h2><ol><li>更加安全；</li><li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；<ul><li>可清楚地辨别代码中每个显式的强制转；</li><li>可读性更好，能体现程序员的意图</li></ul></li></ol><h2 id="158、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#158、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="158、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>158、成员函数里<code>memset(this,0,sizeof(*this))</code>会发生什么</h2><ol><li>如果类中的所有成员都是内置的数据类型的, 则不会存在问题</li><li>如果有以下情况之一会出现问题:<ul><li>存在对象成员</li><li>存在虚函数/虚基类</li><li>如果在构造函数中分配了堆内存, 而此操作可能会产生内存泄漏</li></ul></li></ol><h2 id="159、方法调用的原理-栈，汇编"><a href="#159、方法调用的原理-栈，汇编" class="headerlink" title="159、方法调用的原理(栈，汇编)"></a>159、方法调用的原理(栈，汇编)</h2><ul><li>每一个函数都对应一个栈帧: <ul><li>帧栈可以认为是程序栈的一段</li><li>它有两个端点<ul><li>一个标识起始地址, 开始地址指针ebp;</li><li>一个标识着结束地址，结束地址指针esp;</li></ul></li></ul></li><li>函数调用使用的参数, 返回地址等都是通过栈来传递的.</li><li>函数调用过程:<ul><li>参数逆序入栈(主调函数)</li><li>返回地址入栈(主调函数)(被调函数栈底往上4个子节为返回地址)</li></ul></li></ul><pre><code>***- 主调函数栈底入栈(被调函数)- 栈顶给栈底赋值(被调函数)- 被调函数局部变量...- 被调函数局部变量析构- 恢复主调函数栈帧- 获取返回地址, 继续执行主调函数代码- 关于返回值:     - 如果 `返回值 &lt;= 4字节`，则返回值通过寄存器`eax`带回。    - 如果 `4&lt; 返回值 &lt;=8字节`，则返回值通过两个寄存器`eax`和`edx`带回。    - 如果 `返回值 &gt; 8字节`，则返回值通过产生的临时量带回。</code></pre><hr><ol start="4"><li>过程调用和返回指令<ul><li><code>call</code> 指令</li><li><code>leave</code> 指令</li><li><code>ret</code> 指令</li></ul></li></ol><h2 id="160、MFC消息处理如何封装的？"><a href="#160、MFC消息处理如何封装的？" class="headerlink" title="160、MFC消息处理如何封装的？"></a>160、<code>MFC</code>消息处理如何封装的？</h2><h2 id="161、回调函数的作用"><a href="#161、回调函数的作用" class="headerlink" title="161、回调函数的作用"></a>161、回调函数的作用</h2><ul><li>回调函数一般可以分为两个类型:</li><li>中断处理函数<ul><li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li><li>此时回调函数就相当于是中断处理函数, 由系统在符合你设定的条件时自动调用。</li><li>为此我们需要进行<ul><li>函数声明</li><li>函数定义</li><li>设置中断触发, 就是把回调函数名称转化为地址作为一个参数，以便于系统调用；</li></ul></li></ul></li><li>通过函数指针调用的函数<ul><li>如果函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li><li>因为可以把调用者与被调用者分开。调用者只需要确定被调函数是一个具有特定参数列表和特定返回值的函数, 而不需要知道具体是哪个函数被调用.</li></ul></li></ul><h2 id="162、随机数的生成"><a href="#162、随机数的生成" class="headerlink" title="162、随机数的生成"></a>162、随机数的生成</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;time.h></span> </span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>b<span class="token operator">-</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>a<span class="token punctuation">;</span></code></pre><ul><li>由于<code>rand()</code>的内部实现是用线性同余法做的，所以生成的并不是真正的随机数，而是在一定范围内可看为随机的伪随机数。</li><li>种子写为<code>srand(time(0))</code>代表着获取系统时间，电脑右下角的时间，每一秒后系统时间的改变，数字序列的改变得到的数字</li></ul><h2 id="164、C-临时对象产生的时机"><a href="#164、C-临时对象产生的时机" class="headerlink" title="164、C++临时对象产生的时机"></a>164、C++临时对象产生的时机</h2><ul><li>为了使函数调用成功而进行隐式类型转换的时候。<ul><li>传值方式</li><li>const 引用传递(!!!!)</li></ul></li><li>当函数返回对象的时候。</li><li>参考: <a href="https://www.cnblogs.com/xkfz007/articles/2506022.html">转：C++中临时对象及返回值优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> C++ </tag>
            
            <tag> C++知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ray渲记录</title>
      <link href="/2021/05/26/kai-keng/ray-xuan-ji-lu/"/>
      <url>/2021/05/26/kai-keng/ray-xuan-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="ray渲记录"><a href="#ray渲记录" class="headerlink" title="ray渲记录"></a>ray渲记录</h2><h3 id="导入控制器"><a href="#导入控制器" class="headerlink" title="导入控制器"></a>导入控制器</h3><p>将ray-mmd中的pmx和x拖入mmd</p><h3 id="导入天空盒"><a href="#导入天空盒" class="headerlink" title="导入天空盒"></a>导入天空盒</h3><p>导入默认天空盒Skybox\Helipad GoldenHour\Sky with box.pmx</p><h3 id="设置模型描绘顺序"><a href="#设置模型描绘顺序" class="headerlink" title="设置模型描绘顺序"></a>设置模型描绘顺序</h3><p>天空盒</p><p>场景</p><p>人物</p><p>ray controller</p><h3 id="载入主渲染"><a href="#载入主渲染" class="headerlink" title="载入主渲染"></a>载入主渲染</h3><p>将ray-mmd中Main中的fx放入mme中，对应人物和场景的部分，此时会发现画面发黑</p><h3 id="mme选项讲解"><a href="#mme选项讲解" class="headerlink" title="mme选项讲解"></a>mme选项讲解</h3><ol><li><p>FogMap 雾气</p></li><li><p>LightMap 光源</p></li><li><p>EnvLightMap 环境</p></li></ol><p>将天空盒选择在刚刚选择的天空盒目录下的Sky with lighting with rotation.fx 带有旋转的版本的mme，同时main里面的天空盒选择同样的版本</p><ol start="4"><li><p>MaterialMap 材质</p></li><li><p>SSAOMap 环境吸收</p></li><li><p>PSSM1-4 四通道阴影</p></li></ol><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><p>显示中关闭地面阴影显示，关闭抗锯齿，关闭各向异性过滤</p><h2 id="mme"><a href="#mme" class="headerlink" title="mme"></a>mme</h2><h3 id="法线"><a href="#法线" class="headerlink" title="法线"></a>法线</h3><p>特殊的凹凸贴图。</p><p>将法线贴图复制进ray-master的materials中 的新建文件夹中，并且复制主目录下的fx进入新建文件夹，修改fx最后一句配置文件的相对位置为：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"../material_common_2.0.fxsub"</span></span></code></pre><p>然后在模型需要修改材质的地方引入新的材质贴图，修改对应的配置，详细请参照：</p><p><a href="https://www.bilibili.com/read/cv1171482/">https://www.bilibili.com/read/cv1171482/</a></p><h3 id="SSAO"><a href="#SSAO" class="headerlink" title="SSAO"></a>SSAO</h3><p>在选项页面，人物一般降低，例如0.8，场景为1</p>]]></content>
      
      
      <categories>
          
          <category> 开坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统助教两三事</title>
      <link href="/2021/05/06/ji-lu/qi-ta/proteach/"/>
      <url>/2021/05/06/ji-lu/qi-ta/proteach/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统助教两三事"><a href="#操作系统助教两三事" class="headerlink" title="操作系统助教两三事"></a>操作系统助教两三事</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>操作系统总共有4次实验，对应操作系统的不同阶段的几次实验内容。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>本次实验内容的分发本着不跟人打交道就是降低难度的准则，说服老师用在线仓库进行管理。</p><p>将实验内容先梳理框架，然后分批次放在远程仓库中，提供实验手册和实验报告模板，并且在实验开始前的一周内放出内容，方便大家预习。</p><p>在收集内容时候也是采用了尽量少的方式，直接跟学委沟通通过邮箱来发送，这样既不会错漏还能存档。</p><p>与其他人合作时候在分工同时也要注意时间上的安排等。一些准备时间比较长的部分需要提前准备。</p><h2 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h2><p>在准备物料的时候思考，考虑每个阶段学生需要什么内容，可能有什么问题，并提前对可能问题进行说明，避免后期会频繁询问。</p><p>本次助教中在前期准备还是非常充分的，但是还是忘记了有重修的同学的，这个部分准备的不是特别好。——需要考虑团队中特殊的小部分，对这部分工作提前做好准备。</p><p>在实际实验过程中，看堂和签到都没什么问题，按需解答问题。</p><p>后期接收材料过程中反复提醒时间、格式等内容，为了不错露，但是还是有人格式不正确而产生各种小问题（但是无伤大雅）。</p><p>一次非常有意义的经历。</p><h2 id="相关物料"><a href="#相关物料" class="headerlink" title="相关物料"></a>相关物料</h2><p>仓库： <a href="https://github.com/zhangyuanes/OperatingSystemExperiments">https://github.com/zhangyuanes/OperatingSystemExperiments</a></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String专题</title>
      <link href="/2021/05/05/ji-lu/c/string/"/>
      <url>/2021/05/05/ji-lu/c/string/</url>
      
        <content type="html"><![CDATA[<h1 id="String概念"><a href="#String概念" class="headerlink" title="String概念"></a>String概念</h1><h2 id="String-API-（C-11）"><a href="#String-API-（C-11）" class="headerlink" title="String API （C++11）"></a>String API （C++11）</h2><p><code>string</code>是在C++中才封装的内容，在C中只能使用<code>char* []</code>或者<code>const char* []</code>,但是操作繁琐很容易出错。</p><p>String 的一些比较重要的API：</p><ul><li>c_str ： 返回字符串的不可修改的 C 字符数组版本。该指针有范围 [c_str(); c_str() + size()] 为合法，且其中的值对应存储于字符串的值，且在最后位置有个附加的空终止字符。</li></ul><h3 id="字符查找"><a href="#字符查找" class="headerlink" title="字符查找"></a>字符查找</h3><ul><li>find：于字符串中寻找字符</li><li>rfind：寻找子串的最后一次出现</li><li>find_first_of：寻找字符的首次出现</li><li>find_first_not_of: 寻找字符的首次缺失</li><li>find_last_of: 寻找字符的最后一次出现</li><li>find_last_not_of:寻找字符的最后一次缺失</li></ul><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><blockquote><p>转换字符串为有符号整数<br>stoi<br>stol<br>stoll</p></blockquote><blockquote><p>转换字符串为无符号整数<br>stoul<br>stoull</p></blockquote><blockquote><p>转换字符串为浮点值<br>stof<br>stod<br>stold</p></blockquote><blockquote><p>转换整数或浮点值为 string,wstring<br>to_string<br>to_wstring</p></blockquote><h2 id="String-基本考察类型"><a href="#String-基本考察类型" class="headerlink" title="String 基本考察类型"></a>String 基本考察类型</h2><h3 id="顺序-——-翻转，反转"><a href="#顺序-——-翻转，反转" class="headerlink" title="顺序 —— 翻转，反转"></a>顺序 —— 翻转，反转</h3><h3 id="匹配-——-子串，子序列，模式匹配"><a href="#匹配-——-子串，子序列，模式匹配" class="headerlink" title="匹配 —— 子串，子序列，模式匹配"></a>匹配 —— 子串，子序列，模式匹配</h3><h3 id="比较-——-字典序"><a href="#比较-——-字典序" class="headerlink" title="比较 —— 字典序"></a>比较 —— 字典序</h3><h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><h3 id="统计-——-出现次数，位置，条件，包含"><a href="#统计-——-出现次数，位置，条件，包含" class="headerlink" title="统计 —— 出现次数，位置，条件，包含"></a>统计 —— 出现次数，位置，条件，包含</h3><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><blockquote><p>最长回文子串 DP</p></blockquote><blockquote><p>最长不重复子串 滑动窗口</p></blockquote><blockquote><p>和不小于K的最短子串 前缀叔祖+单调双端队列</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆卡片idea</title>
      <link href="/2021/05/04/kai-keng/ji-yi-qia-pian/"/>
      <url>/2021/05/04/kai-keng/ji-yi-qia-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="记忆卡片project"><a href="#记忆卡片project" class="headerlink" title="记忆卡片project"></a>记忆卡片project</h1><h2 id="需求抽取"><a href="#需求抽取" class="headerlink" title="需求抽取"></a>需求抽取</h2><h3 id="Client功能点"><a href="#Client功能点" class="headerlink" title="Client功能点"></a><strong>Client功能点</strong></h3><p>1、响应式布局，多端使用——需要在PC，移动端自由适配</p><p>2、问题卡片展示：</p><p>卡片展示——在卡片页面中展示卡片问题，记忆层次按钮，问题tags，关联问题，以及上一题、下一题、随机一题跳转按钮，侧边菜单栏按钮，问题卡片细节信息包含：题号，正文，tags，问题贡献者，答案卡片细节包括：问题复述，答案正文，问题贡献者，上次浏览时间，总复习次数</p><p>答案翻转——当用户选择记忆层次时自动翻转卡片，展示答案</p><p>标记记忆层次——层次包括（不了解，知道但不清晰，很了解），点击时标记用户对此问题的了解程度，并展示答案</p><p>分类快速查询——点击tags或者内置关键词搜索链接，自动按照关键词匹配、tags查找、记忆层次查找对应的问题，并分页展示搜索结果</p><p>卡片搜索——在搜索框输入内容，按照id数字、关键词匹配、tags查找、记忆层次，并分页展示搜索结果</p><p>3、问题卡片切换：</p><p>前后顺序切换——点击 上一题、下一题跳转按钮或者手动滑动题目卡片时候切换</p><p>随机切换——给出随机一题的按钮，可以随机给出一题，优先在未浏览的题目中抽取</p><p>4、用户设置：</p><p>保留用户的浏览记录——用户记忆每一张卡片，保留其上次浏览时间，总共浏览次数和对应记忆层次</p><p>记忆分析——生成用户记忆报告，使用可视化js将信息可视化，包括总浏览题目，各个记忆层次的数量和比例，最擅长什么，最不擅长什么</p><h3 id="Admin后台端"><a href="#Admin后台端" class="headerlink" title="Admin后台端"></a><strong>Admin后台端</strong></h3><p>1、root+admins的多用户模式——维护数据库，项目配置</p><p>2、admin dashboard——套用crud系统dashboard，需要带有分页</p><p>3、CURD操作（带权限）：</p><p>添加问题——新建问题，贡献者为操作用户，设置关联问题；完善问题答案——将问题的答案填入，贡献者为操作用户；修改问题——修改问题，答案，tags，关联问题，分类等；删除问题——删除问题，需要验证用户权限，目前仅root管理员拥有删除权限，需要谨慎。</p><p>4、分类浏览——配置分类选项（例如无答案问题，待关联问题，回答有误问题、题目描述不清晰），筛选展示搜索到的合理项</p><p>5、快速修改——在简要分页页面提供合理的快速修改下拉框；详细编辑页面修改完成后点击提交修改，提供跳转到下一个分类过滤项的按钮</p><p>6、操作留痕——所有admin对问题的操作需要留痕，包含操作人id，操作题目id，操作类型，操作时间</p><p>7、操作历史可视化——暂时可以不考虑</p><p>8、数据导出——将问题表，用户表，记录表等数据库表导出为json格式</p><p>9、数据导入——将包含信息的json解析，恢复对应的数据库</p><h3 id="架构选择"><a href="#架构选择" class="headerlink" title="架构选择"></a>架构选择</h3><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>页面构建初步选择Ant design vue构建，rest url风格请求。使用mock来生成测试数据。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>用户表，id，pw，name，priority（can add,modify,delete)功能组合赋予</p><h2 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h2><h3 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h3><p>原型设计。</p><p>记忆页面： 主交互页面。 默认为PC网页，响应式布局，适配手机端。</p><ul><li>记忆卡片设计：正面，反面，。 <ul><li>正面</li><li>反面</li><li>动效</li></ul></li><li>浏览交互按钮设计</li><li>tag交互按钮设计：</li><li>浏览页面： 图状浏览页面，表状浏览页面，展示基础内容字段。 </li></ul><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><ul><li>记忆页面翻转效果，特殊动效。</li><li>交互按钮</li><li>卡片切换设计：滑动动效，可拖动。</li></ul><h3 id="Admin端设计"><a href="#Admin端设计" class="headerlink" title="Admin端设计"></a>Admin端设计</h3><p>套用基于接口的后台管理框架，按照要求适配即可。</p><h3 id="记忆算法设计"><a href="#记忆算法设计" class="headerlink" title="记忆算法设计"></a>记忆算法设计</h3><ol><li>艾宾浩斯遗忘曲线：基于此方式在浏览时间上安排复习</li><li>时间冲突解决原则：先旧后新</li></ol>]]></content>
      
      
      <categories>
          
          <category> 开坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目设想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++刷题相关</title>
      <link href="/2021/05/04/ji-lu/c/c-shua-ti-xiang-guan/"/>
      <url>/2021/05/04/ji-lu/c/c-shua-ti-xiang-guan/</url>
      
        <content type="html"><![CDATA[<p>这里我采用了<code>shpinx</code>来构建新的在线doc，使用<code>read the doc</code>来进行在线文档托管，文档的书写类型是<code>reStructuredText</code>。</p><p><a href="https://sphinx-record.readthedocs.io/zh/latest">在线浏览地址</a></p><p>如何书写自己的在线文档请参照 <a href="https://github.com/zhangyuanes/sphinx_record">这篇</a>。这里就不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 刷题 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 经典算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试笔试中知识体系构建</title>
      <link href="/2021/01/19/kai-keng/coding-interview/"/>
      <url>/2021/01/19/kai-keng/coding-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%E8%BF%99%E6%98%AF">这是？</a></li><li><a href="#%E4%B8%BA%E4%BD%95%E8%A6%81%E7%94%A8%E5%88%B0%E5%AE%83">为何要用到它？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83">如何使用它</a></li><li><a href="#%E4%B8%8D%E8%A6%81%E8%A7%89%E5%BE%97%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%A4%9F%E8%81%AA%E6%98%8E">不要觉得自己不够聪明</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%A7%86%E9%A2%91%E8%B5%84%E6%BA%90">相关视频资源</a></li><li><a href="#%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B--%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87">面试过程 &amp; 通用的面试准备</a></li><li><a href="#%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E8%AF%AD%E8%A8%80">为你的面试选择一种语言</a></li><li><a href="#%E4%B9%A6%E5%8D%95">书单</a></li><li><a href="#%E5%9C%A8%E4%BD%A0%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">在你开始之前</a></li><li><a href="#%E6%B2%A1%E6%9C%89%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9">没有包含的内容</a></li><li><a href="#%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86">必备知识</a></li><li><a href="#%E6%97%A5%E5%B8%B8%E8%AE%A1%E5%88%92">日常计划</a></li><li><a href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6--big-o--%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90%E6%B3%95">算法复杂度 / Big-O / 渐进分析法</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul><li><a href="#%E6%95%B0%E7%BB%84arrays">数组（Arrays）</a></li><li><a href="#%E9%93%BE%E8%A1%A8linked-lists">链表（Linked Lists）</a></li><li><a href="#%E5%A0%86%E6%A0%88stack">堆栈（Stack）</a></li><li><a href="#%E9%98%9F%E5%88%97queue">队列（Queue）</a></li><li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8hash-table">哈希表（Hash table）</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%9F%A5%E8%AF%86">更多的知识</a><ul><li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary-search">二分查找（Binary search）</a></li><li><a href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97bitwise-operations">按位运算（Bitwise operations）</a></li></ul></li><li><a href="#%E6%A0%91trees">树（Trees）</a><ul><li><a href="#%E6%A0%91--%E7%AC%94%E8%AE%B0--%E8%83%8C%E6%99%AF">树 —— 笔记 &amp; 背景</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li><li><a href="#%E5%A0%86heap--%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority-queue--%E4%BA%8C%E5%8F%89%E5%A0%86binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91balanced-search-trees">平衡查找树（Balanced search trees）（基本概念，非细节）</a></li><li>遍历：前序、中序、后序、BFS、DFS</li></ul></li><li><a href="#%E6%8E%92%E5%BA%8Fsorting">排序</a><ul><li>选择排序（selection）</li><li>插入排序（insertion）</li><li>堆排序（heapsort）</li><li>快速排序（quicksort）</li><li>归并排序（merge sort）</li></ul></li><li><a href="#%E5%9B%BEgraphs">图（Graphs）</a><ul><li>有向图（directed）</li><li>无向图（undirected）</li><li>邻接矩阵（adjacency matrix）</li><li>邻接表（adjacency list）</li><li>遍历：广度优先(BFS), 深度优先(DFS)</li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E7%9F%A5%E8%AF%86">更多知识</a><ul><li><a href="#%E9%80%92%E5%BD%92recursion">递归</a></li><li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dynamic-programming">动态规划</a></li><li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li><li><a href="#%E7%BB%84%E5%90%88combinatorics-n-%E4%B8%AD%E9%80%89-k-%E4%B8%AA--%E6%A6%82%E7%8E%87probability">组合 &amp; 概率</a></li><li><a href="#np-np-%E5%AE%8C%E5%85%A8%E5%92%8C%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95">NP, NP-完全和近似算法</a></li><li><a href="#%E7%BC%93%E5%AD%98cache">缓存</a></li><li><a href="#%E8%BF%9B%E7%A8%8Bprocesse%E5%92%8C%E7%BA%BF%E7%A8%8Bthread">进程和线程</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li><li><a href="#%E8%B0%83%E5%BA%A6">调度</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E5%92%8C%E6%93%8D%E4%BD%9C">字符串搜索和操作</a></li><li><a href="#%E5%AD%97%E5%85%B8%E6%A0%91tries">字典树（Tries）</a></li><li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li><li><a href="#unicode">Unicode</a></li><li><a href="#%E5%AD%97%E8%8A%82%E5%BA%8FEndianness">字节顺序</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91">网络</a></li></ul></li><li><a href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">系统设计、可伸缩性、数据处理</a>（如果你有4+年经验）</li><li><a href="#%E7%BB%88%E9%9D%A2">终面</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E7%BB%83%E4%B9%A0">编程问题练习</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E5%92%8C%E6%8C%91%E6%88%98">编程练习和挑战</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E4%B8%B4%E8%BF%91%E9%9D%A2%E8%AF%95%E6%97%B6">当你临近面试时</a></li><li><a href="#%E4%BD%A0%E7%9A%84%E7%AE%80%E5%8E%86">你的简历</a></li><li><a href="#%E5%BD%93%E9%9D%A2%E8%AF%95%E6%9D%A5%E4%B8%B4%E7%9A%84%E6%97%B6%E5%80%99">当面试来临的时候</a></li><li><a href="#%E9%97%AE%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E9%97%AE%E9%A2%98">问面试官的问题</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E8%8E%B7%E5%BE%97%E4%BA%86%E6%A2%A6%E6%83%B3%E7%9A%84%E8%81%8C%E4%BD%8D">当你获得了梦想的职位</a></li></ul><p>—————- 下面的内容是可选的 —————-</p><ul><li><a href="#%E9%A2%9D%E5%A4%96%E4%B9%A6%E7%B1%8D">额外书籍</a></li><li><a href="#%E9%99%84%E5%8A%A0%E5%AD%A6%E4%B9%A0">附加学习</a><ul><li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a></li><li><a href="#emacs-and-vim">Emacs and vi(m)</a></li><li><a href="#unix-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7">Unix 命令行工具</a></li><li><a href="#%E4%BF%A1%E6%81%AF%E8%AE%BA-%E8%A7%86%E9%A2%91">信息论</a></li><li><a href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D--%E6%B1%89%E6%98%8E%E7%A0%81-%E8%A7%86%E9%A2%91">奇偶校验位 &amp; 汉明码 (视频)</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E7%86%B5%E5%80%BCEntropy">系统熵值</a></li><li><a href="#%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a></li><li><a href="#%E5%8E%8B%E7%BC%A9">压缩</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a></li><li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></li><li><a href="#%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B">并行编程</a></li><li><a href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E9%98%9F%E5%88%97%E7%B3%BB%E7%BB%9F">消息传递，序列化和队列化的系统</a></li><li><a href="#A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">A*搜索算法</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">快速傅里叶变换</a></li><li><a href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a></li><li><a href="#HyperLogLog">HyperLogLog</a></li><li><a href="#%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C">局部敏感哈希</a></li><li><a href="#van-emde-boas-%E6%A0%91">van Emde Boas 树</a></li><li><a href="#%E5%A2%9E%E5%BC%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">增强数据结构</a></li><li><a href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91balanced-search-trees">平衡查找树</a><ul><li>AVL 树</li><li>伸缩树（Splay tree）</li><li>红黑树</li><li>2-3 查找树</li><li>2-3-4 树(也称 2-4 树)</li><li>N-ary (K-ary, M-ary)树</li><li>B 树</li></ul></li><li><a href="#k-D%E6%A0%91">k-D 树</a></li><li><a href="#%E8%B7%B3%E8%A1%A8">跳表</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%81">网络流</a></li><li><a href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86--%E8%81%94%E5%90%88%E6%9F%A5%E6%89%BE">不相交集 &amp; 联合查找</a></li><li><a href="#%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E5%AD%A6">快速处理的数学</a></li><li><a href="#%E6%A0%91%E5%A0%86-treap">树堆 (Treap)</a></li><li><a href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92linear-programming%E8%A7%86%E9%A2%91">线性规划</a></li><li><a href="#%E5%87%A0%E4%BD%95%E5%87%B8%E5%8C%85geometry-convex-hull%E8%A7%86%E9%A2%91">几何：凸包（Geometry, Convex hull）</a></li><li><a href="#%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6">离散数学</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0machine-learning">机器学习</a></li></ul></li><li><a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a></li><li><a href="#%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97">视频系列</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE%E7%A8%8B">计算机科学课程</a></li><li><a href="#%E8%AE%BA%E6%96%87">论文</a></li></ul><hr><h1 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h1><p>此项目来源于jwasham作者的项目——<a href="https://github.com/jwasham/coding-interview-university/">Coding Interview University</a>。</p><p>因为本人是学C++的，所以其中就只保留了C++的部分。整体的流程缩减了许多，而且一些写给入门程序员的教学、建议的部分也删除了。</p><p>对于其中特别重要的部分，或者我刷过的部分会写专题来梳理。本文章原版请参考原文。</p><h1 id="Coding-Interview-University"><a href="#Coding-Interview-University" class="headerlink" title="Coding Interview University"></a>Coding Interview University</h1><p>原先我为了成为一个软件工程师而建立这份简单的学习主题清单， 但这份清单随着时间而膨胀成今天这样。在做完这份清单上的每个目标后，<a href="https://startupnextdoor.com/ive-been-acquired-by-amazon/?src=ciu">我成为了 Amazon 的软件开发工程师</a>! 你或许不需要像我一样学习这么多。但是，让你成为一位称职工程师所需要的知识都在这里了。</p><p>我每天自学8~12小时，这样持续了好几个月。这是我的故事：<a href="https://medium.freecodecamp.org/why-i-studied-full-time-for-8-months-for-a-google-interview-cc662ce9bb13">为什么我为了 Google 面试而自学了8个月</a>。</p><p>在这份清单内的主题会让你拥有足够的知识去面对几乎每家软件公司的技术面试，包括科技巨头：Amazon、Facebook、Google，以及 Microsoft。</p><p>祝你好运!</p><h2 id="这是？"><a href="#这是？" class="headerlink" title="这是？"></a>这是？</h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p><p><img src="https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p><p>这份清单适用于 <strong>新手软件工程师</strong>，或者想从软件/网站开发转向软件工程（需要计算机科学知识）的人员。如果你有多年的经验，并且声称拥有多年的软件工程经验，并且期待一次更艰难的面试。</p><p>如果你具有多年的软件/网页开发经验，请注意，大型软件公司（例如 Google，Amazon，Facebook 和 Microsoft）将软件工程视为不同于软件/网页开发，并且它们需要计算机科学知识。</p><p>如果你想成为可靠性工程师或运维工程师，请从可选列表（网络，安全）中学习更多。</p><hr><h2 id="为何要用到它？"><a href="#为何要用到它？" class="headerlink" title="为何要用到它？"></a>为何要用到它？</h2><p>当我开始这个项目时，我不知道堆和栈的区别，不了解时间复杂度（Big-O）、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，才会去找解决方法。在我的编程生涯中，虽然我有用过多维数组，也用过关联数组成千上万次，但我从来没有自己实现过数据结构。</p><p>这是一个漫长的计划，以至于花费了我数月的时间。若你早已熟悉大部分的知识，那么也许能节省大量的时间。</p><p>::tip<br>这时候我也是想这位作者一样，半桶水，很多内容都不甚清晰，模棱两可，应试地刷题为了笔试，没有真正想要深入了解和自己打交道的软件工程及其相关。<br>::</p><h2 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p><p>在学习过程中，我使用 GitHub 特殊语法的 markdown 去检查计划的进展，包括使用包含任务进度的任务列表。</p><p>**创建一个新的分支，以便你可以像这样去勾选计划的进展：直接往方括号中填写一个字符 x 即可：[x]**。</p><pre><code>Fork一个分支，并跟随以下的指令</code></pre><p>通过单击 Fork 按钮来 fork GitHub 仓库：<a href="https://github.com/jwasham/coding-interview-university">jwasham/coding-interview-university</a></p><pre><code>克隆项目到本地</code></pre><p><code>git checkout -b progress</code></p><p><code>git remote add jwasham https://github.com/jwasham/coding-interview-university</code></p><p><code>git fetch --all</code></p><pre><code>在你完成了一些修改后，在框框中打 x</code></pre><p><code>git add .</code></p><p><code>git commit -m &quot;Marked x&quot;</code></p><p><code>git rebase jwasham/master</code></p><p><code>git push --set-upstream origin progress</code></p><p><code>git push --force</code></p><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown">更多关于 Github-flavored markdown 的详情</a></p><h2 id="不要觉得自己不够聪明"><a href="#不要觉得自己不够聪明" class="headerlink" title="不要觉得自己不够聪明"></a>不要觉得自己不够聪明</h2><ul><li>大多数成功的软件工程师都非常聪明，但他们都有一种觉得自己不够聪明的不安全感。</li><li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ">天才程序员的神话</a></li><li><a href="https://www.youtube.com/watch?v=1i8ylq4j_EY">不要单打独斗：面对技术中的隐形怪物</a></li></ul><h2 id="相关视频资源"><a href="#相关视频资源" class="headerlink" title="相关视频资源"></a>相关视频资源</h2><p>部分视频只能通过在 Coursera 或者 Edx 课程上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。有时候某些课程需要等待好几个月才能获取，这期间你无法观看这些课程的影片。</p><pre><code>很感谢你能帮我把网络公开课程的视频链接转换成公开的，可持续访问的视频源，比如 YouTube 视频，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。</code></pre><h2 id="面试过程-amp-通用的面试准备"><a href="#面试过程-amp-通用的面试准备" class="headerlink" title="面试过程 &amp; 通用的面试准备"></a>面试过程 &amp; 通用的面试准备</h2><ul><li><input disabled="" type="checkbox"> <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4">ABC：不要停止编程（Always Be Coding）</a></li><li><input disabled="" type="checkbox"> <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1">白板编程（Whiteboarding）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=N233T0epWTs">揭秘技术招聘</a></li><li><input disabled="" type="checkbox"> 如何在科技四强企业中获得一份工作：<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8">“如何在科技四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> 解密开发类面试第一集：<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ">Gayle L McDowell —— 解密开发类面试（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ">解密开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> 解密 Facebook 编码面试：<ul><li><a href="https://www.youtube.com/watch?v=wCl9kvQGHPI">方法</a></li><li><a href="https://www.youtube.com/watch?v=4UWDyJq8jZg">问题演练</a></li></ul></li><li><input disabled="" type="checkbox"> 准备课程：<ul><li><input disabled="" type="checkbox"> <a href="https://www.udemy.com/software-engineer-interview-unleashed">软件工程师面试发布（收费课程）</a>：<ul><li>从前 Google 面试官身上学习如何准备自己，让自己能够应付软件工程师的面试。</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.udemy.com/python-for-data-structures-algorithms-and-interviews/">Python 数据结构，算法和面试（收费课程）</a>：<ul><li>Python 面试准备课程，内容涉及数据结构，算法，模拟面试等。</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.udacity.com/course/data-structures-and-algorithms-in-python--ud513">Python 的数据结构和算法简介（Udacity 免费课程）</a>：<ul><li>免费的 Python 数据结构和算法课程。</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.udacity.com/course/data-structures-and-algorithms-nanodegree--nd256">数据结构和算法纳米学位！（Udacity 收费纳米学位）</a>：<ul><li>获得超过100种数据结构和算法练习以及指导的动手练习，专门导师帮助你在面试和职场中做好准备。</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.educative.io/courses/grokking-the-behavioral-interview">探究行为面试（Educative 免费课程）</a>：<ul><li>很多时候，不是你的技术能力会阻碍你获得理想的工作，而是你在行为面试中的表现。</li></ul></li></ul></li></ul><h2 id="为你的面试选择一种语言"><a href="#为你的面试选择一种语言" class="headerlink" title="为你的面试选择一种语言"></a>为你的面试选择一种语言</h2><p>你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程，但对于大公司，你只有三种固定的选择：</p><ul><li>C++</li><li>Java</li><li>Python</li></ul><p>你也可以使用下面两种编程语言，但可能会有某些限制，你需要实现查明：</p><ul><li>JavaScript</li><li>Ruby</li></ul><p>我之前写过一篇关于在面试时选择编程语言的文章：<a href="https://startupnextdoor.com/important-pick-one-language-for-the-coding-interview/">为编程面试选择一种语言</a>。</p><p>你需要对你所选择的语言感到非常舒适且足够了解。</p><p>更多关于语言选择的阅读：</p><ul><li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li><li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li></ul><p><a href="../programming-language-resources.md">在此查看相关语言的资源</a></p><p>由于我正在学习C、C++ 和 Python，因此在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>为了节省你的时间，以下是比我使用过的更缩减的书单。</p><h3 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Programming-Interviews-Exposed-Through-Interview/dp/111941847X/">Programming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition</a><ul><li>附有 C++ 和 Java 解答</li><li>这是在练习 Cracking the Coding Interview 之前一个很好的热身</li><li>不太困难，大多数问题可能比你在面试中看到的要容易（根据我的阅读）</li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/">Cracking the Coding Interview, 6th Edition</a><ul><li>附有 Java 答案</li></ul></li></ul><h3 id="如果你有额外的时间："><a href="#如果你有额外的时间：" class="headerlink" title="如果你有额外的时间："></a>如果你有额外的时间：</h3><p>选择以下之一：</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836">Elements of Programming Interviews (C++ version)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Elements-Programming-Interviews-Python-Insiders/dp/1537713949/">Elements of Programming Interviews in Python</a></li><li><input disabled="" type="checkbox"> Elements of Programming Interviews (Java version)<ul><li><a href="https://www.amazon.com/Elements-Programming-Interviews-Java-Insiders/dp/1517435803/">书</a></li><li><a href="https://github.com/gardncl/elements-of-programming-interviews">配套项目──书中每个问题的方法和测试用例</a></li></ul></li></ul><h3 id="编程语言精选"><a href="#编程语言精选" class="headerlink" title="编程语言精选"></a>编程语言精选</h3><p><strong>你需要选择面试语言（请参见上文）。</strong></p><p>这是我按语言给出的建议。我没有所有语言的资源，欢迎贡献。</p><p>如果你通读其中之一，你应该具备了开始解决编程问题所需的所有数据结构和算法知识。除非你需要复习，否则<strong>你可以跳过此项目中的所有视频讲座</strong>。</p><p><a href="https://github.com/jwasham/coding-interview-university/blob/master/programming-language-resources.md">额外编程语言的精选资源</a></p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>我没有读过这两本书，但是它们颇受好评，作者是 Sedgewick，他非常厉害。</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882/">Algorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching</a></li><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Algorithms-Part-Graph-3rd-Pt-5/dp/0201361183/">Algorithms in C++ Part 5: Graph Algorithms</a></li><li><input disabled="" type="checkbox"> <a href="https://opendatastructures.org/ods-cpp.pdf">Open Data Structures in C++</a><ul><li>丰富而详细的数据结构和算法集合</li><li>非常适合初学者</li></ul></li></ul><p>如果你有更好的 C++ 书籍，请告诉我。我正在搜集全面的资源。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/">算法（Sedgewick 和 Wayne）</a><ul><li>包含课程内容（和Sedgewick！）的视频<ul><li><a href="https://www.coursera.org/learn/algorithms-part1">第一部分</a></li><li><a href="https://www.coursera.org/learn/algorithms-part2">第二部分</a></li></ul></li></ul></li></ul><p>或者：</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Data-Structures-Algorithms-Michael-Goodrich/dp/1118771338/">Java 数据结构和算法</a><ul><li>作者：Goodrich、Tamassia、Goldwasser</li><li>用作 UC Berkeley 的 CS 入门课程的可选教材</li><li>请参阅下面有关 Python 版本的我的读书报告，这本书涵盖了相同的主题</li></ul></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Structures-Algorithms-Python-Michael-Goodrich/dp/1118290275/">Python数据结构和算法</a><ul><li>作者：Goodrich、Tamassia、Goldwasser</li><li>我非常喜爱这本书，它包含了所有东西</li><li>很 Python 的代码</li><li>我的读书报告：<a href="https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/">startupnextdoor.com/book-report-data-structures-and-algorithms-in-python</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://opendatastructures.org/ods-python.pdf">Open Data Structures in Python</a></li></ul><h2 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p><p>这里列出了一些我所犯过的错误，希望你不要重滔覆辙。</p><h3 id="1-你不可能把所有的东西都记住"><a href="#1-你不可能把所有的东西都记住" class="headerlink" title="1. 你不可能把所有的东西都记住"></a>1. 你不可能把所有的东西都记住</h3><p>就算我观看了数小时的视频，并记录了大量的笔记，几个月后的我，仍然会忘却其中大部分的东西。所以，我花了3天翻阅我的笔记，并制作成抽认卡（flashcard）帮助我复习：</p><p>请阅读以下的文章以免重蹈覆辙:</p><p><a href="https://startupnextdoor.com/retaining-computer-science-knowledge/">记住计算机科学知识</a>。</p><p>有人推荐给我的课程（但我还沒看过）：<a href="https://www.coursera.org/learn/learning-how-to-learn">学习如何学习</a>。</p><h3 id="2-使用抽认卡"><a href="#2-使用抽认卡" class="headerlink" title="2. 使用抽认卡"></a>2. 使用抽认卡</h3><p>为了解决善忘的问题，我制作了一个抽认卡的网页，用于添加两种抽认卡：一般的及带有代码的。每种卡都会有不同的格式设计。</p><p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方，我都能通过我的手机及平板去回顾知识。</p><p>你也可以免费制作属于你自己的抽认卡网站：</p><ul><li><a href="https://github.com/jwasham/computer-science-flash-cards">抽认卡页面的代码仓库</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db">我的抽认卡数据库 ── 旧 1200 张</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham-extreme.db">我的抽认卡数据库 ── 新 1800 张</a></li></ul><p>有一点需要记住的是，我做事有点过头，以至于卡片都覆盖到所有的东西上，从汇编语言和 Python 的细枝末节，到机器学习和统计都被覆盖到卡片上。而这种做法，对于要求来说是多余的。</p><p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已知”。反复复习这张抽认卡，直到每次都能答对后才是真正学会了这个问题。反复地问答可帮助你深刻记住该知识点。</p><p>这里有个替代我抽认卡的网站 <a href="http://ankisrs.net/">Anki</a>，很多人向我推荐过它。这个网站用同一个字卡重复出现的方式让你牢牢地记住知识。这个网站非常容易使用，支持多平台，并且有云端同步功能。在 iOS 平台上收费25美金，其他平台免费。</p><p>这是我用 Anki 这个网站里的格式所储存的抽认卡资料库: ankiweb.net/shared/info/25173560 （感谢 <a href="https://github.com/xiewenya">@xiewenya</a>）</p><h3 id="3-复习，复习，再复习"><a href="#3-复习，复习，再复习" class="headerlink" title="3. 复习，复习，再复习"></a>3. 复习，复习，再复习</h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的抽认卡，以便在空余的时候可以学习。</p><p>编程累了就休息半个小时，并去复习你的抽认卡。</p><h3 id="4-专注"><a href="#4-专注" class="headerlink" title="4. 专注"></a>4. 专注</h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。放点纯音乐能帮上一些忙。</p><h2 id="没有包含的内容"><a href="#没有包含的内容" class="headerlink" title="没有包含的内容"></a>没有包含的内容</h2><p>有一些熟悉且普遍的技术在此未被谈及到：</p><ul><li>SQL</li><li>Javascript</li><li>HTML、CSS 和其他前端技术</li></ul><h2 id="日常计划"><a href="#日常计划" class="headerlink" title="日常计划"></a>日常计划</h2><p>部分问题可能会花费一天的时间去学习，而有些则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p><p>因此，每一天我都会在下面所列出的列表中选择一项，并观看相关的视频。然后，使用以下的一种语言去实现：</p><ul><li>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。</li><li>C++ —— 不使用内建的数据类型。</li><li>C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。</li><li>Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。</li><li>此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。</li></ul><p>你不需要学会所有的编程语言，你只需要专注在<a href="##%E4%B8%BA%E4%BD%A0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%80%89%E6%8B%A9%E4%B8%80%E7%A7%8D%E8%AF%AD%E8%A8%80">一种编程语言</a>上。</p><p>为何要在这些语言上分别实现一次？</p><ul><li>练习，练习，练习，直至我厌倦它，并正确无误地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）</li><li>在纯原生的条件下工作（不需垃圾回收机制的帮助下，手动分配/释放内存（除了 Python））</li><li>利用语言内建的数据类型，之后在实际工作的时候才能得心应手（在生产环境中，我不会去实现自己的链表）</li></ul><p>就算我没有时间去每一项都这么做，但我也会尽我所能。</p><p>在这里你可以查看到我的代码：</p><ul><li><a href="https://github.com/jwasham/practice-c">C</a></li><li><a href="https://github.com/jwasham/practice-cpp">C++</a></li><li><a href="https://github.com/jwasham/practice-python">Python</a></li></ul><p>你不需要记住每一个算法的内部原理。</p><p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ul><li><p><strong>学习C语言</strong></p><ul><li>C 语言无处不在。在学习的过程中，你会在书籍，讲座，视频等任何地方看到它的身影</li><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628">C程序设计语言，第二版</a><ul><li>这是一本简短的书，但是它将使你更好地使用 C 语言，并且如果你稍加练习，就会很快熟练。理解 C 可帮助你了解程序和内存的工作方式</li><li>问题答案</li></ul></li></ul></li><li><p><strong>计算机是如何处理一段程序：</strong></p><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=XM4lGflQFvA">CPU 是如何执行代码（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/1I5ZMmrOfnA">计算机如何计算（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/fpnE6UAfbtU">寄存器和内存（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/FZGugFqdr60">中央处理单元（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/zltgXvg6r3k">指令和程序（视频）</a></li></ul></li></ul><h2 id="算法复杂度-Big-O-渐进分析法"><a href="#算法复杂度-Big-O-渐进分析法" class="headerlink" title="算法复杂度 / Big-O / 渐进分析法"></a>算法复杂度 / Big-O / 渐进分析法</h2><ul><li>并不需要实现</li><li>这里有很多视频，看到你真正了解它为止。你随时可以回来复习。</li><li>如果这些课程太过数学的话，你可以去看看最下面离散数学的视频，它能让你更了解这些数学背后的来源以及原理。</li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4">Harvard CS50 —— 渐进表示（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=V6mKVRU1evU">Big O 记号（通用快速教程）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&index=2&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li><li><input disabled="" type="checkbox"> Skiena 算法：<ul><li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&index=2&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">视频</a></li><li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf">幻灯片</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://discrete.gr/complexity/">对于算法复杂度分析的一次详细介绍</a></li><li><input disabled="" type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59">增长阶数（Orders of Growth）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61">渐进性（Asymptotics）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/VIS4YDpuP98">UC Berkeley Big O（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/ca3e7UVmeUc">UC Berkeley Big Omega（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&index=10&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN">平摊分析法（Amortized Analysis）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63">举证“Big O”（视频）</a></li><li><input disabled="" type="checkbox"> TopCoder（包括递归关系和主定理）：<ul><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/">计算性复杂度：第一部</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/">计算性复杂度：第二部</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://bigocheatsheet.com/">速查表（Cheat sheet）</a></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><ul><li>实现一个可自动调整大小的动态数组。</li><li><input disabled="" type="checkbox"> 介绍：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays">数组（视频）</a></li><li><a href="https://archive.org/details/ucberkeley_webcast_Wp8oiO_CZZE">UC Berkeley CS61B - 线性数组和多维数组（视频）</a>（从15分32秒开始）</li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_04-basicArrays.mp4">数组的基础知识（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_05-multidimensionalArrays.mp4">多维数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays">动态数组（视频）</a></li><li><a href="https://www.youtube.com/watch?v=1jtrQqYpt7g">不规则数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_06-jaggedArrays.mp4">不规则数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/03_01-resizableArrays.mp4">调整数组的大小（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> 实现一个动态数组（可自动调整大小的可变数组）：<ul><li><input disabled="" type="checkbox"> 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li><li><input disabled="" type="checkbox"> 通过分配内存来新建一个原生数据型数组<ul><li>可以使用 int 类型的数组，但不能使用其语法特性</li><li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li></ul></li><li><input disabled="" type="checkbox"> size() —— 数组元素的个数</li><li><input disabled="" type="checkbox"> capacity() —— 可容纳元素的个数</li><li><input disabled="" type="checkbox"> is_empty()</li><li><input disabled="" type="checkbox"> at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li><li><input disabled="" type="checkbox"> push(item)</li><li><input disabled="" type="checkbox"> insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li><li><input disabled="" type="checkbox"> prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li><li><input disabled="" type="checkbox"> pop() —— 删除在数组末端的元素，并返回其值</li><li><input disabled="" type="checkbox"> delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li><li><input disabled="" type="checkbox"> remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li><li><input disabled="" type="checkbox"> find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li><li><input disabled="" type="checkbox"> resize(new_capacity) // 私有函数<ul><li>若数组的大小到达其容积，则变大一倍</li><li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li></ul></li></ul></li><li><input disabled="" type="checkbox"> 时间复杂度<ul><li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li><li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li></ul></li><li><input disabled="" type="checkbox"> 空间复杂度<ul><li>因为在内存中分配的空间邻近，所以有助于提高性能</li><li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li></ul></li></ul><h3 id="链表（Linked-Lists）"><a href="#链表（Linked-Lists）" class="headerlink" title="链表（Linked Lists）"></a>链表（Linked Lists）</h3><ul><li><input disabled="" type="checkbox"> 介绍：<ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists">单向链表（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/ucberkeley_webcast_htzJdKoEmO0">CS 61B —— 链表（一）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/ucberkeley_webcast_-c4I3gFYe3w">CS 61B —— 链表（二）（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo">C 代码（视频）</a> ── 并非看完整个视频，只需要看关于节点结构和内存分配那一部分即可</li><li><input disabled="" type="checkbox"> 链表 vs 数组：<ul><li><a href="https://www.coursera.org/lecture/data-structures-optimizing-performance/core-linked-lists-vs-arrays-rjBs9">基本链表 Vs 数组（视频）</a></li><li><a href="https://www.coursera.org/lecture/data-structures-optimizing-performance/in-the-real-world-lists-vs-arrays-QUaUd">在现实中，链表 Vs 数组（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo">为什么你需要避免使用链表（视频）</a></li><li><input disabled="" type="checkbox"> 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul><li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html">指向指针的指针</a></li></ul></li><li><input disabled="" type="checkbox"> 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul><li><input disabled="" type="checkbox"> size() —— 返回链表中数据元素的个数</li><li><input disabled="" type="checkbox"> empty() —— 若链表为空则返回一个布尔值 true</li><li><input disabled="" type="checkbox"> value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li><li><input disabled="" type="checkbox"> push_front(value) —— 添加元素到链表的首部</li><li><input disabled="" type="checkbox"> pop_front() —— 删除首部元素并返回其值</li><li><input disabled="" type="checkbox"> push_back(value) —— 添加元素到链表的尾部</li><li><input disabled="" type="checkbox"> pop_back() —— 删除尾部元素并返回其值</li><li><input disabled="" type="checkbox"> front() —— 返回首部元素的值</li><li><input disabled="" type="checkbox"> back() —— 返回尾部元素的值</li><li><input disabled="" type="checkbox"> insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li><li><input disabled="" type="checkbox"> erase(index) —— 删除指定索引的节点</li><li><input disabled="" type="checkbox"> value_n_from_end(n) —— 返回倒数第 n 个节点的值</li><li><input disabled="" type="checkbox"> reverse() —— 逆序链表</li><li><input disabled="" type="checkbox"> remove_value(value) —— 删除链表中指定值的第一个元素</li></ul></li><li><input disabled="" type="checkbox"> 双向链表<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists">介绍（视频）</a></li><li>并不需要实现</li></ul></li></ul><h3 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks">堆栈（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_01-usingStacksForLast-inFirst-out.mp4">使用堆栈 —— 后进先出（视频）</a></li><li><input disabled="" type="checkbox"> 可以不实现，因为使用数组来实现并不重要</li></ul><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ul><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_03-usingQueuesForFirst-inFirst-out.mp4">使用队列 —— 先进先出（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue">队列（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Circular_buffer">原型队列/先进先出（FIFO）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_04-priorityQueuesAndDeques.mp4">优先级队列（视频）</a></li><li><input disabled="" type="checkbox"> 使用含有尾部指针的链表来实现:<ul><li>enqueue(value) —— 在尾部添加值</li><li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li><li>empty()</li></ul></li><li><input disabled="" type="checkbox"> 使用固定大小的数组实现：<ul><li>enqueue(value) —— 在可容的情况下添加元素到尾部</li><li>dequeue() —— 删除最早添加的元素并返回其值</li><li>empty()</li><li>full()</li></ul></li><li><input disabled="" type="checkbox"> 花销：<ul><li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li><li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li><li>dequeue：O(1)（链表和数组）</li><li>empty：O(1)（链表和数组）</li></ul></li></ul><h3 id="哈希表（Hash-table）"><a href="#哈希表（Hash-table）" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h3><ul><li><p><input disabled="" type="checkbox">  视频：</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=8">链式哈希表（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&index=9&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">Table Doubling 和 Karp-Rabin（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&index=10&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68">PyCon 2010：The Mighty Dictionary（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=11">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=N0COwN14gt0&list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&index=4">（进阶）完美哈希（Perfect hashing）（视频）</a></li></ul></li><li><p><input disabled="" type="checkbox">  在线课程：</p><ul><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_02-understandingHashFunctions.mp4">理解哈希函数（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_03-usingHashTables.mp4">使用哈希表（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_04-supportingHashing.mp4">支持哈希（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_05-languageSupportForHashTables.mp4">哈希表的语言支持（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables">基本哈希表（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/home/week/3">数据结构（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem">电话薄问题（Phone Book Problem）（视频）</a></li><li><input disabled="" type="checkbox"> 分布式哈希表：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox">Dropbox 中的瞬时上传及存储优化（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables">分布式哈希表（视频）</a></li></ul></li></ul></li><li><p><input disabled="" type="checkbox">  使用线性探测的数组去实现</p><ul><li>hash(k, m) —— m 是哈希表的大小</li><li>add(key, value) —— 如果 key 已存在则更新值</li><li>exists(key)</li><li>get(key)</li><li>remove(key)</li></ul></li></ul><h2 id="更多的知识"><a href="#更多的知识" class="headerlink" title="更多的知识"></a>更多的知识</h2><h3 id="二分查找（Binary-search）"><a href="#二分查找（Binary-search）" class="headerlink" title="二分查找（Binary search）"></a>二分查找（Binary search）</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=D5SrAga1pno">二分查找（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search">二分查找（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/">详情</a></li><li><input disabled="" type="checkbox"> 实现：<ul><li>二分查找（在一个已排序好的整型数组中查找）</li><li>迭代式二分查找</li></ul></li></ul><h3 id="按位运算（Bitwise-operations）"><a href="#按位运算（Bitwise-operations）" class="headerlink" title="按位运算（Bitwise operations）"></a>按位运算（Bitwise operations）</h3><ul><li><input disabled="" type="checkbox"> <a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-sheet.pdf">Bits 速查表</a> ── 你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li><li><input disabled="" type="checkbox"> 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul><li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">字码（words）</a></li><li><input disabled="" type="checkbox"> 好的介绍：<br>  <a href="https://www.youtube.com/watch?v=7jkIUgLC29I">位操作（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0">C 语言编程教程 2-10：按位运算（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bit_manipulation">位操作</a></li><li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bitwise_operation">按位运算</a></li><li><input disabled="" type="checkbox"> <a href="https://graphics.stanford.edu/~seander/bithacks.html">Bithacks</a></li><li><input disabled="" type="checkbox"> <a href="http://bits.stephan-brumme.com/">位元抚弄者（The Bit Twiddler）</a></li><li><input disabled="" type="checkbox"> <a href="http://bits.stephan-brumme.com/interactive.html">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ZusiKXcz_ac">位操作技巧（Bit Hacks）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://pconrad.github.io/old_pconrad_cs16/topics/bitOps/">练习位操作</a></li></ul></li><li><input disabled="" type="checkbox"> 一补数和补码<ul><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Ones%27_complement">一补数（1s Complement）</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码（2s Complement）</a></li></ul></li><li><input disabled="" type="checkbox"> 计算置位（Set Bits）<ul><li><a href="https://youtu.be/Hzuzo9NJrlc">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan">计算比特位</a></li><li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li></ul></li><li><input disabled="" type="checkbox"> 交换值：<ul><li><a href="http://bits.stephan-brumme.com/swap.html">交换（Swap）</a></li></ul></li><li><input disabled="" type="checkbox"> 绝对值：<ul><li><a href="http://bits.stephan-brumme.com/absInteger.html">绝对整型（Absolute Integer）</a></li></ul></li></ul><h2 id="树（Trees）"><a href="#树（Trees）" class="headerlink" title="树（Trees）"></a>树（Trees）</h2><h3 id="树-——-笔记-amp-背景"><a href="#树-——-笔记-amp-背景" class="headerlink" title="树 —— 笔记 &amp; 背景"></a>树 —— 笔记 &amp; 背景</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees">系列：树（视频）</a></li><li>基本的树形结构</li><li>遍历</li><li>操作算法</li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=uWL6FJhq5fM">BFS（广度优先检索，breadth-first search）和 DFS（深度优先检索，depth-first search）</a><ul><li>BFS 笔记<ul><li>层序遍历（使用队列的 BFS 算法）</li><li>时间复杂度： O(n)</li><li>空间复杂度：<ul><li>最好情况：O(1)</li><li>最坏情况：O(n/2)=O(n)</li></ul></li></ul></li><li>DFS 笔记：<ul><li>时间复杂度：O(n)</li><li>空间复杂度：<ul><li>最好情况：O(log n) - 树的平均高度</li><li>最坏情况：O(n)</li></ul></li><li>中序遍历（DFS：左、节点本身、右）</li><li>后序遍历（DFS：左、右、节点本身）</li><li>先序遍历（DFS：节点本身、左、右）</li></ul></li></ul></li></ul><h3 id="二叉查找树（Binary-search-trees）：BSTs"><a href="#二叉查找树（Binary-search-trees）：BSTs" class="headerlink" title="二叉查找树（Binary search trees）：BSTs"></a>二叉查找树（Binary search trees）：BSTs</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=x6At0nzX92o&index=1&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">二叉查找树概览（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees">系列（视频）</a><ul><li>从符号表开始到 BST 程序</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction">介绍（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=9Jry5-82I68">MIT（视频）</a></li><li>C/C++:<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=COZK7NATh4k&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=28">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=29">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Ut90klNN264&index=30&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">在二叉查找树中找到最小和最大的元素（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=31">寻找二叉树的高度（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=32">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=86g8jAQug04&index=33&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉树：层序遍历（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&index=34&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉树的遍历：先序、中序、后序（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&index=35&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">判断一棵二叉树是否为二叉查找树（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=36">从二叉查找树中删除一个节点（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&index=37&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P">二叉查找树中序遍历的后继者（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> 实现：<ul><li><input disabled="" type="checkbox"> insert    // 往树上插值</li><li><input disabled="" type="checkbox"> get_node_count // 查找树上的节点数</li><li><input disabled="" type="checkbox"> print_values // 从小到大打印树中节点的值</li><li><input disabled="" type="checkbox"> delete_tree</li><li><input disabled="" type="checkbox"> is_in_tree // 如果值存在于树中则返回 true</li><li><input disabled="" type="checkbox"> get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li><li><input disabled="" type="checkbox"> get_min   // 返回树上的最小值</li><li><input disabled="" type="checkbox"> get_max   // 返回树上的最大值</li><li><input disabled="" type="checkbox"> is_binary_search_tree</li><li><input disabled="" type="checkbox"> delete_value</li><li><input disabled="" type="checkbox"> get_successor // 返回给定值的后继者，若没有则返回-1</li></ul></li></ul><h3 id="堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）"><a href="#堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）" class="headerlink" title="堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）"></a>堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</h3><ul><li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li><li><input disabled="" type="checkbox"> <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">堆</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction">介绍（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations">简单的实现（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees">二叉树（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark">关于树高的讨论（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations">基本操作（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees">完全二叉树（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode">伪代码（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3291">堆排序 —— 跳到起点（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort">堆排序（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap">构建一个堆（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&index=4&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">MIT：堆与堆排序（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&index=24&list=PL4BBB74C7D2A1049C">CS 61B Lecture 24：优先级队列（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=MiyLo8adrWw">构建线性时间复杂度的堆（大顶堆）</a></li><li><input disabled="" type="checkbox"> 实现一个大顶堆：<ul><li><input disabled="" type="checkbox"> insert</li><li><input disabled="" type="checkbox"> sift_up —— 用于插入元素</li><li><input disabled="" type="checkbox"> get_max —— 返回最大值但不移除元素</li><li><input disabled="" type="checkbox"> get_size() —— 返回存储的元素数量</li><li><input disabled="" type="checkbox"> is_empty() —— 若堆为空则返回 true</li><li><input disabled="" type="checkbox"> extract_max —— 返回最大值并移除</li><li><input disabled="" type="checkbox"> sift_down —— 用于获取最大值元素</li><li><input disabled="" type="checkbox"> remove(i) —— 删除指定索引的元素</li><li><input disabled="" type="checkbox"> heapify —— 构建堆，用于堆排序</li><li><input disabled="" type="checkbox"> heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆或者小顶堆进行就地排序</li></ul></li></ul><h2 id="排序（Sorting）"><a href="#排序（Sorting）" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h2><ul><li><p><input disabled="" type="checkbox">  笔记:</p></li><li><p>实现各种排序，知道每种排序的最坏、最好和平均的复杂度分别是什么场景:</p><ul><li>不要用冒泡排序 - 效率太差 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li></ul></li><li><p><input disabled="" type="checkbox">  排序算法的稳定性 (“快排是稳定的么?”)</p><ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms">排序算法的稳定性</a></li><li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/">排序算法的稳定性</a></li><li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf">排序算法 - 稳定性</a></li></ul></li><li><p><input disabled="" type="checkbox">  哪种排序算法可以用链表？哪种用数组？哪种两者都可？</p><ul><li>并不推荐对一个链表排序，但归并排序是可行的.</li><li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/">链表的归并排序</a></li></ul></li><li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p></li><li><p><a href="https://www.coursera.org/learn/algorithms-part1/home/week/3">Sedgewick ── 归并排序（5个视频）</a></p><ul><li><input disabled="" type="checkbox"> <ol><li>归并排序</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2"><li>自下而上的归并排序</li></ol></li><li><input disabled="" type="checkbox"> <ol start="3"><li>排序复杂度</li></ol></li><li><input disabled="" type="checkbox"> <ol start="4"><li>比较器</li></ol></li><li><input disabled="" type="checkbox"> <ol start="5"><li>稳定性</li></ol></li></ul></li><li><p><a href="https://www.coursera.org/learn/algorithms-part1/home/week/3">Sedgewick ── 快速排序（4个视频）</a></p><ul><li><input disabled="" type="checkbox"> <ol><li>快速排序</li></ol></li><li><input disabled="" type="checkbox"> <ol start="2"><li>选择</li></ol></li><li><input disabled="" type="checkbox"> <ol start="3"><li>重复键值</li></ol></li><li><input disabled="" type="checkbox"> <ol start="4"><li>系统排序</li></ol></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=P00xJgWzz2c&index=1&list=PL89B61F78B552C1AB">冒泡排序（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=ni_zk257Nqo&index=7&list=PL89B61F78B552C1AB">冒泡排序分析（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&index=3&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">插入排序 &amp; 归并排序（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&index=2&list=PL89B61F78B552C1AB">插入排序（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=GCae1WNvnZM&index=3&list=PL89B61F78B552C1AB">归并排序（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&index=4&list=PL89B61F78B552C1AB">快排（视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&index=8&list=PL89B61F78B552C1AB">选择排序（视频）</a></p></li><li><p><input disabled="" type="checkbox">  归并排序代码：</p><ul><li><input disabled="" type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c">使用外部数组（C语言）</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/jwasham/practice-python/blob/master/merge_sort/merge_sort.py">使用外部数组（Python语言）</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc">对原数组直接排序（C++）</a></li></ul></li><li><p><input disabled="" type="checkbox">  快速排序代码：</p><ul><li><input disabled="" type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c">实现（C语言）</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c">实现（C语言）</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/jwasham/practice-python/blob/master/quick_sort/quick_sort.py">实现（Python语言）</a></li></ul></li><li><p><input disabled="" type="checkbox">  实现:</p><ul><li><input disabled="" type="checkbox"> 归并：平均和最差情况的时间复杂度为 O(n log n)。</li><li><input disabled="" type="checkbox"> 快排：平均时间复杂度为 O(n log n)。</li><li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li><li>关于堆排序，请查看前文堆的数据结构部分。</li></ul></li><li><p><input disabled="" type="checkbox">  有兴趣的话，还有一些补充，但并不是必须的:</p><ul><li><a href="https://www.coursera.org/learn/algorithms-part2/home/week/3">Sedgewick──基数排序 (6个视频)</a><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/vGHvb/strings-in-java">1. Java 中的字符串</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/2pi1Z/key-indexed-counting">2. 键值索引计数（Key Indexed Counting）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/c1U7L/lsd-radix-sort">3. Least Significant Digit First String Radix Sort</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/gFxwG/msd-radix-sort">4. Most Significant Digit First String Radix Sort</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/crkd5/3-way-radix-quicksort">5. 3中基数快速排序</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TH18W/suffix-arrays">6. 后继数组（Suffix Arrays）</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort">基数排序</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=xhr26ia4k38">基数排序（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&index=7&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">基数排序, 计数排序 (线性时间内)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&index=8&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">随机算法: 矩阵相乘, 快排, Freivalds’ 算法（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=14">线性时间内的排序（视频）</a></li></ul></li></ul><p>总结一下，这是<a href="https://www.youtube.com/watch?v=kPRA0W1kECg">15种排序算法</a>的可视化表示。如果你需要有关此主题的更多详细信息，请参阅“<a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a>”中的“排序”部分。</p><h2 id="图（Graphs）"><a href="#图（Graphs）" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p><ul><li><p>笔记:</p><ul><li>有4种基本方式在内存里表示一个图:<ul><li>对象和指针</li><li>邻接矩阵</li><li>邻接表</li><li>邻接图</li></ul></li><li>熟悉以上每一种图的表示法，并了解各自的优缺点</li><li>广度优先搜索和深度优先搜索：知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li><li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li></ul></li><li><p>MIT（视频）：</p><ul><li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=13">广度优先搜索</a></li><li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=14">深度优先搜索</a></li></ul></li><li><p><input disabled="" type="checkbox">  Skiena 教授的课程 - 很不错的介绍:</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=11">CSE373 2012 - 课程 11 - 图的数据结构（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=g5vF8jscteo&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=12">CSE373 2012 - 课程 12 - 广度优先搜索（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=13">CSE373 2012 - 课程 13 - 图的算法（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&index=14&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 14 - 图的算法 (1)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&index=15&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 15 - 图的算法 (2)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&index=16&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 16 - 图的算法 (3)（视频）</a></li></ul></li><li><p><input disabled="" type="checkbox">  图 (复习和其他):</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&index=15&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006 单源最短路径问题（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&index=16&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006 Dijkstra 算法（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ozsuci5pIso&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=17">6.006 Bellman-Ford 算法（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=18">6.006 Dijkstra 效率优化（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&index=6&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Aduni: 图的算法 I - 拓扑排序，最小生成树，Prim 算法 - 第六课（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=7">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=8">Aduni: 图的算法 III: 最短路径 - 第八课（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=9">Aduni: 图的算法. IV: 几何算法介绍 - 第九课（视频）</a></li><li><input disabled="" type="checkbox"> <del><a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&t=3489">CS 61B 2014 (从 58:09 开始)（视频）</a></del></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&index=19">CS 61B 2014: 加权图（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&index=16&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">贪心算法: 最小生成树（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=RpgcYiky7uw">图的算法之强连通分量 Kosaraju 算法（视频）</a></li></ul></li><li><p>完整的 Coursera 课程:</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome">图的算法（视频）</a></li></ul></li><li><p>我会实现:</p><ul><li><input disabled="" type="checkbox"> DFS 邻接表 (递归)</li><li><input disabled="" type="checkbox"> DFS 邻接表 (栈迭代)</li><li><input disabled="" type="checkbox"> DFS 邻接矩阵 (递归)</li><li><input disabled="" type="checkbox"> DFS 邻接矩阵 (栈迭代)</li><li><input disabled="" type="checkbox"> BFS 邻接表</li><li><input disabled="" type="checkbox"> BFS 邻接矩阵</li><li><input disabled="" type="checkbox"> 单源最短路径问题 (Dijkstra)</li><li><input disabled="" type="checkbox"> 最小生成树</li><li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul><li><input disabled="" type="checkbox"> 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li><li><input disabled="" type="checkbox"> 拓扑排序</li><li><input disabled="" type="checkbox"> 计算图中的连通分支</li><li><input disabled="" type="checkbox"> 列出强连通分量</li><li><input disabled="" type="checkbox"> 检查双向图</li></ul></li></ul></li></ul><p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p><h2 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h2><h3 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><ul><li><input disabled="" type="checkbox"> Stanford 大学关于递归 &amp; 回溯的课程:<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&list=PLFE6E58F856038C69&index=8">课程 8 | 抽象编程（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&list=PLFE6E58F856038C69&index=9">课程 9 | 抽象编程（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&index=10&list=PLFE6E58F856038C69">课程 10 | 抽象编程（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&list=PLFE6E58F856038C69&index=11">课程 11 | 抽象编程（视频）</a></li></ul></li><li>什么时候适合使用</li><li>尾递归会更好么?<ul><li><input disabled="" type="checkbox"> <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad">什么是尾递归以及为什么它如此糟糕?</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=L1jjXGfxozc">尾递归（视频）</a></li></ul></li></ul><h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><ul><li>在你的面试中或许没有任何动态规划的问题，但能够知道一个题目可以使用动态规划来解决是很重要的。</li><li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li><li>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</li><li><input disabled="" type="checkbox"> 视频:<ul><li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&t=1718">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&t=2749">Skiena: CSE373 2012 - 课程 20 - 编辑距离（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&t=406">Skiena: CSE373 2012 - 课程 21 - 动态规划举例（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=22">Skiena: CSE373 2012 - 课程 22 - 动态规划应用（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3558">Simonson: 动态规划 0 (starts at 59:18)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&index=11&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Simonson: 动态规划 I - 课程 11（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=12">Simonson: 动态规划 II - 课程 12（视频）</a></li><li><input disabled="" type="checkbox"> 单独的 DP 问题 (每一个视频都很短)：<a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr">动态规划（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> 耶鲁课程笔记:<ul><li><input disabled="" type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming">动态规划</a></li></ul></li><li><input disabled="" type="checkbox"> Coursera 课程:<ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem">RNA 二级结构问题（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm">动态规划算法（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm">DP 算法描述（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm">DP 算法的运行时间（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation">DP vs 递归实现（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment">全局成对序列排列（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment">本地成对序列排列（视频）</a></li></ul></li></ul><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ul><li>可选：<a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc">UML 2.0系列（视频）</a></li><li>SOLID 面向对象编程原则：<a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A">SOLID 原则（视频）</a></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&index=3">UML 统一建模语言概览 (视频)</a></li><li><input disabled="" type="checkbox"> 主要有如下的设计模式:<ul><li><input disabled="" type="checkbox"> 策略模式（strategy）</li><li><input disabled="" type="checkbox"> 单例模式（singleton）</li><li><input disabled="" type="checkbox"> 适配器模式（adapter）</li><li><input disabled="" type="checkbox"> 原型模式（prototype）</li><li><input disabled="" type="checkbox"> 装饰器模式（decorator）</li><li><input disabled="" type="checkbox"> 访问者模式（visitor）</li><li><input disabled="" type="checkbox"> 工厂模式，抽象工厂模式（factory, abstract factory）</li><li><input disabled="" type="checkbox"> 外观模式（facade）</li><li><input disabled="" type="checkbox"> 观察者模式（observer）</li><li><input disabled="" type="checkbox"> 代理模式（proxy）</li><li><input disabled="" type="checkbox"> 委托模式（delegate）</li><li><input disabled="" type="checkbox"> 命令模式（command）</li><li><input disabled="" type="checkbox"> 状态模式（state）</li><li><input disabled="" type="checkbox"> 备忘录模式（memento）</li><li><input disabled="" type="checkbox"> 迭代器模式（iterator）</li><li><input disabled="" type="checkbox"> 组合模式（composite）</li><li><input disabled="" type="checkbox"> 享元模式（flyweight）</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&t=3344">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&index=12&list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=7sduBHuex4c&index=13&list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07">系列视频（27个）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124">Head First 设计模型</a><ul><li>尽管《设计模式：可复用面向对象软件的基础》才是这方面的经典，但是我还是认为Head First对于新手更加友好。</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://sourcemaking.com/design-patterns-and-tips">实际操作：设计模式和对入门开发者的建议</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/kamranahmedse/design-patterns-for-humans#structural-design-patterns">Design patterns for humans</a></li></ul><h3 id="组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）"><a href="#组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）" class="headerlink" title="组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）"></a>组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U">数据技巧: 如何找出阶乘、排列和组合(选择)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4">来点学校的东西: 概率（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ">来点学校的东西: 概率和马尔可夫链（视频）</a></li><li><input disabled="" type="checkbox"> 可汗学院:<ul><li>课程设置:<ul><li><input disabled="" type="checkbox"> <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic">概率理论基础</a></li></ul></li><li>只有视频 - 41 (每一个都短小精悍):<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&list=PLC58778F28211FA19">概率解释（视频）</a></li></ul></li></ul></li></ul><h3 id="NP-NP-完全和近似算法"><a href="#NP-NP-完全和近似算法" class="headerlink" title="NP, NP-完全和近似算法"></a>NP, NP-完全和近似算法</h3><ul><li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题，而且能在面试官试图忽悠你的时候识别出他们。</li><li>知道 NP 完全是什么意思.</li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=23">计算复杂度（视频）</a></li><li><input disabled="" type="checkbox"> Simonson:<ul><li><input disabled="" type="checkbox"> <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939">贪心算法. II &amp; 介绍 NP-完全性（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&index=16&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">NP-完全性 II &amp; 归约（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&index=17&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">NP-完全性 III（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=18">NP-完全性 IV（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> Skiena:<ul><li><input disabled="" type="checkbox"> <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&t=1508">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=27Al52X3hd4&index=24&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 24 - NP-完全性证明（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&index=25&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">CSE373 2012 - 课程 25 - NP-完全性挑战（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22">复杂度: P, NP, NP-完全性, 规约（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24">复杂度: 近视算法 Algorithms（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">复杂度: 固定参数算法（视频）</a></li><li>Peter Norvik 讨论旅行商问题的近似最优解:<ul><li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb">Jupyter 笔记本</a></li></ul></li><li>《算法导论》（CLRS）的第 1048 - 1140 页。</li></ul><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><ul><li><input disabled="" type="checkbox"> LRU 缓存:<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=R5ON3iwx78M">LRU 的魔力 (100 Days of Google Dev)（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI">实现 LRU（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU">LeetCode - 146 LRU Cache (C++)（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> CPU 缓存:<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&index=24">MIT 6.004 L15: 存储体系（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&index=25&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-">MIT 6.004 L16: 缓存的问题（视频）</a></li></ul></li></ul><h3 id="进程（Processe）和线程（Thread）"><a href="#进程（Processe）和线程（Thread）" class="headerlink" title="进程（Processe）和线程（Thread）"></a>进程（Processe）和线程（Thread）</h3><ul><li><input disabled="" type="checkbox"> 计算机科学 162 - 操作系统 (25 个视频):<ul><li>视频 1-11 是关于进程和线程</li><li><a href="https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c">操作系统和系统编程（视频）</a></li></ul></li><li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread">进程和线程的区别是什么?</a></li><li>涵盖了:<ul><li>进程、线程、协程<ul><li>进程和线程的区别</li><li>进程</li><li>线程</li><li>锁</li><li>互斥</li><li>信号量</li><li>监控</li><li>他们是如何工作的</li><li>死锁</li><li>活锁</li></ul></li><li>CPU 活动, 中断, 上下文切换</li><li>现代多核处理器的并发式结构</li><li><a href="https://www.youtube.com/watch?v=LKe7xK0bF7o&list=PLCiOXwirraUCBE9i_ukL8_Kfg6XNv7Se8&index=2">分页（paging），分段（segmentation）和虚拟内存（视频）</a></li><li><a href="https://www.youtube.com/watch?v=uFKi2-J-6II&list=PLCiOXwirraUCBE9i_ukL8_Kfg6XNv7Se8&index=3">中断（视频）</a></li><li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li><li>线程资源需要（在同一个进程内和其他线程共享以上（除了栈）的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li><li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li><li>上下文切换<ul><li>操作系统和底层硬件是如何初始化上下文切换的？</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M">C++ 的线程 (系列 - 10 个视频)</a></li><li><input disabled="" type="checkbox"> Python 的并发 (视频):<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1">线程系列</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM">Python 线程</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s">理解 Python 的 GIL (2010)</a><ul><li><a href="http://www.dabeaz.com/GIL">参考</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">David Beazley - Python 协程 - PyCon 2015</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ZzfHjytDceU">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY">Python 中的互斥</a></li></ul></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>涵盖了:<ul><li>单元测试是如何工作的</li><li>什么是模拟对象</li><li>什么是集成测试</li><li>什么是依赖注入</li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=SAhJf36_u5U">James Bach 讲敏捷软件测试（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU">James Bach 软件测试公开课（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://vimeo.com/83960706">Steve Freeman - 测试驱动的开发（视频）</a><ul><li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf">slides</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.obeythetestinggoat.com/pages/book.html#toc">Python：测试驱动的 Web 开发</a></li><li><input disabled="" type="checkbox"> 依赖注入:<ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ">视频</a></li><li><input disabled="" type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html">测试之道</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html">如何编写测试</a></li></ul><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li>在操作系统中是如何运作的</li><li>在操作系统部分的视频里有很多资料</li></ul><h3 id="字符串搜索和操作"><a href="#字符串搜索和操作" class="headerlink" title="字符串搜索和操作"></a>字符串搜索和操作</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TH18W/suffix-arrays">Sedgewick──后缀数组（Suffix Arrays）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/home/week/4">Sedgewick──子字符串搜寻（视频）</a><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/n3ZpG/introduction-to-substring-search">1. 子字符串搜寻导论</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/2Kn5i/brute-force-substring-search">2. 子字符串搜寻──暴力法</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/TAtDr/knuth-morris-pratt">3. KMP算法</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/CYxOT/boyer-moore">4. Boyer-Moore算法</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/3KiqT/rabin-karp">5. Rabin-Karp算法</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text">文本的搜索模式（视频）</a></li></ul><p>如果你需要有关此主题的更多详细信息，请参阅“<a href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98%E7%9A%84%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9">一些主题的额外内容</a>”中的“字符串匹配”部分。</p><h3 id="字典树（Tries）"><a href="#字典树（Tries）" class="headerlink" title="字典树（Tries）"></a>字典树（Tries）</h3><ul><li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li><li>阅读代码，但不实现。</li><li><a href="https://www.coursera.org/learn/algorithms-part2/home/week/4">Sedgewick──字典树（3个视频）</a><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/CPVdr/r-way-tries">1. R Way字典树</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/yQM8K/ternary-search-tries">2. 三元搜索树</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2/lecture/jwNmV/character-based-operations">3. 基于字符串的操作</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries">数据结构笔记及编程技术</a></li><li><input disabled="" type="checkbox"> 短课程视频：<ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries">对字典树的介绍（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries">字典树的性能（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie">实现一棵字典树（视频）</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure">字典树：一个被忽略的数据结构</a></li><li><input disabled="" type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/">TopCoder —— 使用字典树</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU">标准教程（现实中的用例）（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&index=16&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf">MIT，高阶数据结构，字符串（视频中间有点困难）（视频）</a></li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li><input disabled="" type="checkbox"> 简单8位：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU">浮点数的表示形式-1（视频──计算中存在错误，请参见视频说明）</a></li><li><input disabled="" type="checkbox"> 32位：<a href="https://www.youtube.com/watch?v=50ZYcZebIec">IEEE754 32位浮点二进制（视频）</a></li></ul><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul><li><input disabled="" type="checkbox"> <a href="http://www.joelonsoftware.com/articles/Unicode.html">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li><li><input disabled="" type="checkbox"> <a href="http://kunststube.net/encoding/">关于处理文本需要的编码和字符集，每个程序员绝对需要知道的知识</a></li></ul><h3 id="字节序（Endianness）"><a href="#字节序（Endianness）" class="headerlink" title="字节序（Endianness）"></a>字节序（Endianness）</h3><ul><li><a href="https://web.archive.org/web/20180107141940/http://www.cs.umd.edu:80/class/sum2003/cmsc311/Notes/Data/endian.html">大/小端序</a></li><li><a href="https://www.youtube.com/watch?v=JrNF0KRAlyo">大端序 Vs 小端序（视频）</a></li><li><a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0">由里入内的大端序与小端序（视频）</a><ul><li>对于内核开发非常具有技术性，如果大多数的内容听不懂也没关系。</li><li>前半部就已经足够了。</li></ul></li></ul><h3 id="网络（视频）"><a href="#网络（视频）" class="headerlink" title="网络（视频）"></a>网络（视频）</h3><ul><li><strong>如果你具有网络经验或想成为可靠性工程师或运维工程师，期待你的问题</strong></li><li>知道这些有益无害，多多益善!</li><li><input disabled="" type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/computers-and-internet-code-org">可汗学院</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8">UDP 和 TCP：网络传输协议中的数据压缩（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0">TCP/IP 和 OSI 模型解释！（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=nomyRJehhnM">互联网上的数据包传输。网络和 TCP/IP 教程。（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=WGJrLqtX7As">HTTP（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0">SSL 和 HTTPS（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM">SSL/TLS（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8">HTTP 2.0（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j">视频系列（21个视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记（视频）</a></li><li><input disabled="" type="checkbox"> 套接字（Sockets）：<ul><li><a href="https://www.youtube.com/watch?v=6G_W54zuadg&t=6s">Java──套接字──介绍（视频）</a></li><li><a href="https://www.youtube.com/watch?v=G75vN2mnJeQ">套接字编程（视频）</a></li></ul></li></ul><h2 id="系统设计、可伸缩性、数据处理"><a href="#系统设计、可伸缩性、数据处理" class="headerlink" title="系统设计、可伸缩性、数据处理"></a>系统设计、可伸缩性、数据处理</h2><p><strong>如果你已经拥有了4年以上的编程经验，那你可以来看看有关系统设计的问题</strong></p><ul><li>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。要花费相当多的时间在这个主题上。</li><li>考量：<ul><li>伸缩性<ul><li>把大数据集提取为单一值</li><li>大数据集转换</li><li>处理大量的数据集</li></ul></li><li>系统<ul><li>功能集</li><li>接口</li><li>类层次结构</li><li>在特定的约束下设计系统</li><li>轻量和健壮性</li><li>权衡和折衷</li><li>性能分析和优化</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <strong>从这里开始</strong>：<a href="https://github.com/donnemartin/system-design-primer">系统设计入门</a></li><li><input disabled="" type="checkbox"> <a href="http://www.hiredintech.com/system-design/">HiredInTech：系统设计</a></li><li><input disabled="" type="checkbox"> <a href="https://www.quora.comhow-do-i-prepare-to-answer-design-questions-in-a-technical-interview/?redirected_qid=1500023">该如何为技术面试里设计方面的问题做准备?</a></li><li><input disabled="" type="checkbox"> <a href="http://blog.gainlo.co/index.php/2015/10/228-things-you-need-to-know-before-system-design-interviews/">在系统设计面试前必须知道的 8 件事</a></li><li><input disabled="" type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/">算法设计</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM">数据库范式 - 1NF, 2NF, 3NF and 4NF（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://github.com/checkcheckzz/system-design-interview">系统设计面试</a> - 这一部分有很多的资源浏览一下我放在下面的文章和例子。</li><li><input disabled="" type="checkbox"> <a href="http://www.palantir.com/2011/10how-to-rock-a-systems-design-interview/">如何在系统设计面试中脱颖而出</a></li><li><input disabled="" type="checkbox"> <a href="http://everythingisdata.wordpress.com/2009/10/17numbers-everyone-should-know/">每个人都该知道的一些数字</a></li><li><input disabled="" type="checkbox"> <a href="http://blog.tsunanet.net/2010/11how-long-does-it-take-to-make-context.html">上下文切换操作会耗费多少时间?</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=srOgpXECblk">跨数据中心的事务（视频）</a></li><li><input disabled="" type="checkbox"> <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/">简明 CAP 理论介绍</a></li><li><input disabled="" type="checkbox"> 共识算法：<ul><li><input disabled="" type="checkbox"> Paxos：<a href="https://www.youtube.com/watch?v=s8JqcZtvnsM">Paxos协议──Computerphile（视频）</a></li><li><input disabled="" type="checkbox"> Raft: <a href="https://www.youtube.com/watch?v=P9Ydif5_qvE">Raft 分布式共识算法简介（视频）</a><ul><li><input disabled="" type="checkbox"> <a href="https://raft.github.io/">易于阅读的论文</a></li><li><input disabled="" type="checkbox"> [信息图]</li></ul></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html">一致性哈希</a></li><li><input disabled="" type="checkbox"> <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html">NoSQL 模式</a></li><li><input disabled="" type="checkbox"> 可伸缩性:<ul><li>你不需要知道所有这些。只需挑选一些你感兴趣的东西即可。</li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=-W9F__D3oY4">很棒的概述（视频）</a></li><li><input disabled="" type="checkbox"> 简短系列:<ul><li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones">克隆</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">数据库</a></li><li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache">缓存</a></li><li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism">异步</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.aosabook.org/en/distsys.html">可伸缩的 Web 架构和分布式系统</a></li><li><input disabled="" type="checkbox"> <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf">错误的分布式系统解释</a></li><li><input disabled="" type="checkbox"> <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">实用编程技术</a><ul><li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html">extra: Google Pregel 图形处理</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=modXC5IWTJI">Jeff Dean - 在 Goolge 构建软件系统（视频）</a></li><li><input disabled="" type="checkbox"> <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/">可伸缩系统架构设计介绍</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0">How Google Does Planet-Scale Engineering for Planet-Scale Infra（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/">算法的重要性</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html">分片（Sharding）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=oodS71YtkGU">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建”（视频）</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&index=4">Long Game 工程实践 - Astrid Atkinson Keynote（视频）</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul><li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok">视频</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li><li><input disabled="" type="checkbox"> <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/">如何对大数据集去重</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o">Etsy 的扩展和工程文化探究 Jon Cowie（视频）</a></li><li><input disabled="" type="checkbox"> <a href="http://thenewstack.io/led-amazon-microservices-architecture/">是什么造就了 Amazon 自己的微服务架构</a></li><li><input disabled="" type="checkbox"> <a href="https://eng.uber.com/trip-data-squeeze/">压缩还是不压缩，是 Uber 面临的问题</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html">异步 I/O Tarantool 队列</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html">什么时候应该用近似查询处理?</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html">Spanner</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html">机器学习驱动的编程: 新世界的新编程方式</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html">日服务数百万请求的图像优化技术</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html">Patreon 架构</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html">现代缓存设计</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html">Facebook 实时视频流扩展</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html">对延时敏感的应用是否应该使用 Docker?</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html">360 度解读 Netflix 技术栈</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it">延迟无处不在 - 如何搞定它？</a></li><li><input disabled="" type="checkbox"> <a href="http://martinfowler.com/articles/serverless.html">无服务器架构</a></li><li><input disabled="" type="checkbox"> <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html">Justin.Tv 实时视频播放架构</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/plentyoffish-architecture">PlentyOfFish 架构</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li><li><input disabled="" type="checkbox"> <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html">ESPN’s 架构扩展</a></li><li><input disabled="" type="checkbox"> 下面“消息传递，序列化和队列系统”部分的内容会提到什么样的技术能把各种服务整合到一起</li><li><input disabled="" type="checkbox"> Twitter:<ul><li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter”（视频）</a></li><li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability">时间线的扩展</a></li></ul></li><li>更多内容可以查看<a href="#%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97">视频系列部分</a>的“大规模数据挖掘”视频系列。</li></ul></li><li><input disabled="" type="checkbox"> 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul><li>复习: <a href="https://github.com/donnemartin/system-design-primer">系统设计入门</a></li><li><a href="http://www.hiredintech.com/system-design/">HiredInTech 的系统设计</a></li><li><a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf">备忘单</a></li><li>流程:<ol><li>理解问题和范围:<ul><li>在面试官的帮助下定义用例</li><li>提出附加功能的建议</li><li>去掉面试官认定范围以外的内容</li><li>假定高可用是必须的，而且要作为一个用例</li></ul></li><li>考虑约束:<ul><li>问一下每月请求量</li><li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li><li>评估读写所占的百分比</li><li>评估的时候牢记 2/8 原则</li><li>每秒写多少数据</li><li>总的数据存储量要考虑超过 5 年的情况</li><li>每秒读多少数据</li></ul></li><li>抽象设计:<ul><li>分层 (服务, 数据, 缓存)</li><li>基础设施: 负载均衡, 消息</li><li>粗略的概括任何驱动整个服务的关键算法</li><li>考虑瓶颈并指出解决方案</li></ul></li></ol></li><li>练习:<ul><li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&context=compsci">设计一个 CDN 网络</a></li><li><a href="https://blog.twitter.com/2010/announcing-snowflake">设计一个随机唯一 ID 生成系统</a></li><li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html">设计一个在线多人卡牌游戏</a></li><li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis">设计一个键值数据库</a></li><li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html">设计一个图片分享系统</a></li><li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf">设计一个推荐系统</a></li><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/">设计一个短域名生成系统</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/">设计一个缓存系统</a></li></ul></li></ul></li></ul><hr><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。这对经常性的巩固很有帮助。</code></pre><ul><li>[ ] 2-3分钟的简短主题视频系列（23个视频）<ul><li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&index=22">视频</a></li></ul></li><li><input disabled="" type="checkbox"> 2-5分钟的简短主题视频系列──Michael Sambol（18个视频）：<ul><li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ">视频</a></li></ul></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part1">Sedgewick 视频 ── 算法I</a></li><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-part2">Sedgewick 视频 ── 算法II</a></li></ul><h2 id="编程问题练习"><a href="#编程问题练习" class="headerlink" title="编程问题练习"></a>编程问题练习</h2><p>现在你已经了解了上面所有的计算机科学主题，是时候练习回答编程问题了。</p><p><strong>编程问题的实践并不是要记住编程问题的答案</strong>。</p><p>为什么需要练习编程问题：</p><ul><li>快速识别问题，以及如何应用正确的数据结构及算法</li><li>收集问题的要求</li><li>像在面试中一样谈论问题</li><li>在白板或纸上而非计算机上编码</li><li>计算解决方案的时间和空间的复杂性</li><li>测试你的解决方案</li></ul><p>这里有个很棒的入门教学，内容是如何在面试中有条不紊，并且有互动沟通地解决问题。这种能力可以从面试书籍中获得，但我觉得这个也很棒：<a href="http://www.hiredintech.com/algorithm-design/">算法设计画布</a>。</p><p>家里没有白板？那讲得通。我是一个怪人，有一个很大的白板。从白板商店买了一个大的绘图板，而不是白板。你可以坐在沙发上练习。这是我的“沙发白板”。我在照片中添加了笔以便进行缩放。如果你使用笔，则希望可以擦除。快速变得凌乱。我用铅笔和橡皮擦。</p><p><img src="https://d3j2pkmjtin6ou.cloudfront.net/art_board_sm_2.jpg" alt="我的沙发白板"></p><p>补充：</p><ul><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/mathematics-for-topcoders/">Topcoder的数学</a></li><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/dynamic-programming-from-novice-to-advanced/">动态编程──从新手到高级</a></li><li><a href="https://web.archive.org/web/20160906124824/http://courses.csail.mit.edu/iap/interview/materials.php">MIT 面试材料</a></li><li><a href="http://exercism.io/languages">练习以掌握特定语言</a></li></ul><p><strong>阅读并练习编程问题（按此顺序）</strong>：</p><ul><li><input disabled="" type="checkbox"> <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html">编程面试公开：下一份工作的秘密，第二版</a><ul><li>C，C ++ 和 Java 的答案</li></ul></li><li><input disabled="" type="checkbox"> <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/">破解编码面试，第六版</a><ul><li>Java 答案</li></ul></li></ul><p>请参阅上方的<a href="#%E4%B9%A6%E5%8D%95">书单</a>。</p><h2 id="编程练习和挑战"><a href="#编程练习和挑战" class="headerlink" title="编程练习和挑战"></a>编程练习和挑战</h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。<br>尽量坚持每天做编码练习，越多越好。</p><ul><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/how-to-find-a-solution/">如何找到解决方案</a></li><li><a href="https://www.topcoder.com/community/competitive-programming/tutorials/how-to-dissect-a-topcoder-problem-statement/">如何剖析 Topcoder 题目描述</a></li></ul><p>编码面试问题视频：</p><ul><li><a href="https://www.youtube.com/watch?v=NBcqBddFbZw&list=PLamzFoFxwoNjPfxzaWqs7cZGsPYy0x_gI">IDeserve（88个视频）</a></li><li><a href="https://www.youtube.com/user/tusharroy2525/playlists?shelf_id=2&view=50&sort=dd">Tushar Roy（5个播放列表）</a><ul><li>超级解决问题的方法</li></ul></li><li><a href="https://www.youtube.com/playlist?list=PLU_sdQYzUj2keVENTP0a5rdykRSgg9Wp-">Nick White──LeetCode 解题（187个视频）</a><ul><li>良好的解决方案和代码解释</li><li>你可以在短时间内看好几个</li></ul></li><li><a href="https://youtube.com/FisherCoder">FisherCoder──LeetCode 解题</a></li></ul><p>编码练习平台:</p><ul><li><a href="https://leetcode.com/">LeetCode</a><ul><li>我最喜欢的编码问题网站，值得你准备的1-2个月的订阅费用</li><li><a href="https://github.com/fishercoder1534/Leetcode">FisherCoder 的 LeetCode 解题</a></li><li>请参阅上面的 Nick White 视频，以获得简短的代码</li></ul></li><li><a href="https://www.hackerrank.com/">HackerRank</a></li><li><a href="https://www.topcoder.com/">TopCoder</a></li><li><a href="https://www.interviewcake.com/">InterviewCake</a></li><li><a href="http://www.geeksforgeeks.org/">http://www.geeksforgeeks.org/</a></li><li><a href="https://www.interviewbit.com/invite/icjf">InterviewBit</a></li><li><a href="https://projecteuler.net/index.php?section=problems">Project Euler (数学方向为主)</a></li><li><a href="https://code-exercises.com/">Code Exercises</a></li></ul><p>语言学习网站，附带编码挑战：</p><ul><li><a href="http://www.codewars.com/">Codewars</a></li><li><a href="https://codility.com/programmers/">Codility</a></li><li><a href="https://www.hackerearth.com/">HackerEarth</a></li><li><a href="http://www.spoj.com/">Sphere Online Judge (spoj)</a></li><li><a href="https://www.codechef.com/">Codechef</a></li></ul><p>编码挑战项目：</p><ul><li><a href="https://github.com/donnemartin/interactive-coding-challenges">Python 交互式编码面试挑战</a></li></ul><p>模拟面试：</p><ul><li><a href="http://www.gainlo.co/">Gainlo.co：来自大公司的模拟面试官</a>──我使用了它，它帮助我减轻了电话屏幕和现场面试的压力</li><li><a href="https://www.pramp.com/">Pramp：模拟来自/与同行的面试</a>──点对点方式练习面试</li><li><a href="https://refdash.com/">Refdash：模拟面试和加急面试</a>──跳过与科技公司的多次面试，帮助求职者快速追踪</li><li><a href="https://interviewing.io/">interviewing.io：与高级工程师进行模拟面试</a>──与来自 FAANG（译者注：Facebook, Amazon, Apple, Netflix and Google） 的高级工程师进行匿名算法/系统设计面试。</li></ul><h2 id="当你临近面试时"><a href="#当你临近面试时" class="headerlink" title="当你临近面试时"></a>当你临近面试时</h2><ul><li>搞定代码面试──第二集 (视频):<ul><li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo">Cracking The Code Interview</a></li><li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo">Cracking the Coding Interview - 全栈系列</a></li></ul></li></ul><h2 id="你的简历"><a href="#你的简历" class="headerlink" title="你的简历"></a>你的简历</h2><ul><li>请参阅“破解编码面试”和“编程面试的背面”中的建立准备项。</li></ul><h2 id="当面试来临的时候"><a href="#当面试来临的时候" class="headerlink" title="当面试来临的时候"></a>当面试来临的时候</h2><p>随着下面列举的问题思考下你可能会遇到的 20 个面试问题，每个问题准备 2-3 种回答。准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事。</p><ul><li>你为什么想得到这份工作？</li><li>你解决过的最有难度的问题是什么？</li><li>面对过的最大挑战是什么?</li><li>见过的最好或者最坏的设计是怎么样的?</li><li>对某个产品提出改进建议。</li><li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li><li>你的什么技能或者经验是你的角色中不可或缺的，为什么？</li><li>你在某份工作或某个项目中最享受的是什么?</li><li>你在某份工作或某个项目中面临过的最大挑战是什么?</li><li>你在某份工作或某个项目中遇到过的最硬的 Bug 是什么样的？</li><li>你在某份工作或某个项目中学到了什么？</li><li>你在某份工作或某个项目中哪些地方还可以做的更好？</li></ul><h2 id="问面试官的问题"><a href="#问面试官的问题" class="headerlink" title="问面试官的问题"></a>问面试官的问题</h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):</code></pre><ul><li>团队多大规模?</li><li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li><li>经常会为截止日期（deadlines）加班么? 或者是有弹性的?</li><li>团队里怎么做技术选型?</li><li>每周平均开多少次会?</li><li>你觉得工作环境有助于员工集中精力吗?</li><li>目前正在做什么工作?</li><li>喜欢这些事情吗?</li><li>工作期限是怎么样的?</li><li>工作生活怎么平衡?</li></ul><h2 id="当你获得了梦想的职位"><a href="#当你获得了梦想的职位" class="headerlink" title="当你获得了梦想的职位"></a>当你获得了梦想的职位</h2><p>恭喜你！</p><p>继续学习。</p><p>活到老，学到老。</p><hr><hr><hr><pre><code>下面的内容都是可选的。通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。你将会成为一个更全面的软件工程师。</code></pre><hr><hr><hr><h2 id="额外书籍"><a href="#额外书籍" class="headerlink" title="额外书籍"></a>额外书籍</h2><pre><code>你可以从以下的书单挑选你有兴趣的主题来研读。</code></pre><ul><li><p><a href="https://www.amazon.com/dp/013937681X">UNIX环境高级编程</a></p><ul><li>老，但却很棒</li></ul></li><li><p><a href="https://www.amazon.com/dp/1593273894/">Linux 命令行大全</a></p><ul><li>现代选择</li></ul></li><li><p><a href="https://en.wikipedia.org/wiki/TCP/IP_Illustrated">TCP-IP详解系列</a></p></li><li><p><a href="https://www.amazon.com/gp/product/0596007124/">Head First 设计模式</a></p><ul><li>设计模式入门介绍</li></ul></li><li><p><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">设计模式：可复用面向对象软件的基础</a></p><ul><li>也被称为“四人帮”（Gang of Four(GOF)）</li><li>经典设计模式书籍</li></ul></li><li><p><a href="https://www.amazon.com/UNIX-Linux-System-Administration-Handbook/dp/0134277554/">Linux 和 UNIX 系统管理技术手册（第五版）</a></p></li><li><p><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202">算法设计手冊（Skiena）</a></p><ul><li>作为复习以及问题辨别</li><li>这本书中算法的部分难度已经超过面试会出现的</li><li>本书分为两个部分:<ul><li>数据结构和算法课本<ul><li>优点:<ul><li>跟其他算法课本一样是个很棒的复习素材</li><li>包含作者以往解决工业及学术上问题的经验的故事</li><li>含C语言代码示例</li></ul></li><li>缺点:<ul><li>某些地方跟《算法导论》（CLRS）一样艰深，但在某些主题，算法导论或许是更好的选择。</li><li>第7、8、9章有点难以消化，因为某些地方并没有解释得很清楚，或者根本上我就是个学渣</li><li>别会错意了，我很喜欢 Skiena 的教学方法以及他的风格。</li></ul></li></ul></li><li>算法目录:<ul><li>这个部分是买这本书的最大原因</li><li>我即将着手进行这部分，一旦完成这部分我会再更新上来</li></ul></li></ul></li><li>可以在 kindle 上租</li><li>解答：<ul><li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition)">解答</a></li><li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/">解答</a></li></ul></li><li><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata">勘误表</a></li></ul></li><li><p><a href="https://www.amazon.com/Write-Great-Code-Understanding-Machine/dp/1593270038">编程卓越之道（第一卷）：深入理解计算机</a></p><ul><li>该书于2004年出版，虽然有些过时，但是对于简单了解计算机而言，这是一个了不起的资源</li><li>作者发明了<a href="https://en.wikipedia.org/wiki/High_Level_Assembly">高阶组合语言 HLA</a>，所以提到，并且举了一些HLA的例子。里面没有用到很多，但都是很棒的组合语言的例子。</li><li>这些章节值得阅读，为你提供良好的基础：<ul><li>第2章──数字表示</li><li>第3章──二进制算术和位运算</li><li>第4章──浮点表示</li><li>第5章──字符表示</li><li>第6章──内存组织和访问</li><li>第7章──组合数据类型和内存对象</li><li>第9章──CPU体系结构</li><li>第10章──指令集架构</li><li>第11章──内存体系结构和组织</li></ul></li></ul></li><li><p><a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844">算法导论</a></p><ul><li><strong>重要提示</strong>：读这本书的价值有限。本书很好地回顾了算法和数据结构，但不会教你如何编写良好的代码。你必须能够有效地编写一个不错的解决方案</li><li>又称 CLR，有时是 CLRS，因为 Stein 最后才加入</li></ul></li><li><p><a href="https://www.amazon.com/dp/0128119055">计算机体系结构：量化研究方法（第6版）</a></p><ul><li>更丰富、更新（2017年），但篇幅较长</li></ul></li><li><p><a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880">编程珠矶</a></p><ul><li>前几章介绍了解决编程问题（非常古老，甚至还用数据磁带）的巧妙解决方案，但这只是一个介绍。这是关于程序设计和体系结构的指南</li></ul></li></ul><h2 id="附加学习"><a href="#附加学习" class="headerlink" title="附加学习"></a>附加学习</h2><pre><code>我把它们加进来是为了让你成为更全方位的软件工程师，并且留意一些技术以及算法，让你拥有更大的工具箱。</code></pre><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><ul><li><a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg">编译器的工作方式，约1分钟（视频）</a></li><li><a href="https://www.youtube.com/watch?v=CSZLNYF4Klo">Harvard CS50-编译器（视频）</a></li><li><a href="https://www.youtube.com/watch?v=twodd1KFfGk">C ++（视频）</a></li><li><a href="https://www.youtube.com/watch?v=FnGCDLhaxKU">了解编译器优化（C ++）（视频）</a></li></ul><h3 id="Emacs-and-vi-m"><a href="#Emacs-and-vi-m" class="headerlink" title="Emacs and vi(m)"></a>Emacs and vi(m)</h3><ul><li>熟悉基于 unix 的代码编辑器</li><li>vi(m):<ul><li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&index=1&list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li><li><a href="http://vim-adventures.com/">VIM 的冒险之旅</a></li><li>4 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk">vi/vim 编辑器 - 课程 1</a></li><li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE">vi/vim 编辑器 - 课程 2</a></li><li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA">vi/vim 编辑器 - 课程 4</a></li><li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI">vi/vim 编辑器 - 课程 3</a></li></ul></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs">使用 Vi 而不是 Emacs</a></li></ul></li><li>emacs:<ul><li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0">基础 Emacs 教程 (视频)</a></li><li>3 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li><li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li><li><a href="https://www.youtube.com/watch?v=paSgzPso-yc">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs">使用 Emacs 开发 C 程序</a></li><li><a href="https://www.youtube.com/watch?v=nsGYet02bEk">(或许) 深度组织模式:管理结构 (视频)</a></li></ul></li></ul><h3 id="Unix-命令行工具"><a href="#Unix-命令行工具" class="headerlink" title="Unix 命令行工具"></a>Unix 命令行工具</h3><ul><li>下列内容包含优秀工具</li><li>bash</li><li>cat</li><li>grep</li><li>sed</li><li>awk</li><li>curl or wget</li><li>sort</li><li>tr</li><li>uniq</li><li><a href="https://en.wikipedia.org/wiki/Strace">strace</a></li><li><a href="https://danielmiessler.com/study/tcpdump/">tcpdump</a></li></ul><h3 id="信息论-视频"><a href="#信息论-视频" class="headerlink" title="信息论 (视频)"></a>信息论 (视频)</h3><ul><li><a href="https://www.khanacademy.org/computing/computer-science/informationtheory">Khan Academy 可汗学院</a></li><li>更多有关马尔可夫的内容:<ul><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation">马尔可夫内容生成（Core Markov Text Generation）</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation">Core Implementing Markov Text Generation马尔可夫内容生成实现</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through">一个马尔可夫内容生成器的项目（Project = Markov Text Generation Walk Through）</a></li></ul></li><li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容。</li></ul><h3 id="奇偶校验位-amp-汉明码-视频"><a href="#奇偶校验位-amp-汉明码-视频" class="headerlink" title="奇偶校验位 &amp; 汉明码 (视频)"></a>奇偶校验位 &amp; 汉明码 (视频)</h3><ul><li><a href="https://www.youtube.com/watch?v=q-3BctoUpHE">入门</a></li><li><a href="https://www.youtube.com/watch?v=DdMcAUlxh1M">奇偶校验位</a></li><li>汉明码(Hamming Code):<ul><li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc">发现错误</a></li><li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o">修正错误</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=wbH2VxzmoZk">检查错误</a></li></ul><h3 id="系统熵值（Entropy）"><a href="#系统熵值（Entropy）" class="headerlink" title="系统熵值（Entropy）"></a>系统熵值（Entropy）</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li><a href="https://youtu.be/JnJq3Py0dyM?t=176">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li></ul><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li><a href="https://www.khanacademy.org/computing/computer-science/%E5%AF%86%E7%A0%81%E5%AD%A6">可汗学院</a></li><li><a href="https://www.youtube.com/watch?v=KqqOXndnvic&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=30">密码学: 哈希函数</a></li><li><a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&index=31&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">密码学: 加密</a></li></ul><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li>观看之前，请先确定观看了信息论的视频</li><li>Computerphile (视频)：<ul><li><a href="https://www.youtube.com/watch?v=Lto-ajuqW3w">压缩</a></li><li><a href="https://www.youtube.com/watch?v=M5c_RFKVkko">压缩熵值</a></li><li><a href="https://www.youtube.com/watch?v=umTbivyJoiI">由上而下的树 (霍夫曼编码树)</a></li><li><a href="https://www.youtube.com/watch?v=DV8efuB3h2g">额外比特 - 霍夫曼编码树</a></li><li><a href="https://www.youtube.com/watch?v=goOa3DGezUA">优雅的压缩数据 (无损数据压缩方法)</a></li><li><a href="https://www.youtube.com/watch?v=cCDCfoHTsaU">Text Compression Meets Probabilities</a></li></ul></li><li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H">数据压缩的艺术</a></li><li><a href="https://www.youtube.com/watch?v=whGwm0Lky2s">(可选) 谷歌开发者：GZIP 还差远了呢!</a></li></ul><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">MIT（23个视频）</a><ul><li><a href="https://www.youtube.com/watch?v=GqmQg-cszw4&index=1&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">威胁模型：入门</a></li><li><a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&index=2">控制劫持攻击</a></li><li><a href="https://www.youtube.com/watch?v=drQyrzRoRiA&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&index=3">缓冲区溢出漏洞攻击和防御</a></li><li><a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&index=4&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">优先权区分</a></li><li><a href="https://www.youtube.com/watch?v=8VqTSY-11F4&index=5&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">能力</a></li><li><a href="https://www.youtube.com/watch?v=VEV74hwASeU&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&index=6">在沙盒中运行原生代码</a></li><li><a href="https://www.youtube.com/watch?v=chkFBigodIw&index=7&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全模型</a></li><li><a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&index=8&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全应用</a></li><li><a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&index=9&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">标志化执行</a></li><li><a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&index=11&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络安全</a></li><li><a href="https://www.youtube.com/watch?v=QOtA76ga_fY&index=12&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">网络协议</a></li><li><a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&index=15&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">旁路攻击</a></li></ul></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI">Python 中的垃圾回收 (视频)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.infoq.com/presentations/garbage-collection-benefits">深度解析：论垃圾回收在 JAVA 中的重要性</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&index=3">深度解析：论垃圾回收在 Python 中的重要性(视频)</a></li></ul><h3 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h3><ul><li><input disabled="" type="checkbox"> <a href="https://www.coursera.org/learn/parprog1/home/week/1">Coursera (Scala)</a></li><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=uY85GkaYzBk">用于高性能并行计算的高效Python（视频）</a></li></ul><h3 id="消息传递，序列化和队列系统"><a href="#消息传递，序列化和队列系统" class="headerlink" title="消息传递，序列化和队列系统"></a>消息传递，序列化和队列系统</h3><ul><li><a href="https://thrift.apache.org/">Thrift</a><ul><li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html">教程</a></li></ul></li><li><a href="https://developers.google.com/protocol-buffers/">协议缓冲</a><ul><li><a href="https://developers.google.com/protocol-buffers/docs/tutorials">教程</a></li></ul></li><li><a href="http://www.grpc.io/">gRPC</a><ul><li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&index=1">gRPC 对于JAVA开发者的入门教程（视频）</a></li></ul></li><li><a href="http://redis.io/">Redis</a><ul><li><a href="http://try.redis.io/">教程</a></li></ul></li><li><a href="https://aws.amazon.com/sqs/">Amazon的 SQS 系统 (队列)</a></li><li><a href="https://aws.amazon.com/sns/">Amazon的 SNS 系统 (pub-sub)</a></li><li><a href="https://www.rabbitmq.com/">RabbitMQ</a><ul><li><a href="https://www.rabbitmq.com/getstarted.html">入门教程</a></li></ul></li><li><a href="http://www.celeryproject.org/">Celery</a><ul><li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">Celery入门</a></li></ul></li><li><a href="http://zeromq.org/">ZeroMQ</a><ul><li><a href="http://zeromq.org/intro:read-the-manual">入门教程</a></li></ul></li><li><a href="http://activemq.apache.org/">ActiveMQ</a></li><li><a href="http://kafka.apache.org/documentation.html#introduction">Kafka</a></li><li><a href="http://msgpack.org/index.html">MessagePack</a></li><li><a href="https://avro.apache.org/">Avro</a></li></ul><h3 id="A-搜索算法"><a href="#A-搜索算法" class="headerlink" title="A*搜索算法"></a>A*搜索算法</h3><ul><li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A 搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=KNXfSOx4eEE">A* 路径搜索教程（教程）</a></li><li><a href="https://www.youtube.com/watch?v=-L-WgKMFuhE">A* 路径搜索（E01：算法解释）（视频）</a></li></ul><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><ul><li><a href="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/">傅立叶变换的交互式指南</a></li><li><a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/">什么是傅立叶变换？论傅立叶变换的用途</a></li><li><a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q">什么是傅立叶变换？ (视频)</a></li><li><a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=4">分而治之：FFT（视频）</a></li><li><a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/">FTT 是什么</a></li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>给定布隆过滤器m比特位和k个哈希函数，插入和成员检测都会是 O(k)。</li><li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs">布隆过滤器（视频）</a></li><li><a href="https://www.youtube.com/watch?v=qBTdukbzc78">布隆过滤器 | 数据挖掘 | Stanford University（视频）</a></li><li><a href="http://billmill.org/bloomfilter-tutorial/">教程</a></li><li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/">如何写一个布隆过滤器应用</a></li></ul><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><ul><li><a href="http://highscalability.com/blog/2012/4/5/big-data-counting-how-to-count-a-billion-distinct-objects-us.html">如何仅使用1.5KB内存计算十亿个不同的对象</a></li></ul><h3 id="局部敏感哈希"><a href="#局部敏感哈希" class="headerlink" title="局部敏感哈希"></a>局部敏感哈希</h3><ul><li>用于确定文件的相似性</li><li>MD5 或 SHA 的反义词，用于确定2个文档/字符串是否完全相同</li><li><a href="http://ferd.ca/simhashing-hopefully-made-simple.html">Simhashing（希望如此）变得简单</a></li></ul><h3 id="van-Emde-Boas-树"><a href="#van-Emde-Boas-树" class="headerlink" title="van Emde Boas 树"></a>van Emde Boas 树</h3><ul><li><a href="https://www.youtube.com/watch?v=hmReJCupbNU&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=6">分而治之：van Emde Boas 树 (视频)</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf">MIT课堂笔记</a></li></ul><h3 id="增强数据结构"><a href="#增强数据结构" class="headerlink" title="增强数据结构"></a>增强数据结构</h3><ul><li><a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&t=950">CS 61B 第 39 课: 增强数据结构</a></li></ul><h3 id="平衡查找树（Balanced-search-trees）"><a href="#平衡查找树（Balanced-search-trees）" class="headerlink" title="平衡查找树（Balanced search trees）"></a>平衡查找树（Balanced search trees）</h3><ul><li><p>掌握至少一种平衡查找树（并懂得如何实现）：</p></li><li><p>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的键。” —— Skiena</p></li><li><p>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。</p><ul><li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li><li>跳过删除函数，直接实现搜索和插入功能</li></ul></li><li><p>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据集当中。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">自平衡二叉查找树</a></p></li><li><p><strong>AVL 树</strong></p><ul><li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li><li><a href="https://www.youtube.com/watch?v=FNeL18KsWPc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=6">MIT AVL 树 / AVL 树的排序（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees">AVL 树（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation">AVL 树的实现（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge">分离与合并</a></li></ul></li><li><p><strong>伸展树</strong></p><ul><li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li><li><a href="https://www.youtube.com/watch?v=Najzh1rYQTo&index=23&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd">CS 61B：伸展树（Splay trees）（视频）</a></li><li>MIT 教程：伸展树（Splay trees）：<ul><li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li><li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo">视频</a></li></ul></li></ul></li><li><p><strong>红黑树</strong></p><ul><li>这些是2-3棵树的翻译（请参见下文）。</li><li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 内核所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，Collection HashMap也从原本用Linked List实现，储存特定元素的哈希码，改为用红黑树实现。</li><li><a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3871">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li><li><a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=5">Aduni —— 算法 —— 课程5（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">黑树（Black Tree）</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/">二分查找及红黑树的介绍</a></li></ul></li><li><p><strong>2-3查找树</strong></p><ul><li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li><li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li><li><a href="https://www.youtube.com/watch?v=C3SsdUqasD4&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&index=2">2-3树的直感与定义（视频）</a></li><li><a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&index=3&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">2-3树的二元观点</a></li><li><a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&index=5&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">2-3树（学生叙述）（视频）</a></li></ul></li><li><p><strong>2-3-4树 (亦称2-4树)</strong></p><ul><li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li><li><a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&index=26&list=PL4BBB74C7D2A1049C">CS 61B Lecture 26：平衡查找树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=DQdMYevEyE4&index=4&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">自底向上的2-4树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=2679VQ26Fp4&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&index=5">自顶向下的2-4树（视频）</a></li></ul></li><li><p><strong>N 叉树（K 叉树、M 叉树）</strong></p><ul><li>注意：N 或 K 指的是分支系数（即树的最大分支数）：</li><li>二叉树是一种分支系数为2的树</li><li>2-3树是一种分支系数为3的树</li><li><a href="https://en.wikipedia.org/wiki/K-ary_tree">K 叉树</a></li></ul></li><li><p><strong>B 树</strong></p><ul><li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li><li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li><li><a href="https://en.wikipedia.org/wiki/B-tree">B 树</a></li><li><a href="http://btechsmartclass.com/data_structures/b-trees.html">B 树数据结构</a></li><li><a href="https://www.youtube.com/watch?v=I22wEC1tTGo&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&index=6">B 树的介绍（视频）</a></li><li><a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&index=7&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">B 树的定义及其插入操作（视频）</a></li><li><a href="https://www.youtube.com/watch?v=svfnVhJOfMc&index=8&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6">B 树的删除操作（视频）</a></li><li><a href="https://www.youtube.com/watch?v=V3omVLzI0WE&index=7&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul><li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li><li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li></ul></li></ul></li></ul><h3 id="k-D树"><a href="#k-D树" class="headerlink" title="k-D树"></a>k-D树</h3><ul><li>非常适合在矩形或更高维度的对象中查找点数</li><li>最适合k近邻</li><li><a href="https://www.youtube.com/watch?v=W94M9D_yXKk">Kd树（视频）</a></li><li><a href="https://www.youtube.com/watch?v=Y4ZgLlDfKDg">kNN K-d树算法（视频）</a></li></ul><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ul><li>“有一种非常迷幻的数据类型” - Skiena</li><li><a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&index=10&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">随机化: 跳表 (视频)</a></li><li><a href="https://en.wikipedia.org/wiki/Skip_list">更生动详细的解释</a></li></ul><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li><a href="https://www.youtube.com/watch?v=v1VgJmkEJW0">5分钟简析 Ford-Fulkerson──一步步示例 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=v1VgJmkEJW0">Ford-Fulkerson 算法 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=2vhN4Ice5jI">网络流 (视频)</a></li></ul><h3 id="不相交集-amp-联合查找"><a href="#不相交集-amp-联合查找" class="headerlink" title="不相交集 &amp; 联合查找"></a>不相交集 &amp; 联合查找</h3><ul><li><a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&index=21">UCB 61B - 不相交集；排序 &amp; 选择(视频)</a></li><li><a href="https://www.coursera.org/learn/algorithms-part1/home/week/1">Sedgewick算法──Union-Find（6视频）</a></li></ul><h3 id="快速处理的数学"><a href="#快速处理的数学" class="headerlink" title="快速处理的数学"></a>快速处理的数学</h3><ul><li><a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&index=11&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">整数运算, Karatsuba 乘法 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=ru7mWZJlRQg">中国剩余定理 (在密码学中的使用) (视频)</a></li></ul><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 (Treap)"></a>树堆 (Treap)</h3><ul><li>一个二叉搜索树和一个堆的组合</li><li><a href="https://en.wikipedia.org/wiki/Treap">树堆</a></li><li><a href="https://www.youtube.com/watch?v=6podLUYinH8">数据结构：树堆的讲解（视频）</a></li><li><a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf">集合操作的应用(Applications in set operations)</a></li></ul><h3 id="线性规划（Linear-Programming）（视频）"><a href="#线性规划（Linear-Programming）（视频）" class="headerlink" title="线性规划（Linear Programming）（视频）"></a>线性规划（Linear Programming）（视频）</h3><ul><li><a href="https://www.youtube.com/watch?v=M4K6HYLHREQ">线性规划</a></li><li><a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U">寻找最小成本</a></li><li><a href="https://www.youtube.com/watch?v=8AA_81xI3ik">寻找最大值</a></li><li><a href="https://www.youtube.com/watch?v=44pAWI7v5Zk">用 Python 解决线性方程式──单纯形算法</a></li></ul><h3 id="几何：凸包（Geometry-Convex-hull）（视频）"><a href="#几何：凸包（Geometry-Convex-hull）（视频）" class="headerlink" title="几何：凸包（Geometry, Convex hull）（视频）"></a>几何：凸包（Geometry, Convex hull）（视频）</h3><ul><li><a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3164">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li><li><a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&index=10&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li><li><a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=2">分而治之: 凸包, 中值查找</a></li></ul><h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h3><pre><code>- 查看下面的视频</code></pre><h3 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h3><ul><li>为什么学习机器学习？<ul><li><a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li><li><a href="https://www.youtube.com/watch?v=QSaZGT4-6EY">智能计算机系统的大规模深度学习 (视频)</a></li><li><a href="https://www.youtube.com/watch?v=X769cyzBNVw">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0">谷歌云机器学习工具（视频）</a></li><li><a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li><li><a href="https://www.youtube.com/watch?v=oZikw5k_2FM">Tensorflow (视频)</a></li><li><a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html">Tensorflow 教程</a></li><li><a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/">Python 实现神经网络实例教程（使用 Theano）</a></li><li>课程:<ul><li><a href="https://www.coursera.org/learn/machine-learning">很棒的初级课程：机器学习</a><ul><li><a href="https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW">视频教程</a></li><li>看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）</li></ul></li><li><a href="https://www.coursera.org/learn/neural-networks">机器学习中的神经网络</a></li><li><a href="https://www.udacity.com/course/deep-learning--ud730">Google 深度学习微学位</a></li><li><a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009">Google/Kaggle 机器学习工程师微学位</a></li><li><a href="https://www.udacity.com/drive">无人驾驶工程师微学位</a></li><li><a href="http://www.thisismetis.com/explore-data-science">Metis 在线课程 (两个月 99 美元)</a></li></ul></li><li>资源:<ul><li>书籍：<ul><li><a href="https://www.amazon.com/Python-Machine-Learning-Sebastian-Raschka/dp/1783555130/">Python 机器学习</a></li><li><a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X">Data Science from Scratch: First Principles with Python</a></li><li><a href="https://www.amazon.com/Introduction-Machine-Learning-Python-Scientists/dp/1449369413/">Python 机器学习简介</a></li></ul></li><li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers">软件工程师的机器学习</a></li><li>Data School：<a href="http://www.dataschool.io/">http://www.dataschool.io/</a></li></ul></li></ul><p>–</p><h2 id="一些主题的额外内容"><a href="#一些主题的额外内容" class="headerlink" title="一些主题的额外内容"></a>一些主题的额外内容</h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？</code></pre><ul><li><p>SOLID</p><ul><li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=TMuno5RZNeE">Bob Martin SOLID面向对象和敏捷设计的原理（视频）</a></li><li><input disabled="" type="checkbox"> S ── <a href="http://www.oodesign.com/single-responsibility-principle.html">单一责任原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html">对每个对象的单一责任</a><ul><li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk">更多</a></li></ul></li><li><input disabled="" type="checkbox"> O ── <a href="http://www.oodesign.com/open-close-principle.html">开放/封闭原则</a> | <a href="https://en.wikipedia.org/wiki/Open/closed_principle">在生产级别上，可以扩展对象，但不能修改对象</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&pid=explorer&chrome=true&srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&hl=en">更多</a></li></ul></li><li><input disabled="" type="checkbox"> L ── <a href="http://www.oodesign.com/liskov-s-substitution-principle.html">Liskov 替换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle">基本类别和派生类别遵循“IS A”原则</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&pid=explorer&chrome=true&srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&hl=en">更多</a></li></ul></li><li><input disabled="" type="checkbox"> I ── <a href="http://www.oodesign.com/interface-segregation-principle.html">接口隔离原理</a> | 不应强迫客户端实现不使用的接口<ul><li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ">5分钟了解接口隔离原理（视频）</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&pid=explorer&chrome=true&srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&hl=en">更多</a></li></ul></li><li><input disabled="" type="checkbox"> D ── <a href="http://www.oodesign.com/dependency-inversion-principle.html">依赖倒置原理</a> | 减少对象组合中的依赖性。<ul><li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important">依赖倒置原理为何如此重要？</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&pid=explorer&chrome=true&srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&hl=en">更多</a></li></ul></li></ul></li><li><p>Union-Find</p><ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview">概览</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations">初级实践</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees">树状结构</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank">合并树状结构</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression">路径压缩</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional">分析选项</a></li></ul></li><li><p><strong>动态规划的更多内容</strong> (视频)</p><ul><li><a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=19">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li><li><a href="https://www.youtube.com/watch?v=ENyox7kNKeY&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=20">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li><li><a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=21">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li><li><a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&index=22&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li><li><a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&index=14&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">6.046: 动态规划: 动态规划进阶</a></li><li><a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=15">6.046: 动态规划: 所有点对最短路径</a></li><li><a href="https://www.youtube.com/watch?v=krZI60lKPek&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=12">6.046: 动态规划: 更多示例</a></li></ul></li><li><p><strong>图形处理进阶</strong> (视频)</p><ul><li><a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=27">异步分布式算法: 对称性破缺，最小生成树</a></li><li><a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=28">异步分布式算法: 最小生成树</a></li></ul></li><li><p>MIT <strong>概率论</strong> (过于数学，进度缓慢，但这对于数学的东西却是必要之恶) (视频):</p><ul><li><a href="https://www.youtube.com/watch?v=SmFwFdESMHI&index=18&list=PLB7540DEDD482705B">MIT 6.042J - 概率论概述</a></li><li><a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&index=19&list=PLB7540DEDD482705B">MIT 6.042J - 条件概率 Probability</a></li><li><a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&index=20&list=PLB7540DEDD482705B">MIT 6.042J - 独立</a></li><li><a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&list=PLB7540DEDD482705B&index=21">MIT 6.042J - 随机变量</a></li><li><a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&index=22&list=PLB7540DEDD482705B">MIT 6.042J - 期望 I</a></li><li><a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&index=23&list=PLB7540DEDD482705B">MIT 6.042J - 期望 II</a></li><li><a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&index=24&list=PLB7540DEDD482705B">MIT 6.042J - 大偏差</a></li><li><a href="https://www.youtube.com/watch?v=56iFMY8QW2k&list=PLB7540DEDD482705B&index=25">MIT 6.042J - 随机游走</a></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=oDniZCmNmNw&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=19">Simonson: 近似算法 (视频)</a></p></li><li><p><strong>字符串匹配</strong></p><ul><li>Rabin-Karp（视频）<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm">Rabin Karps 算法</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation">预计算</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis">优化：实施和分析</a></li><li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9">表翻倍，Karp-Rabin</a></li><li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=32">滚动哈希，摊销分析</a></li></ul></li><li>Knuth-Morris-Pratt (KMP)：<ul><li><a href="https://www.youtube.com/watch?v=5i7oKodCRJo">Knuth-Morris-Pratt（KMP）字符串匹配算法</a></li></ul></li><li>Boyer–Moore 字符串搜索算法<ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm">Boyer–Moore 字符串搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=QDZpzctPf10">高级字符串搜索Boyer-Moore-Horspool算法（视频）</a></li></ul></li><li><a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1">Coursera：字符串算法</a><ul><li>刚开始时很棒，但是当它超过 KMP 时，它变得比需要复杂得多</li><li>很好的字典树解释</li><li>可以跳过</li></ul></li></ul></li><li><p><strong>排序</strong></p><ul><li><p>斯坦福大学关于排序算法的视频:</p><ul><li><a href="https://www.youtube.com/watch?v=ENp00xylP7c&index=15&list=PLFE6E58F856038C69">课程 15 | 编程抽象（视频）</a></li><li><a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&index=16&list=PLFE6E58F856038C69">课程 16 | 编程抽象（视频）</a></li></ul></li><li><p>Shai Simonson 视频，<a href="http://www.aduni.org/">Aduni.org</a>:</p><ul><li><a href="https://www.youtube.com/watch?v=odNJmw5TOEE&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=2">算法 - 排序 - 第二讲（视频）</a></li><li><a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=3">算法 - 排序2 - 第三讲（视频）</a></li></ul></li><li><p>Steven Skiena 关于排序的视频:</p><ul><li><a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&t=1600">课程从 26:46 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=yLvp-pB8mak&index=8&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">课程从 27:40 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=q7K9otnzlfE&index=9&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b">课程从 35:00 开始（视频）</a></li><li><a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=10">课程从 23:50 开始（视频）</a></li></ul></li></ul></li></ul><h2 id="视频系列"><a href="#视频系列" class="headerlink" title="视频系列"></a>视频系列</h2><p> 坐下来享受一下吧。”netflix 和技能” :P</p><ul><li><p><a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr">个人的动态规划问题列表 (都是短视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0">x86 架构，汇编，应用程序 (11 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A">绝妙的 MIT 微积分：单变量微积分</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG">离散数学 (19 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLGxuz-nmYlQPOc4w1Kp2MZrdqOOm4Jxeo">离散数学（第一部分），Sarada Herke （5个视频）</a></p></li><li><p>CSE373 - 算法分析 (25 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&index=1">Skiena 的算法设计手册讲座</a></li></ul></li><li><p><a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_">UC Berkeley 61C：计算机结构 (26 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO">OOSE：使用 UML 和 Java 进行软件开发 (21 个视频)</a></p></li><li><p><del><a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&index=20&list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></del></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-">MIT 6.004: 计算结构 (49 视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&nohtml5=False">MIT 6.006：算法介绍 (47 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&list=PL6535748F59DCA484">MIT 6.033：计算机系统工程 (22 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi">MIT 6.034：人工智能，2010 年秋季 (30 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&list=PLB7540DEDD482705B">MIT 6.042J：计算机科学数学, 2010 年秋季 (25 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=2P-yW7LQr08&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp">MIT 6.046：算法设计与分析 (34 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=phxsQrZQupo&list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7">MIT 6.050J：信息和熵, 2008 年春季 (19 个视频)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=T0yzrZL1py0&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=1">MIT 6.851：高等数据结构 (22 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL2SOU6wwxB0uP4rJgf5ayhHWgw7akUWSf">Harvard COMPSCI 224：高级算法（25个视频）</a></p></li><li><p><a href="https://www.youtube.com/watch?v=GqmQg-cszw4&index=1&list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh">MIT 6.858：计算机系统安全, 2014 年秋季</a></p></li><li><p><a href="https://www.youtube.com/view_play_list?p=9D558D49CA734A02">斯坦福: 编程范例 (27 个视频)</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PL6N5qY2nvvJE8X75VkXglSrVhLv1tVcfy">密码学导论，Christof Paar</a></p><ul><li><a href="http://www.crypto-textbook.com/">课程网站以及幻灯片和问题集</a></li></ul></li><li><p><a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV">大数据 - 斯坦福大学 (94 个视频)</a></p></li><li><p><a href="https://www.youtube.com/user/DrSaradaHerke/playlists?shelf_id=5&view=50&sort=dd">图论，Sarada Herke（67个视频）</a></p></li></ul><h2 id="计算机科学课程"><a href="#计算机科学课程" class="headerlink" title="计算机科学课程"></a>计算机科学课程</h2><ul><li><a href="https://github.com/open-source-society/computer-science">在线 CS 课程目录</a></li><li><a href="https://github.com/prakhar1989/awesome-courses">CS 课程目录 (一些是在线讲座)</a></li></ul><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><ul><li><a href="https://www.cs.cmu.edu/~crary/819-f09/">喜欢经典的论文？</a></li><li><a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf">1978: 通信顺序处理</a><ul><li><a href="https://godoc.org/github.com/thomas11/csp">Go 实现</a></li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf">2003: The Google 文件系统</a><ul><li>2012 年被 Colossus 取代了</li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul><li>大多被云数据流取代了?</li></ul></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">2006年：Bigtable：结构化数据的分布式存储系统</a><ul><li><a href="https://cloud.google.com/files/BigQueryTechnicalWP.pdf">深入了解Google BigQuery</a></li></ul></li><li><a href="https://research.google.com/archive/chubby-osdi06.pdf">2006年：针对松散耦合的分布式系统的Chubby Lock服务</a></li><li><a href="http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf">2007年：Dynamo：亚马逊的高可用键值存储</a><ul><li>Dynamo论文启动了NoSQL革命</li></ul></li><li><a href="https://www.akkadia.org/drepper/cpumemory.pdf">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li><li><a href="https://research.google.com/pubs/archive/36356.pdf">2010年：Dapper，一个大型分布式系统跟踪基础结构</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf">2010年：Dremel：Web规模数据集的交互式分析</a></li><li><a href="https://www.wired.com/2012/07/google-colossus/">2012: Google 的 Colossus</a><ul><li>没有论文</li></ul></li><li>2012: AddressSanitizer: 快速的内存访问检查器:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf">论文</a></li><li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany">视频</a></li></ul></li><li>2013: Spanner: Google 的分布式数据库:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">论文</a></li><li><a href="https://www.usenix.org/node/170855">视频</a></li></ul></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf">2015: Continuous Pipelines at Google</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li><li><a href="http://download.tensorflow.org/paper/whitepaper2015.pdf">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf">2015: 开发者应该如何搜索代码：用例学习</a></li><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf">2016: Borg, Omega, and Kubernetes</a></li></ul><h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><p><a href="https://github.com/jwasham/coding-interview-university/blob/master/LICENSE.txt">CC-BY-SA-4.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于GitHub与PicGo的稳定快速的免费图床</title>
      <link href="/2021/01/19/ji-lu/bo-ke-da-jian/tu-chuang-da-jian/"/>
      <url>/2021/01/19/ji-lu/bo-ke-da-jian/tu-chuang-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h2><p><strong>Q：什么是图床？为什么要使用图床呢？</strong></p><p><strong>A</strong>：撰写在线文章时，图片是文章表达中不可或缺的一部分。其中图片的上传和存放就是一个大问题。</p><p>有些朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用（我以前也是这样使用的），这样后期维护起来会比较麻烦——因为这样一篇文章如果放到其他环境中图片就会由于相对路径而无法正常展示，没有什么比一个裂掉的图还让人感觉难受了。</p><p>有的朋友会在不同的平台发布同一篇文章，例如简书，csdn，b站等，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，这个静态资源库就是图床，其返回一个图片的URL，这样在文章中插入在线引用即可展示图片，一次书写，多处使用。</p><p>一般在商业项目中使用cdn加速，加速内容包括但不限于各种静态资源，有的需要分布式缓存等，但是考虑到个人的使用，没必要如此，使用<code>markdown+image url</code>的方式写作文章用公开github仓库和免费cdn加速即可。</p><a id="more"></a><p><strong>Q：图床的选择</strong></p><p>A：推荐使用GitHub作为图床，特点是免费、稳定，有一个缺点是国内访问速度慢，不过可以使用<code>jsDelivr</code>免费CDN加速。</p><p><strong>Q：jsDelivr是什么？</strong></p><p>A：<a href="https://www.jsdelivr.com/"><code>jsDelivr</code></a>A free CDN for Open Source,fast, reliable, and automated.</p><p>其是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/infographics.png" alt="jsDelivr_infographics"></p><h2 id="图床打造"><a href="#图床打造" class="headerlink" title="图床打造"></a>图床打造</h2><ol><li><p>登录github新建一个自己图床<strong>公开</strong>GitHub仓库</p></li><li><p>生成一个GitHub token密钥</p><ul><li>进入Settings &gt; Developer settings &gt; Personal access tokens</li><li>点击Generate new token</li><li>默认只需要repo权限即可，点击Generate token后获取到token，<strong>注意</strong>：此处的明文token只显示一次，刷新页面就会再也看不到，请及时复制保存或截图保存</li></ul></li><li><p>在这里<a href="https://github.com/Molunerfinn/picgo/releases"><code>下载PicGo</code></a> ，安装完成后打开，<code>图床设置</code> 选 <code>GitHub图床</code>，并填写相应的信息。<a href="https://picgo.github.io/PicGo-Doc/">官方文档</a></p><ul><li>仓库名：前面新建的仓库，格式：<code>&lt;用户名&gt;/&lt;仓库名&gt;</code></li><li>分支名：填写主分支<code>master</code>即可</li><li>Token：第2步生成的token密钥</li><li>存储路径：图片在仓库中的路径，例如img/</li><li>自定义域名：图片上传后，PicGo 会按照 <code>自定义域名+上传的图片名</code> 的方式生成访问链接，此处我们填写<code>jsDelivr</code>的CDN加速地址，<code>jsdelivr</code>其提供的格式为：<code>https://cdn.jsdelivr.net/gh/user/repo@version/file</code>,<code>https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;@&lt;版本&gt;/文件名</code></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/20210119154343.png"></p><ol start="4"><li><p>压缩上传的在线图片，保证传输速度（图片已很小可省略这一步）</p></li><li><p>在PigGo的<code>上传区</code>上传你的图片，到<code>相册</code>一键复制刚刚上传的图片URL，至此，你就可以在你的文章当中愉快的插入图片了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoBD使用</title>
      <link href="/2021/01/19/shu-ju-ku/mongodb/"/>
      <url>/2021/01/19/shu-ju-ku/mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.mongodb.com/">官网</a> 选择合适的版本下载.msi文件安装即可，或者下载解压版本</p><h3 id="命令行下运行-MongoDB"><a href="#命令行下运行-MongoDB" class="headerlink" title="命令行下运行 MongoDB"></a>命令行下运行 MongoDB</h3><p>为了从命令提示符下运行 MongoDB 服务器，必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件，来关联一个文件夹作为数据存储的位置。这里以D盘下的MongoDB为例，文件路径如下：</p><pre class=" language-js"><code class="language-js"><span class="token operator">-</span>D<span class="token punctuation">:</span>\Program Files\MongoDB <span class="token operator">-</span> data        <span class="token operator">-</span> db     <span class="token comment" spellcheck="true">//数据</span>   <span class="token operator">-</span> log    <span class="token comment" spellcheck="true">//日志</span> <span class="token operator">-</span> Server   <span class="token comment" spellcheck="true">//Mongodb服务</span>   <span class="token operator">-</span> <span class="token number">4.0</span>     <span class="token operator">-</span> bin     <span class="token operator">-</span> data  <span class="token comment" spellcheck="true">//系统数据</span>     <span class="token operator">-</span> log   <span class="token comment" spellcheck="true">//系统日志</span>     <span class="token operator">-</span> LICENSE<span class="token operator">-</span>Community<span class="token punctuation">.</span>txt     <span class="token operator">-</span> MPL<span class="token number">-2</span>     <span class="token operator">-</span> <span class="token operator">...</span></code></pre><p>关联用户数据文件夹，这里是data下的db，命令如下：</p><pre class=" language-bash"><code class="language-bash">D:\Program Files\MongoDB\Server\4.0\bin\mongod --dbpath D:\Program Files\MongoDB\data\db</code></pre><p>配置mongod命令到系统的环境变量中，将D:\Program Files\MongoDB\Server\4.0\bin\加入到 控制面板-&gt;系统与安全-&gt;系统-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;Path 中即可。再次打开命令行输入mongo命令出现版本号和信息即成功。</p><pre class=" language-bash"><code class="language-bash">C:\Users\17879<span class="token operator">></span> mongoMongoDB shell version v4.0.8connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName<span class="token operator">=</span>mongodbImplicit session: session <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "id" : UUID("2e4226ab-6fff-4fc1-bba0-baf52c6f2f33") &amp;#125;</span>MongoDB server version: 4.0.8<span class="token operator">></span> </code></pre><p>设置批处理文件来启动或者使用Mongoliandb的MongoDB Compass Community可视化工具。其默认的端口号是27017.</p><pre class=" language-bash"><code class="language-bash">mongo.exe --dbpath<span class="token operator">=</span>D:\Program Files\MongoDB\data\db</code></pre><h3 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h3><p>可以在命令窗口中运行 mongo 命令即可连接上 MongoDB，执行如下命令：</p><pre class=" language-bash"><code class="language-bash">C:\Users\17879<span class="token operator">></span>mongo</code></pre><p>如果需要查看合适的options可以使用命令：</p><pre class=" language-bash"><code class="language-bash">C:\Users\17879<span class="token operator">></span>mongod -help</code></pre><h2 id="体系结构概念"><a href="#体系结构概念" class="headerlink" title="体系结构概念"></a>体系结构概念</h2><p>mongodb与SQL术语的概念对比：<br><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/sql_mongodb.png" alt="sql_mongodb"></p><h3 id="数据库-database"><a href="#数据库-database" class="headerlink" title="数据库 database"></a>数据库 database</h3><p>在一个mongodb中可以建立多个数据库（母庸置疑），默认数据库为db，放在data目录中。mongoDB的单个实例可以容纳多个数据库，不同的数据库也可以放置在不同的文件中。展示所有数据库列表使用命令 show dbs（前提是已经连接了MongoDB，参见上节）。</p><pre class=" language-bash"><code class="language-bash">C:\Users\17879<span class="token operator">></span>show dbs</code></pre><p>这里还有一些其他命令：</p><ul><li>使用db命令可以展示当前所使用的数据库名称；</li><li>使用use database可以切换连接到一个指定的数据库中。</li></ul><p>数据库的名称命名和JAVA中的关键字差不多，原则是：非空，不含有空格，英文句号，美元符号，左右划线，应该全部小写，最多64字节。其中有一些数据库的名称是保留的，例如</p><p>admin（root数据库，权限控制，一些特定命令只能从这个数据库运行），</p><p>local（存储仅限于本地单台服务器的任意集合，不可复制），</p><p>config（mongo用于分片设置时在内部使用保存分片信息）。</p><h3 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h3><p>文档本质上是一组键值对（BSON）。MongoDB的文档组织相当的松散，相同的字段不需要相同的数据类型（关系型数据库中是不成立的）。可以在程序中动态定义文档的结构，也可以自定义文档结构。document相当于数据库表中的一行记录。</p><h3 id="集合-collection"><a href="#集合-collection" class="headerlink" title="集合 collection"></a>集合 collection</h3><p>集合是文档组，类似于RDBMS中的表 table。注：RDBMS- relational database management system.<br>集合存在数据库中，可以将不同的数据结构插入到集合之中。当第一个文档被插入时，集合就会被创建。一般不要使用特殊字符作为集合名称，会和系统保留前缀或名称冲突。</p><h3 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h3><p>一个mongodb server支持多个数据库，每个db中包含多个collection，每个collection由多个document组成。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/data_type.png" alt="datatype"></p><h2 id="基本数据操作"><a href="#基本数据操作" class="headerlink" title="基本数据操作"></a>基本数据操作</h2><p>为了使用方便，也可以为mongodb设置客户端。</p><pre class=" language-bash"><code class="language-bash">mongo.exe 127.0.0.1：27017/admin</code></pre><p>连接后的help帮助文档</p><pre class=" language-bash"><code class="language-bash"> db.help<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token function">help</span> on db methods db.mycoll.help<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token function">help</span> on collection methods sh.help<span class="token punctuation">(</span><span class="token punctuation">)</span>                    sharding helpers rs.help<span class="token punctuation">(</span><span class="token punctuation">)</span>                    replica <span class="token keyword">set</span> helpers <span class="token function">help</span> admin                   administrative <span class="token function">help</span> <span class="token function">help</span> connect                 connecting to a db <span class="token function">help</span> <span class="token function">help</span> keys                    key shortcuts <span class="token function">help</span> misc                    misc things to know <span class="token function">help</span> mr                      mapreduce show dbs                     查看所有数据库 show collections             show collections <span class="token keyword">in</span> current database show <span class="token function">users</span>                   show <span class="token function">users</span> <span class="token keyword">in</span> current database show profile                 show <span class="token function">most</span> recent system.profile entries with <span class="token function">time</span> <span class="token operator">>=</span> 1ms show logs                    show the accessible logger names show log <span class="token punctuation">[</span>name<span class="token punctuation">]</span>              prints out the last segment of log <span class="token keyword">in</span> memory, <span class="token string">'global'</span> is default use <span class="token operator">&lt;</span>db_name<span class="token operator">></span>                创建或者切换到目标数据库。注意：如果创建空的数据库（未添加集合和文档）离开后会自动销毁。如果是已经存在的数据库，就自动切换到目标数据库。 db.foo.find<span class="token punctuation">(</span><span class="token punctuation">)</span>                list objects <span class="token keyword">in</span> collection foo db.foo.find<span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; a : 1 &amp;#125; )     list objects in foo where a == 1</span> it                           result of the last line evaluated<span class="token punctuation">;</span> use to further iterate DBQuery.shellBatchSize <span class="token operator">=</span> x   <span class="token keyword">set</span> default number of items to display on shell <span class="token keyword">exit</span>                         quit the mongo shell</code></pre><h3 id="db-collectionName-insert-…"><a href="#db-collectionName-insert-…" class="headerlink" title="db.[collectionName].insert( {…} )"></a>db.[collectionName].insert( {…} )</h3><p>向指定数据库添加集合并且添加记录，insert的参数可以是BSON格式或者对象名。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> use nodedbswitched to db nodedb<span class="token operator">></span> show collections<span class="token function">users</span><span class="token operator">></span> person<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"name":"yanbo01haomiao"&amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "yanbo01haomiao" &amp;#125;</span><span class="token operator">></span> animal<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"name":"cat"&amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "cat" &amp;#125;</span><span class="token operator">></span> db.persons.insert<span class="token punctuation">(</span>person<span class="token punctuation">)</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nInserted" : 1 &amp;#125;)</span><span class="token operator">></span> db.persons.insert<span class="token punctuation">(</span>animal<span class="token punctuation">)</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nInserted" : 1 &amp;#125;)</span><span class="token operator">></span> show collectionspersons<span class="token function">users</span></code></pre><h3 id="db-collectionName-find"><a href="#db-collectionName-find" class="headerlink" title="db.[collectionName].find()"></a>db.[collectionName].find()</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e0bc9827fb3a4e9aa90"), "name" : "yanbo01haomiao" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e13c9827fb3a4e9aa91"), "name" : "cat" &amp;#125;</span></code></pre><p>相当于关系型数据库中select * from table.其中_id为Objectid。</p><h3 id="Objectid"><a href="#Objectid" class="headerlink" title="Objectid"></a>Objectid</h3><p>mongodb支持的数据类型中，ObjectId是其自有产物。存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId，可以很快的生成和排序。</p><p>ObjectId的12字节是如此构成的：0-3这4个字节是时间戳（timestamp）、4-6这3个字节是机器码（machine）、7-8这2个字节是进程id（pid）、9-11这3个字节是程序自增id（increment）。</p><ul><li>前4字节表示船舰unix时间戳，时间为格林尼治时间UTC。因为ObjectId以时间戳打头，所以它是近似有序的，使得_id的索引插入效率相比普通索引高很多</li><li>接下来3字节为机器标识码</li><li>接下来2字节为进程id组成的PID</li><li>最后3字节为随机数计数器</li></ul><p>ObjectId的前9个字节（timestamp+machine+pid）可以保证不同进程生成的ObjectId不会重复，而后3个字节increment又可以保证同一进程内生成的ObjectId不会重复，所以无需怀疑ObjectId的全局唯一性。</p><p>ObjectId存储是12个字节，但如果应用有需要以可读的方式表现它，就需要将它转成字符串，这需要24字节（每字节转成2字节的16进制表示），这个长度的字符串看起来就有些不让人舒服了，如果是追踪某个id引发的bug，就需要配上copy+paste的杀招。</p><blockquote><p>在关系数据库schema设计中，主键大多是数值型的，比如常用的int和long，并且更通常的，主键的取值由数据库自增 获得，这种主键数值的有序性有时也表明了某种逻辑。<br>反观mongodb，它在设计之初就定位于分布式存储系统，所以它原生的不支持自增主键。</p></blockquote><p>ObjectId被设计成跨机器的分布式环境中全局唯一的类型，长度是12个字节。字节长度比int大了两倍，比long也多了一个int，但在现在的硬件配置中，多出的这些字节很难有理由成为限制系统的瓶颈所在，所以尽可放心使用。</p><p>::tip<br>初涉ObjectId很容易犯的两个错误：</p><ol><li><p>查询时直接使用类似db.collection.find({_id:”xx”})式的代码， 结果怎么也查不到明明存在的文档，而正确的写法应该是：db.collection.find({_id:new ObjectId(“xx”)})。</p></li><li><p>集合间有外键关联时，也需要将外键置为ObjectId类型，而不要直接使用上24字节的string。在写与 mongodb打交道的CRUD代码时，需要多留意ObjectId和string的转换代码。<br>::</p></li></ol><h3 id="db-collectionName-findOne"><a href="#db-collectionName-findOne" class="headerlink" title="db.[collectionName].findOne()"></a>db.[collectionName].findOne()</h3><p>查询集合中的第一条数据，这个语句的使用很又意义，类似于找到关系型数据库条件查询的返回数据的第一条。</p><h3 id="db-collectionName-update-查询条件-更新内容"><a href="#db-collectionName-update-查询条件-更新内容" class="headerlink" title="db.[collectionName].update( {查询条件}, {更新内容})"></a>db.[collectionName].update( {查询条件}, {更新内容})</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.update<span class="token punctuation">(</span>db.persons.findOne<span class="token punctuation">(</span><span class="token punctuation">)</span>,<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"name":"yanbo"&amp;#125;)</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &amp;#125;)</span><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e0bc9827fb3a4e9aa90"), "name" : "yanbo" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e13c9827fb3a4e9aa91"), "name" : "cat" &amp;#125;</span></code></pre><h3 id="db-collectionName-remove-…"><a href="#db-collectionName-remove-…" class="headerlink" title="db.[collectionName].remove( {…} )"></a>db.[collectionName].remove( {…} )</h3><p>删除文档数据</p><h2 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h2><h3 id="批量插入文档"><a href="#批量插入文档" class="headerlink" title="批量插入文档"></a>批量插入文档</h3><p>shell不支持批量插入，需要进行修改，可以使用for循环，mongoDB是基于js的语法。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> for<span class="token punctuation">(</span>var i<span class="token operator">=</span>0<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>5<span class="token punctuation">;</span>i++<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span><span class="token punctuation">..</span>. db.persons.insert<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"name":i&amp;#125;);</span><span class="token punctuation">..</span>. <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nInserted" : 1 &amp;#125;)</span><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e0bc9827fb3a4e9aa90"), "name" : "yanbo" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e13c9827fb3a4e9aa91"), "name" : "cat" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19756cc9827fb3a4e9aa92"), "name" : 0 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19756cc9827fb3a4e9aa93"), "name" : 1 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19756cc9827fb3a4e9aa94"), "name" : 2 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19756cc9827fb3a4e9aa95"), "name" : 3 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19756cc9827fb3a4e9aa96"), "name" : 4 &amp;#125;</span></code></pre><h3 id="save操作"><a href="#save操作" class="headerlink" title="save操作"></a>save操作</h3><p>如果在insert插入时_id已经存在（一般时人为设定_id时会重复，使用系统默认生成的_id则不会重复），会出现错误，因为主键不允许重复。</p><p>无法判断这样的情况时使用save命令，当遇到_id相同时save会自动完成修改操作，避免了insert的报错。</p><h3 id="删除-db-collectionName-remove-…"><a href="#删除-db-collectionName-remove-…" class="headerlink" title="删除 db.[collectionName].remove( {…} )"></a>删除 db.[collectionName].remove( {…} )</h3><p>db.[collectionName].remove( {…} )是删除指定文档数据，如果去掉条件就是删除集合中全部文档，但是集合本身和索引不会被删除。</p><h2 id="修改-更新-db-collectionName-update-查询条件-更新内容"><a href="#修改-更新-db-collectionName-update-查询条件-更新内容" class="headerlink" title="修改/更新 db.[collectionName].update( {查询条件}, {更新内容})"></a>修改/更新 db.[collectionName].update( {查询条件}, {更新内容})</h2><p>db.[collectionName].update( {查询条件}, {更新内容})中的更新内容中可以加入$set:{ field: value }修改器用于增加新的字段。如果不写修改器则默认为更改field操作。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.update<span class="token punctuation">(</span>db.persons.findOne<span class="token punctuation">(</span><span class="token punctuation">)</span>,<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;$set:&amp;#123;"age":"22"&amp;#125;&amp;#125;)</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &amp;#125;)</span><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d196e0bc9827fb3a4e9aa90"), "name" : "yanbo", "age" : "22" &amp;#125;</span></code></pre><h2 id="Select-查询"><a href="#Select-查询" class="headerlink" title="Select 查询"></a>Select 查询</h2><p>先插入模拟数据。</p><pre class=" language-js"><code class="language-js">db<span class="token punctuation">.</span>persons<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> personArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">"zhangsan"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token string">"1787948156@qq.com"</span><span class="token punctuation">,</span>    c <span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> m <span class="token punctuation">:</span> <span class="token number">78</span><span class="token punctuation">,</span> e <span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">,</span>    contry<span class="token punctuation">:</span> <span class="token string">"China"</span><span class="token punctuation">,</span>    books<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"JS"</span><span class="token punctuation">,</span> <span class="token string">"JAVA"</span><span class="token punctuation">,</span> <span class="token string">"MongoDB"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">"lichong"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token string">"1784512477@qq.com"</span><span class="token punctuation">,</span>    c <span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> m <span class="token punctuation">:</span> <span class="token number">82</span><span class="token punctuation">,</span> e <span class="token punctuation">:</span> <span class="token number">93</span><span class="token punctuation">,</span>    contry<span class="token punctuation">:</span> <span class="token string">"Japan"</span><span class="token punctuation">,</span>    books<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"JS"</span><span class="token punctuation">,</span> <span class="token string">"PHP"</span><span class="token punctuation">,</span> <span class="token string">"MongoDB"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">"lishuhuan"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token string">"17161515@qq.com"</span><span class="token punctuation">,</span>    c <span class="token punctuation">:</span> <span class="token number">75</span><span class="token punctuation">,</span> m <span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">,</span> e <span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>    contry<span class="token punctuation">:</span> <span class="token string">"china"</span><span class="token punctuation">,</span>    books<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"Vue"</span><span class="token punctuation">,</span> <span class="token string">"JAVA"</span><span class="token punctuation">,</span> <span class="token string">"MongoDB"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">"songhuan"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">21</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token string">"65871558@qq.com"</span><span class="token punctuation">,</span>    c <span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">,</span> m <span class="token punctuation">:</span> <span class="token number">87</span><span class="token punctuation">,</span> e <span class="token punctuation">:</span> <span class="token number">93</span><span class="token punctuation">,</span>    contry<span class="token punctuation">:</span> <span class="token string">"USA"</span><span class="token punctuation">,</span>    books<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"MySQL"</span><span class="token punctuation">,</span> <span class="token string">"JAVA"</span><span class="token punctuation">,</span> <span class="token string">"MongoDB"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">"wuyong"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">,</span>    email<span class="token punctuation">:</span> <span class="token string">"1568457953@qq.com"</span><span class="token punctuation">,</span>    c <span class="token punctuation">:</span> <span class="token number">84</span><span class="token punctuation">,</span> m <span class="token punctuation">:</span> <span class="token number">78</span><span class="token punctuation">,</span> e <span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">,</span>    contry<span class="token punctuation">:</span> <span class="token string">"Korea"</span><span class="token punctuation">,</span>    books<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"C++"</span><span class="token punctuation">,</span> <span class="token string">"JAVA"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>personArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    db<span class="token punctuation">.</span>persons<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>personArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="查询部分字段"><a href="#查询部分字段" class="headerlink" title="查询部分字段"></a>查询部分字段</h3><p>查询persons表中的name，age，contry字段</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;,&amp;#123;_id:0,name:1,age:1,contry:1&amp;#125;)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "zhangsan", "age" : 22, "contry" : "China" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "lichong", "age" : 23, "contry" : "Japan" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "lishuhuan", "age" : 22, "contry" : "china" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "songhuan", "age" : 21, "contry" : "USA" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "wuyong", "age" : 22, "contry" : "Korea" &amp;#125;</span></code></pre><p>db.collection.find( {条件}, {键指定})，在这里第一个参数条件可以不书写，表示空对象，表示全部查询，第二个参数表示要查询谁就设置谁为1，否则设置为0，_id默认会查询出来，当然也可以指定_id:0不查询。</p><p><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/compare.png" alt="compare"></p><p>查询年龄在21-22之间的学生的name，age</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;age:&amp;#123;$gte:21,$lte:22&amp;#125;&amp;#125;,&amp;#123;_id:0,name:1,age:1&amp;#125;)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "zhangsan", "age" : 22 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "lishuhuan", "age" : 22 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "songhuan", "age" : 21 &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "wuyong", "age" : 22 &amp;#125;</span></code></pre><p>查询条件<br>$in 包含<br>$nin 不包含</p><p>关于包含与不包含的关系，后面需要跟数组。</p><p>查询国籍是中国或美国的学生的姓名，国籍，年龄</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.persons.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;contry:&amp;#123;$in:["USA","china","China"]&amp;#125;&amp;#125;,&amp;#123;_id:0,name:1,contry:1,age:1&amp;#125;)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "zhangsan", "age" : 22, "contry" : "China" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "lishuhuan", "age" : 22, "contry" : "china" &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "name" : "songhuan", "age" : 21, "contry" : "USA" &amp;#125;</span></code></pre><p>find带条件类似于SQL中的where待条件查询</p><pre class=" language-bash"><code class="language-bash">db.persons.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"age":21&amp;#125;)</span><span class="token operator">==</span><span class="token operator">></span> <span class="token keyword">select</span> * from persons where age<span class="token operator">=</span>21db.persons.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"age":21,"name":"songhuan"&amp;#125;, &amp;#123;name:1,age:1,contry:1,_id:0&amp;#125;)</span><span class="token operator">==</span><span class="token operator">></span> <span class="token keyword">select</span> name,age,contry from persons where age<span class="token operator">=</span>21 and name<span class="token operator">=</span><span class="token string">'songhuan'</span></code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>实现方案一般有两种：嵌套和引用。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>一对多中进行嵌套，关系型数据是抽取主键进行关联。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> var classes <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span><span class="token punctuation">..</span>.     id:1,<span class="token punctuation">..</span>.     name:<span class="token string">"JAVA"</span>,<span class="token punctuation">..</span>.     students:<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span><span class="token punctuation">..</span>.         sid:1,<span class="token punctuation">..</span>.         name:<span class="token string">"zhangsan"</span><span class="token punctuation">..</span>.     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;,&amp;#123;</span><span class="token punctuation">..</span>.         sid:2,<span class="token punctuation">..</span>.         name:<span class="token string">"lisi"</span><span class="token punctuation">..</span>.     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;]</span><span class="token punctuation">..</span>. <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;;</span><span class="token operator">></span> db.classes.insert<span class="token punctuation">(</span>classes<span class="token punctuation">)</span><span class="token punctuation">;</span>WriteResult<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "nInserted" : 1 &amp;#125;)</span><span class="token operator">></span> db.classes.find<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "_id" : ObjectId("5d19be7cc9827fb3a4e9aa9c"), "id" : 1, "name" : "JAVA",</span> <span class="token string">"students"</span> <span class="token keyword">:</span> <span class="token punctuation">[</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "sid" : 1, "name" : "zhangsan" &amp;#125;, &amp;#123; "sid" : 2, "name" : "lisi" &amp;#125; ] &amp;#125;</span></code></pre><p>查询班级为JAVA的班级的第一个学生的sid</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.classes.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"name":"JAVA"&amp;#125;).forEach(function(e)&amp;#123;printjson(e.students[0].sid)&amp;#125;)</span>1</code></pre><p>查询id为1的班级中的所有学生</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> db.classes.find<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;"id":1&amp;#125;,&amp;#123;"students":1,"_id":0&amp;#125;)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123; "students":[&amp;#123; "sid" : 1, "name" : "zhangsan" &amp;#125;, &amp;#123; "sid" : 2, "name" : "lisi" &amp;#125; ] &amp;#125;</span></code></pre><p>嵌套数据保存在一个单一文档中，比较容易获得和维护数据，但是数据量的不断增加，会影响读写性能。<br>需要注意的是在findOne返回数据类型是一个对象，find返回的数据类型是数组</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p> 引用式关系是设计数据库时经常用到的方法，这种方法把用户数据文档和用户地址数据文档分开，通过引用文档的 id 字段来建立关系。这种方法需要两次查询，但是数据相互分离。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 菜鸟教程</a></p><p><a href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html">MongoDB 概念解析</a></p><p><a href="https://www.bilibili.com/video/av56886494">基于MongoDB实现商品管理系统视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>navigation包参数配置与原理略读</title>
      <link href="/2020/09/16/ji-lu/ros/navigation-bao-can-shu-pei-zhi-yu-yuan-li-lue-du/"/>
      <url>/2020/09/16/ji-lu/ros/navigation-bao-can-shu-pei-zhi-yu-yuan-li-lue-du/</url>
      
        <content type="html"><![CDATA[<h2 id="Navigation包参数调优"><a href="#Navigation包参数调优" class="headerlink" title="Navigation包参数调优"></a>Navigation包参数调优</h2><p><a href="https://github.com/teddyluo/ROSNavGuide-Chinese">ROS 导航功能调优指南</a></p><h2 id="DWAPlanner原理略读"><a href="#DWAPlanner原理略读" class="headerlink" title="DWAPlanner原理略读"></a>DWAPlanner原理略读</h2><p>动态窗口法</p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> SLAM </tag>
            
            <tag> navigation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APF方法的local planner</title>
      <link href="/2020/09/14/ji-lu/ros/apf-fang-fa-local-planner-cai-keng/"/>
      <url>/2020/09/14/ji-lu/ros/apf-fang-fa-local-planner-cai-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="人工势场法（Artificial-Potential-Field）"><a href="#人工势场法（Artificial-Potential-Field）" class="headerlink" title="人工势场法（Artificial Potential Field）"></a>人工势场法（Artificial Potential Field）</h2><p>移动机器人在给定初始点和最终点的情况下，在不与障碍物发生碰撞的情况下执行由自动路径规划模块规划出的路径到达最终点。</p><p>在实际情况下，部分或全部环境未知，路径规划通常使用基于行为的方法（Behavior based methods）和使用智能控制技术的方法（methods using Intelligent Control Techniques）。</p><p>已知环境中的路径规划包括生成供机器人遵循的路径，前提是该环境的整体（静态或动态）都是已知的。在这种情况下，方法可以被大致分为两类：最小化代价方法，势场法。最小化代价方法中一个很典型的算法就是的启发式A*算法。</p><p>人工势场法是势场法中避障规划路径的常见方法。人工势场法在障碍物周围使用斥力场来使得机器人离开（不碰撞），目标点周围使用吸引力场来吸引机器人。因此，机器人受到的总力等于总场势梯度的负值（矢量）。这样的合力驱动机器人朝着目标点的位置下降，直到其到达目标点或者停止（可能陷入局部最小，类似于梯度下降）。</p><p>人工势场法的主要问题以下几点：</p><ol><li>距离很近的障碍物之间没有通道（不能通过）；</li><li>在狭小环境下，机器人可能陷入平衡位置，并且会振荡或以闭环运行；</li><li>GNRON（Goals nonreachable with obstacle near by）无法到达障碍物附近的目标。</li></ol><h2 id="手动实现APF"><a href="#手动实现APF" class="headerlink" title="手动实现APF"></a>手动实现APF</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在激光的回调函数中调用，拿到Lansecan的数据，数据结构如下：</p><pre class=" language-bash"><code class="language-bash">sensor_msgs/LaserScanangle_min <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> scan 的开始角度 <span class="token punctuation">[</span>弧度<span class="token punctuation">]</span>angle_max <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> scan 的结束角度 <span class="token punctuation">[</span>弧度<span class="token punctuation">]</span>angle_increment <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> 测量的角度间的距离 <span class="token punctuation">[</span>弧度<span class="token punctuation">]</span>time_increment <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> 测量间的时间 <span class="token punctuation">[</span>秒<span class="token punctuation">]</span> – 如果扫描仪在移动,这将用于插入 3D 点的位置scan_time <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> 扫描间的时间 <span class="token punctuation">[</span>秒<span class="token punctuation">]</span>range_min <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> 最小的测量距离 <span class="token punctuation">[</span>米<span class="token punctuation">]</span>range_max <span class="token punctuation">(</span>float32<span class="token punctuation">)</span> 最大的测量距离 <span class="token punctuation">[</span>米<span class="token punctuation">]</span></code></pre><p>在world中拿到goal（目标点）和机器人所在位置坐标，分别为goal_（x，y），pose_（x，y）。然后计算goal与pose的欧式距离r，再使用atan2（dy，dx）计算出目标点相对当前位置的角度theta_goal，单位 [弧度]，其中dy = goal_（y）-pose_（y），dx同理。这里theta_goal是在世界坐标系中的，而非机器人坐标系。</p><pre class=" language-cpp"><code class="language-cpp">pose_x <span class="token operator">=</span> goal_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x <span class="token operator">-</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x<span class="token punctuation">;</span>pose_y <span class="token operator">=</span> goal_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y <span class="token operator">-</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">float</span> theta_goal <span class="token operator">=</span> <span class="token function">atan2</span><span class="token punctuation">(</span>pose_y<span class="token punctuation">,</span> pose_x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>pose_x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>pose_y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="引力"><a href="#引力" class="headerlink" title="引力"></a>引力</h3><p>引力场计算公式：</p><p>$$<br>U_{att}(q) = \frac12\xi r^2<br>$$</p><p>引力场下的引力计算为：</p><p>$$<br>F_{att} = -\Delta U_{att}(q) = \xi r<br>$$</p><p>这里将系数设置为GOAL_FORCE（default=1），需要进行世界坐标系的xy分解：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//常量定义</span><span class="token macro property">#<span class="token directive keyword">define</span> PI 3.14</span><span class="token macro property">#<span class="token directive keyword">define</span> GOAL_FORCE 1      </span><span class="token comment" spellcheck="true">// 目标吸引力因子</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pose_x <span class="token operator">=</span> goal_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x <span class="token operator">-</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x<span class="token punctuation">;</span>pose_y <span class="token operator">=</span> goal_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y <span class="token operator">-</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token keyword">float</span> theta_goal <span class="token operator">=</span> <span class="token function">atan2</span><span class="token punctuation">(</span>pose_y<span class="token punctuation">,</span> pose_x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>pose_x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>pose_y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> goal_force <span class="token operator">=</span> GOAL_FORCE <span class="token operator">*</span> r<span class="token punctuation">;</span><span class="token keyword">float</span> goal_x <span class="token operator">=</span> goal_force <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>theta_goal<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">float</span> goal_y <span class="token operator">=</span> goal_force <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>theta_goal<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里实现的上是冗余的，所以可以进行简化，直接写成引力计算的公式，但是后面需要可视化引力，这里就保留较为复杂的写法。</p><h3 id="斥力"><a href="#斥力" class="headerlink" title="斥力"></a>斥力</h3><p>斥力场计算公式：</p><p>$$<br>U_{rep}(q) = \frac12 \eta \left( \frac{1}{\rho (q,q_{obs})} - \frac1{\rho_0} \right)^2 \rho ^n(q,q_{goal}), \rho (q,q_{obs}) \leq \rho_0<br>$$</p><p>$$<br>U_{rep}(q) = 0, \rho (q,q_{obs}) &gt; \rho_0<br>$$</p><p>这里需要设置两个系数，参数n和阈值p0,在原有的斥力场中加上目标点和机器人距离的影响，来缓解GNRON问题。参数n一般设置为2，阈值p0是障碍物的影响半径，如果机器人距离障碍物一定距离，即使可以看见障碍物，也对机器人没有影响。</p><p>在斥力影响不为0时刻的斥力计算公式：</p><p>$$<br>F_{rep}(q) = -\Delta U_{rep}(q) = F_{rep1}n_{OR} + F_{req2}n_{RG} , \rho (q,q_{obs}) \leq \rho_0<br>$$</p><p>$$<br>F_{rep1}=\eta \left( \frac1{\rho (q,q_{obs})} - \frac1{\rho_0} \right) \frac{\rho ^n(q,q_{goal})}{\rho (q,q_{obs})},F_{req2}=\frac{n}{2}\eta \left( \frac1{\rho (q,q_{obs})} - \frac1{\rho_0} \right)^2\rho ^{n-1}(q,q_{goal})<br>$$</p><p>这里对标在激光中的实现还是有些问题，所以采用了一种另一种处理方式：</p><ol><li>遍历激光数据，找到距离机器人最近的障碍物距离 temp_min，以及其对应的range[i]的下标 temp_min_i。</li><li>然后计算这个最近点对机器人的斥力。采用传统斥力公式。</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//常量定义</span><span class="token macro property">#<span class="token directive keyword">define</span> MAX_RANGE 0.3 </span><span class="token comment" spellcheck="true">//机器人探测半径，也可以理解为障碍物影响距离</span><span class="token macro property">#<span class="token directive keyword">define</span> ROBOT_RADIUS 0.10 </span><span class="token comment" spellcheck="true">//机器人半径，默认机器人为圆形</span><span class="token macro property">#<span class="token directive keyword">define</span> REPULSE_FORCE 0.1  </span><span class="token comment" spellcheck="true">// 斥力因子</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">float</span> temp_min <span class="token operator">=</span> MAX_RANGE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获得与机器人最近的障碍物距离来控制速度减小</span><span class="token keyword">int</span> temp_min_i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对应最小距离的range下标</span><span class="token comment" spellcheck="true">// 计算激光探测到的力（障碍物的斥力），分解到x，y方向（世界坐标系）</span><span class="token keyword">float</span> repulsion_resultant_x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">float</span> repulsion_resultant_y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// laser_msg_这里是激光数据的数据结构，定义为sensor_msgs::LaserScan</span><span class="token keyword">int</span> total_points <span class="token operator">=</span> <span class="token punctuation">(</span>laser_msg_<span class="token punctuation">.</span>angle_max <span class="token operator">-</span> laser_msg_<span class="token punctuation">.</span>angle_min<span class="token punctuation">)</span> <span class="token operator">/</span> laser_msg_<span class="token punctuation">.</span>angle_increment<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total_points<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>laser_msg_<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> MAX_RANGE <span class="token operator">||</span> laser_msg_<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>laser_msg_<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ROBOT_RADIUS<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> r_laser <span class="token operator">=</span> laser_msg_<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ROBOT_RADIUS<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r_laser <span class="token operator">&lt;</span> temp_min<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      temp_min <span class="token operator">=</span> r_laser<span class="token punctuation">;</span>      temp_min_i <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果存在最近障碍物，将最近障碍物角度 laser_radian_global 转换到世界坐标系：先计算机器人坐标系坐标偏转 laser_radian，加上yaw角度（这里yaw角度放在了位姿的z轴中，因为机器人不存在高度上的移动，所以简化和充分利用pose数据结构将yaw放在了 pose_.pose.position.z中）</span><span class="token comment" spellcheck="true">// 之后使用斥力公式计算，这里为了表示方向相反而乘上了负号</span><span class="token keyword">if</span> <span class="token punctuation">(</span>temp_min_i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">float</span> laser_radian <span class="token operator">=</span> laser_msg_<span class="token punctuation">.</span>angle_min <span class="token operator">+</span> laser_msg_<span class="token punctuation">.</span>angle_increment <span class="token operator">*</span> temp_min_i<span class="token punctuation">;</span>  <span class="token keyword">float</span> laser_radian_global <span class="token operator">=</span> laser_radian <span class="token operator">+</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z<span class="token punctuation">;</span>  repulsion_resultant_x <span class="token operator">=</span> <span class="token operator">-</span>REPULSE_FORCE <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>laser_radian_global<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">pow</span><span class="token punctuation">(</span>temp_min<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  repulsion_resultant_y <span class="token operator">=</span> <span class="token operator">-</span>REPULSE_FORCE <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>laser_radian_global<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">pow</span><span class="token punctuation">(</span>temp_min<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="合力"><a href="#合力" class="headerlink" title="合力"></a>合力</h3><p>力的合成高中物理，无需赘述。合成之后如果合力的方向与目标引力的方向一致，可能落入局部最小，需要给予扰动力让其逃逸。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 计算在x，y轴方向上的合力：斥合力+吸引力, attention: *r</span><span class="token keyword">float</span> force_x <span class="token operator">=</span> repulsion_resultant_x <span class="token operator">*</span> r <span class="token operator">+</span> goal_x<span class="token punctuation">;</span><span class="token keyword">float</span> force_y <span class="token operator">=</span> repulsion_resultant_y <span class="token operator">*</span> r <span class="token operator">+</span> goal_y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// x，y分量合成合力</span><span class="token comment" spellcheck="true">// force = sqrt(pow(force_x, 2) + pow(force_y, 2));</span>theta <span class="token operator">=</span> <span class="token function">atan2</span><span class="token punctuation">(</span>force_y<span class="token punctuation">,</span> force_x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>theta_goal <span class="token operator">==</span> theta<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  theta <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>此外机器人移动发布的消息类型为cmd_vel需要指定线速度和角速度，所以需要进行合力到速度的映射。角速度需要优先考虑，因为机器人的旋转是其改变方向避开障碍物的第一步，这里就是计算出合力角度 theta 和 yaw的差值角度，假设时间间隔dt = 1来将其直接设置为角速度 angular.z；线速度如果变动不光滑在初步实现demo的时候也不用太过在意，直接写死简化处理方式（注释代码段，这个地方其实也有bug，因为速度的线性减小会逐步累加而导致最后速度很小，需要额外增加恢复函数）。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 角度变化并放缩到-PI到PI之间</span><span class="token keyword">float</span> radian_speed <span class="token operator">=</span> theta <span class="token operator">-</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>radian_speed <span class="token operator">></span> PI<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  radian_speed <span class="token operator">=</span> radian_speed <span class="token operator">-</span> <span class="token number">2</span><span class="token operator">*</span>PI<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>radian_speed <span class="token operator">&lt;</span> <span class="token operator">-</span>PI<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  radian_speed <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>PI <span class="token operator">+</span> radian_speed<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>geometry_msgs<span class="token punctuation">:</span><span class="token punctuation">:</span>Twist vel_msg<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// float cur_vx = 0.5;</span>    <span class="token comment" spellcheck="true">// float new_vx = cur_vx * temp_min / MAX_RANGE; // 越靠近物体速度越小</span>    vel_msg<span class="token punctuation">.</span>linear<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.35</span><span class="token punctuation">;</span>    vel_msg<span class="token punctuation">.</span>linear<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    vel_msg<span class="token punctuation">.</span>linear<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    vel_msg<span class="token punctuation">.</span>angular<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    vel_msg<span class="token punctuation">.</span>angular<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    vel_msg<span class="token punctuation">.</span>angular<span class="token punctuation">.</span>z <span class="token operator">=</span> radian_speed<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 角度充当角速度，dt=1</span>    vel_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>vel_msg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在初步需要实现代码到系统中的时候遇到了许多问题和坑：</p><ul><li>不需要发布点云——最开始的时候将激光数据发布到点云，后来发现这个回调只需要计算合力大小与方向即可，不需要发布点云，删去这个部分代码</li><li>atan2方法的参数为y，x——注意这里的顺序是先y后x，我不小心写成了atan2（x，y）导致角度计算不正确，花了好大力气一步步审查代码才发现，函数使用请细心；</li><li>计算出theta为世界坐标系中的弧度值——因为LaserScan中的angle_min与angle_max都是在世界坐标系下的弧度值，且已知angle_increment可以直接计算，但是不能直接使用这个做x，y分解的角度，因为引力是分解到世界坐标系中的，所以斥力以应该如此，需要在theta与yaw做运算和之后才行</li><li>启发式算法以计算角度差值代替角速度值</li><li>线速度与角速度的平滑函数很复杂，之前尝试使用加速度与角加速度去实现速度映射，发现不可行，机器人的运动无法预测。</li><li>善用可视化——在最开始遇到机器人的运动无法预测没有想到可视化，只是将数据打印了出来，然后使用rqt工具观察，发现角速度的变化是正常的，而合力很小，斥力很大，大的离谱，这时候合力对机器人的运动起不到影响作用，斥力直接影响合力方向，后面查看代码时候发现是这一段：</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span>int i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total_points<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>scan_filtered<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> MAX_RANGE <span class="token operator">||</span> scan_filtered<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>scan_filtered<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> ROBOT_RADIUS<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                float r_laser <span class="token operator">=</span> scan_filtered<span class="token punctuation">.</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ROBOT_RADIUS<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>r_laser <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    repulsion_resultant_x <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">-</span>REPULSE_FORCE <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>scan_filtered<span class="token punctuation">.</span>angle_min <span class="token operator">+</span> scan_filtered<span class="token punctuation">.</span>angle_increment <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">pow</span><span class="token punctuation">(</span>r_laser<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    repulsion_resultant_y <span class="token operator">+</span><span class="token operator">=</span> <span class="token operator">-</span>REPULSE_FORCE <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>scan_filtered<span class="token punctuation">.</span>angle_min <span class="token operator">+</span> scan_filtered<span class="token punctuation">.</span>angle_increment <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">pow</span><span class="token punctuation">(</span>r_laser<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上一段代码是有几个错误的，包括之前说的计算出theta为世界坐标系中的弧度值，这里使用机器人坐标系的角度分解是错误的。但是我想说的重点在斥力计算的部分：这里代码含义为只要在机器人探测范围内有效的障碍物的粒子点都参与斥力计算，而且斥力是加和（+=）的，导致在机器人距离物体很近的时候，粒子很多，每个粒子都提供斥力，累和数值很大，所以后之后绝得将其修改为了一个粒子的影响。<br>这个问题是在进行引力、斥力和合力的可视化之后才发现的，可视化的部分代码如下：将力的数据处理成PoseStamped格式进行发布，只显示方向，大小从topic输出的数值来看。pose中最重要的方向orientation，将theta转化为四元数输出，同理对引力theta_goal、斥力atan2(repulsion_resultant_y, repulsion_resultant_x)也是一样的做法。</p><pre class=" language-cpp"><code class="language-cpp">std_msgs<span class="token operator">::</span>Float32 force_msg<span class="token punctuation">;</span>force_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> force_x<span class="token punctuation">;</span>force_x_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>force_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> force_y<span class="token punctuation">;</span>force_y_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>force_msg<span class="token punctuation">.</span>data <span class="token operator">=</span> radian_speed<span class="token punctuation">;</span>w_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>geometry_msgs<span class="token operator">::</span>PoseStamped force_dir_msg<span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>header<span class="token punctuation">.</span>frame_id <span class="token operator">=</span> <span class="token string">"map"</span><span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>header<span class="token punctuation">.</span>stamp <span class="token operator">=</span> ros<span class="token operator">::</span>Time<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x <span class="token operator">=</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x<span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y <span class="token operator">=</span> pose_<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y<span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>orientation <span class="token operator">=</span> tf<span class="token operator">::</span><span class="token function">createQuaternionMsgFromRollPitchYaw</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> theta<span class="token punctuation">)</span><span class="token punctuation">;</span>force_direction_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_dir_msg<span class="token punctuation">)</span><span class="token punctuation">;</span>force_dir_msg<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>orientation <span class="token operator">=</span> tf<span class="token operator">::</span><span class="token function">createQuaternionMsgFromRollPitchYaw</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> theta_goal<span class="token punctuation">)</span><span class="token punctuation">;</span>att_force_direction_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_dir_msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 斥力有才发布</span><span class="token keyword">if</span> <span class="token punctuation">(</span>repulsion_resultant_y <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> repulsion_resultant_x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  force_dir_msg<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>orientation <span class="token operator">=</span> tf<span class="token operator">::</span><span class="token function">createQuaternionMsgFromRollPitchYaw</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">atan2</span><span class="token punctuation">(</span>repulsion_resultant_y<span class="token punctuation">,</span> repulsion_resultant_x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  rep_force_direction_pub_<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>force_dir_msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在rviz中展示的效果如下：<br><img src="https://cdn.jsdelivr.net/gh/zhangyuanes/thirdPic/img/apf-rviz.jpg" alt="apf-rviz"></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> SLAM </tag>
            
            <tag> 人工势场法 </tag>
            
            <tag> 局部路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World to Hexo</title>
      <link href="/2020/09/11/hello-world/"/>
      <url>/2020/09/11/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>我的blog很大程度上不算blog，算是个整合贴。我的blog的流程一般是这样的：</p><p>遇到一个实际问题，或者从完全不了解到初步入门，我会保留自己在解决这个问题的浏览器历史搜索记录（请务必科学上网）、大致流程、特殊问题和解决方案。</p><p>一般不再书写别人已经写作的内容，仅仅贴上链接。虽然不排除链接实效的情况，但是一般来说链接是稳定的。万一实在链接失效，也可以搜索关键词找寻更新的教程。在此不再赘述。</p><h2 id="使用Github-Pages和Hexo构建个人博客"><a href="#使用Github-Pages和Hexo构建个人博客" class="headerlink" title="使用Github Pages和Hexo构建个人博客"></a><a href="https://developer.aliyun.com/article/387750">使用Github Pages和Hexo构建个人博客</a></h2><p>此项目是基于gitpage的托管，在本地nodejs平台渲染hexo项目生成的静态网站。</p><p>静态博客文档的书写一方面是记录了博主的工作，另一方面在线分享也节省了有同样问题或者想要了解、从事某方面研究的人的调研时间，一举两得。</p><p>感谢所有愿意分享的博主，你们的无私让整个社区更加美好。</p><h3 id="Valine无后端评论系统"><a href="#Valine无后端评论系统" class="headerlink" title="Valine无后端评论系统"></a><a href="https://valine.js.org/">Valine无后端评论系统</a></h3><p>这是静态网站中不那么静态的部分——评论系统。</p><p>后台存储使用的是LeanCloud。详细配置文档中有细致说明。</p><h2 id="使用jekyll构建gitpage静态网页"><a href="#使用jekyll构建gitpage静态网页" class="headerlink" title="使用jekyll构建gitpage静态网页"></a><a href="https://sspai.com/post/54608">使用jekyll构建gitpage静态网页</a></h2><p>这是另一种实现静态网站的方案，但是jekyll是基于ruby的，对于windows用户可能不是那么友好，所以推荐使用前面的方案。</p><h2 id="Ubuntu安装Node环境"><a href="#Ubuntu安装Node环境" class="headerlink" title="Ubuntu安装Node环境"></a><a href="https://mupceet.com/2020/02/the-best-way-to-install-nodejs/">Ubuntu安装Node环境</a></h2><p>windows下直接安装就OK。这里采用了NVM的Node版本管理来做安装,并使用国内镜像。</p><h3 id="NVM-github"><a href="#NVM-github" class="headerlink" title="NVM github"></a><a href="https://github.com/nvm-sh/nvm#installing-and-updating">NVM github</a></h3><h2 id="仓库主题下载使用"><a href="#仓库主题下载使用" class="headerlink" title="仓库主题下载使用"></a>仓库主题下载使用</h2><p><a href="https://github.com/zhangyuanes/blinkTheme">仓库地址</a>,请参照 readme运行，参照 themes\hexo-theme-matery\README_CN.md 中说明配置详细主题信息.</p><p>根据自己需求进行自定义修改和美化的blinkfox的hexo主题。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>安装NodeJS（Windows，Linux，MacOS均可）。</p><h3 id="Fork仓库后使用git克隆项目"><a href="#Fork仓库后使用git克隆项目" class="headerlink" title="Fork仓库后使用git克隆项目"></a>Fork仓库后使用git克隆项目</h3><p>点击fork按钮fork到自己的账号下，这样你的配置就可以保存下来了。</p><pre><code>git clone https://github.com/zhangyuanes/blinkTheme.git</code></pre><h3 id="进入项目文件夹，安装依赖包"><a href="#进入项目文件夹，安装依赖包" class="headerlink" title="进入项目文件夹，安装依赖包"></a>进入项目文件夹，安装依赖包</h3><pre><code>cd blinkThemenpm install</code></pre><h3 id="清理并生成渲染"><a href="#清理并生成渲染" class="headerlink" title="清理并生成渲染"></a>清理并生成渲染</h3><pre><code>npm run cleannpm run build</code></pre><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> run server</code></pre><p>访问<code>http://localhost:4000</code>即可看到页面。</p><h3 id="使用hexo-admin做后台dashboard"><a href="#使用hexo-admin做后台dashboard" class="headerlink" title="使用hexo-admin做后台dashboard"></a>使用hexo-admin做后台dashboard</h3><p>预先配置有hexo-admin，在url结尾加入<code>/admin</code>即可进入管理页面，可以在线md交互预览编辑。用户名和密码我配置的为：yanbo，你可以修改配置文件来自定义，相关配置在<code>_config.yml</code>中:</p><pre class=" language-yml"><code class="language-yml"># hexo-admin authentification# 在本地浏览的时候在url之后加上admin即可访问# 这里的password是密码经过sha256加密admin:  username: yanbo  password_hash: $2a$10$SD3chEWmZ4/qWCOOvmVv3ut5/lKgPqDx5YBLwtZHt07/XzcG4TEAK  secret: yanbo  deployCommand: 'hexo-deploy.bat'</code></pre><h3 id="推送到github-io"><a href="#推送到github-io" class="headerlink" title="推送到github.io"></a>推送到github.io</h3><p>如果你没有设置这个gitpage仓库，<a href="https://zhangyuanes.github.io/2020/09/11/hello-world/">参考这里</a>.</p><p>需要预先设置项目根目录下的<code>_config.yml</code>中的部署deploy配置：</p><pre><code># Deploymentdeploy:  type: git  repo: https://github.com/********/********.github.io.git  branch: master</code></pre><p>预览渲染没有问题可以使用命令推送到gitpage，推从到github.io仓库中，使用命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> run deploy</code></pre><p>当显示成功后刷新仓库，就可以访问到对应的页面了，页面地址为 <code>https://YourGithubName.github.io</code>。</p><h3 id="编写你的文章"><a href="#编写你的文章" class="headerlink" title="编写你的文章"></a>编写你的文章</h3><p>清除<code>source/_posts</code>下全部文章页（但请至少保留一个md文件用于生成页面，否则build会失败），完成<code>_config.yml</code>中其他个性化配置后重新清理并生成渲染，预览后推送即可。</p><p><code>_config.yml</code>已经添加很多中文注释，如果需要请按照注释修改即可。</p><p>本项目代码唯一需要用户单独存档的仅仅为<code>source/_posts</code>下的原始md文章页面以及对应的配图。</p><p>配图建议使用图床，这样就不用担心相对引用，相关文章<a href="https://zhangyuanes.github.io/2021/01/19/ji-lu/bo-ke-da-jian/tu-chuang-da-jian/">参考这里</a>。本仓库的配图还是比较大的，后续会逐渐修改为图床链接。</p><p>补：如果不是图床的图片，配图请放在<code>source/medias</code>中，如果需要分类请在此文件夹下新建文件夹放置即可，在页面中引用地址为：<code>/medias/******.jpg</code>。</p><p>md文章的编写如果不清楚可以先参考我的md，里面基本内容包括：header和正文。</p><p>header需要用三个连接号显式表示出来，字段和含义如下 ： <code>title</code> 文章标题, <code>date</code> 时间, <code>author</code> 作者, <code>categories</code> 分类,<code>tags</code> 文章标签。</p><p>header写完后就是正文，直接兼容全部的md语法，自由书写即可。</p><pre class=" language-md"><code class="language-md">---title: Hello World to Hexodate: 2020-09-11 20:26:00author: zhangyuanescategories: 博客搭建tags:  - Hexo  - Gitpage---<你的文章内容></code></pre><h3 id="如有其他问题请提交issue或发邮件询问。"><a href="#如有其他问题请提交issue或发邮件询问。" class="headerlink" title="如有其他问题请提交issue或发邮件询问。"></a>如有其他问题请提交issue或发邮件询问。</h3>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Gitpage </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
